//-------------------------------------------------------------------------
// MeshMultiCgraRTL__22e761dce011167a.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL BitStruct CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 Definition
typedef struct packed {
  logic [31:0] payload;
  logic [0:0] predicate;
  logic [0:0] bypass;
  logic [0:0] delay;
} CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1;

// PyMTL BitStruct CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf Definition
typedef struct packed {
  logic [5:0] operation;
  logic [0:0] predicate;
  logic [3:0][2:0] fu_in;
  logic [7:0][2:0] routing_xbar_outport;
  logic [7:0][1:0] fu_xbar_outport;
  logic [3:0][0:0] routing_predicate_in;
  logic [2:0] vector_factor_power;
  logic [0:0] is_last_ctrl;
  logic [3:0][1:0] write_reg_from;
  logic [3:0][3:0] write_reg_idx;
  logic [3:0][0:0] read_reg_from;
  logic [3:0][3:0] read_reg_idx;
} CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf;

// PyMTL BitStruct MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__cc89ed621b71ae36 Definition
typedef struct packed {
  logic [3:0] cmd;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 data;
  logic [8:0] data_addr;
  CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf ctrl;
  logic [3:0] ctrl_addr;
} MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__cc89ed621b71ae36;

// PyMTL BitStruct InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d Definition
typedef struct packed {
  logic [3:0] src;
  logic [3:0] dst;
  logic [1:0] src_x;
  logic [1:0] src_y;
  logic [1:0] dst_x;
  logic [1:0] dst_y;
  logic [2:0] src_tile_id;
  logic [2:0] dst_tile_id;
  logic [7:0] opaque;
  logic [1:0] vc_id;
  MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__cc89ed621b71ae36 payload;
} InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d;

// PyMTL BitStruct IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 Definition
typedef struct packed {
  logic [2:0] src;
  logic [2:0] dst;
  logic [3:0] src_cgra_id;
  logic [3:0] dst_cgra_id;
  logic [1:0] src_cgra_x;
  logic [1:0] src_cgra_y;
  logic [1:0] dst_cgra_x;
  logic [1:0] dst_cgra_y;
  logic [7:0] opaque;
  logic [0:0] vc_id;
  MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__cc89ed621b71ae36 payload;
} IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74;

// PyMTL BitStruct ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f Definition
typedef struct packed {
  logic [0:0] dst;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d inter_cgra_pkt;
} ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f;

// PyMTL BitStruct TileSramXbarPacket_4_3_288__c14254250acb3a03 Definition
typedef struct packed {
  logic [1:0] src;
  logic [1:0] dst;
  logic [8:0] addr;
  logic [3:0] src_cgra;
  logic [2:0] src_tile;
} TileSramXbarPacket_4_3_288__c14254250acb3a03;

// PyMTL BitStruct CGRAData_1_1__payload_1__predicate_1 Definition
typedef struct packed {
  logic [0:0] payload;
  logic [0:0] predicate;
} CGRAData_1_1__payload_1__predicate_1;

// PyMTL BitStruct MeshPosition_3x3__pos_x_2__pos_y_2 Definition
typedef struct packed {
  logic [1:0] pos_x;
  logic [1:0] pos_y;
} MeshPosition_3x3__pos_x_2__pos_y_2;

// PyMTL Component BypassQueueCtrlRTL Definition
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py

module BypassQueueCtrlRTL__num_entries_2
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  output logic [0:0] mux_sel ,
  output logic [0:0] raddr ,
  output logic [0:0] recv_rdy ,
  input  logic [0:0] recv_val ,
  input  logic [0:0] reset ,
  input  logic [0:0] send_rdy ,
  output logic [0:0] send_val ,
  output logic [0:0] waddr ,
  output logic [0:0] wen 
);
  localparam logic [1:0] __const__num_entries_at__lambda__s_dut_cgra_0__controller_crossbar_input_units_0__queue_ctrl_recv_rdy  = 2'd2;
  localparam logic [1:0] __const__num_entries_at_up_reg  = 2'd2;
  logic [0:0] head;
  logic [0:0] recv_xfer;
  logic [0:0] send_xfer;
  logic [0:0] tail;

  // PyMTL Lambda Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py:484
  // s.mux_sel //= lambda: s.count == 0
  
  always_comb begin : _lambda__s_dut_cgra_0__controller_crossbar_input_units_0__queue_ctrl_mux_sel
    mux_sel = count == 2'd0;
  end

  // PyMTL Lambda Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py:481
  // s.recv_rdy //= lambda: s.count < num_entries
  
  always_comb begin : _lambda__s_dut_cgra_0__controller_crossbar_input_units_0__queue_ctrl_recv_rdy
    recv_rdy = count < 2'( __const__num_entries_at__lambda__s_dut_cgra_0__controller_crossbar_input_units_0__queue_ctrl_recv_rdy );
  end

  // PyMTL Lambda Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py:486
  // s.recv_xfer //= lambda: s.recv_val & s.recv_rdy
  
  always_comb begin : _lambda__s_dut_cgra_0__controller_crossbar_input_units_0__queue_ctrl_recv_xfer
    recv_xfer = recv_val & recv_rdy;
  end

  // PyMTL Lambda Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py:482
  // s.send_val //= lambda: (s.count > 0) | s.recv_val
  
  always_comb begin : _lambda__s_dut_cgra_0__controller_crossbar_input_units_0__queue_ctrl_send_val
    send_val = ( count > 2'd0 ) | recv_val;
  end

  // PyMTL Lambda Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py:487
  // s.send_xfer //= lambda: s.send_val & s.send_rdy
  
  always_comb begin : _lambda__s_dut_cgra_0__controller_crossbar_input_units_0__queue_ctrl_send_xfer
    send_xfer = send_val & send_rdy;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py:489
  // @update_ff
  // def up_reg():
  // 
  //   if s.reset:
  //     s.head  <<= 0
  //     s.tail  <<= 0
  //     s.count <<= 0
  // 
  //   else:
  //     if s.recv_xfer:
  //       s.tail <<= s.tail + 1 if ( s.tail < num_entries - 1 ) else 0
  // 
  //     if s.send_xfer:
  //       s.head <<= s.head + 1 if ( s.head < num_entries -1 ) else 0
  // 
  //     if s.recv_xfer & ~s.send_xfer:
  //       s.count <<= s.count + 1
  //     if ~s.recv_xfer & s.send_xfer:
  //       s.count <<= s.count - 1
  
  always_ff @(posedge clk) begin : up_reg
    if ( reset ) begin
      head <= 1'd0;
      tail <= 1'd0;
      count <= 2'd0;
    end
    else begin
      if ( recv_xfer ) begin
        tail <= ( tail < ( 1'( __const__num_entries_at_up_reg ) - 1'd1 ) ) ? tail + 1'd1 : 1'd0;
      end
      if ( send_xfer ) begin
        head <= ( head < ( 1'( __const__num_entries_at_up_reg ) - 1'd1 ) ) ? head + 1'd1 : 1'd0;
      end
      if ( recv_xfer & ( ~send_xfer ) ) begin
        count <= count + 2'd1;
      end
      if ( ( ~recv_xfer ) & send_xfer ) begin
        count <= count - 2'd1;
      end
    end
  end

  assign wen = recv_xfer;
  assign waddr = tail;
  assign raddr = head;

endmodule


// PyMTL Component Mux Definition
// Full name: Mux__Type_ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f__ninputs_2
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py

module Mux__c929e5ab74891dae
(
  input  logic [0:0] clk ,
  input  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f in_ [0:1],
  output ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py

module RegisterFile__c68a654c5b045145
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f regs [0:1];

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component BypassQueueDpathRTL Definition
// Full name: BypassQueueDpathRTL__EntryType_ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f__num_entries_2
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py

module BypassQueueDpathRTL__12e4bd34e2c6eb7b
(
  input  logic [0:0] clk ,
  input  logic [0:0] mux_sel ,
  input  logic [0:0] raddr ,
  input  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f recv_msg ,
  input  logic [0:0] reset ,
  output ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f send_msg ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component mux
  //-------------------------------------------------------------

  logic [0:0] mux__clk;
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f mux__in_ [0:1];
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f mux__out;
  logic [0:0] mux__reset;
  logic [0:0] mux__sel;

  Mux__c929e5ab74891dae mux
  (
    .clk( mux__clk ),
    .in_( mux__in_ ),
    .out( mux__out ),
    .reset( mux__reset ),
    .sel( mux__sel )
  );

  //-------------------------------------------------------------
  // End of component mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component rf
  //-------------------------------------------------------------

  logic [0:0] rf__clk;
  logic [0:0] rf__raddr [0:0];
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f rf__rdata [0:0];
  logic [0:0] rf__reset;
  logic [0:0] rf__waddr [0:0];
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f rf__wdata [0:0];
  logic [0:0] rf__wen [0:0];

  RegisterFile__c68a654c5b045145 rf
  (
    .clk( rf__clk ),
    .raddr( rf__raddr ),
    .rdata( rf__rdata ),
    .reset( rf__reset ),
    .waddr( rf__waddr ),
    .wdata( rf__wdata ),
    .wen( rf__wen )
  );

  //-------------------------------------------------------------
  // End of component rf
  //-------------------------------------------------------------

  assign rf__clk = clk;
  assign rf__reset = reset;
  assign rf__raddr[0] = raddr;
  assign rf__wen[0] = wen;
  assign rf__waddr[0] = waddr;
  assign rf__wdata[0] = recv_msg;
  assign mux__clk = clk;
  assign mux__reset = reset;
  assign mux__sel = mux_sel;
  assign mux__in_[0] = rf__rdata[0];
  assign mux__in_[1] = recv_msg;
  assign send_msg = mux__out;

endmodule


// PyMTL Component BypassQueueRTL Definition
// Full name: BypassQueueRTL__EntryType_ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f__num_entries_2
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py

module BypassQueueRTL__12e4bd34e2c6eb7b
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__mux_sel;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__recv_rdy;
  logic [0:0] ctrl__recv_val;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__send_rdy;
  logic [0:0] ctrl__send_val;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  BypassQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .mux_sel( ctrl__mux_sel ),
    .raddr( ctrl__raddr ),
    .recv_rdy( ctrl__recv_rdy ),
    .recv_val( ctrl__recv_val ),
    .reset( ctrl__reset ),
    .send_rdy( ctrl__send_rdy ),
    .send_val( ctrl__send_val ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  logic [0:0] dpath__mux_sel;
  logic [0:0] dpath__raddr;
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f dpath__recv_msg;
  logic [0:0] dpath__reset;
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f dpath__send_msg;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  BypassQueueDpathRTL__12e4bd34e2c6eb7b dpath
  (
    .clk( dpath__clk ),
    .mux_sel( dpath__mux_sel ),
    .raddr( dpath__raddr ),
    .recv_msg( dpath__recv_msg ),
    .reset( dpath__reset ),
    .send_msg( dpath__send_msg ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign dpath__mux_sel = ctrl__mux_sel;
  assign ctrl__recv_val = recv__val;
  assign recv__rdy = ctrl__recv_rdy;
  assign send__val = ctrl__send_val;
  assign ctrl__send_rdy = send__rdy;
  assign count = ctrl__count;
  assign dpath__recv_msg = recv__msg;
  assign send__msg = dpath__send_msg;

endmodule


// PyMTL Component InputUnitRTL Definition
// Full name: InputUnitRTL__PacketType_ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f__QueueType_BypassQueueRTL
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/InputUnitRTL.py

module InputUnitRTL__2bc5d380f554ae63
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [1:0] queue__count;
  logic [0:0] queue__reset;
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f queue__recv__msg;
  logic [0:0] queue__recv__rdy;
  logic [0:0] queue__recv__val;
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f queue__send__msg;
  logic [0:0] queue__send__rdy;
  logic [0:0] queue__send__val;

  BypassQueueRTL__12e4bd34e2c6eb7b queue
  (
    .clk( queue__clk ),
    .count( queue__count ),
    .reset( queue__reset ),
    .recv__msg( queue__recv__msg ),
    .recv__rdy( queue__recv__rdy ),
    .recv__val( queue__recv__val ),
    .send__msg( queue__send__msg ),
    .send__rdy( queue__send__rdy ),
    .send__val( queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__recv__msg = recv__msg;
  assign recv__rdy = queue__recv__rdy;
  assign queue__recv__val = recv__val;
  assign send__msg = queue__send__msg;
  assign queue__send__rdy = send__rdy;
  assign send__val = queue__send__val;

endmodule


// PyMTL Component OutputUnitRTL Definition
// Full name: OutputUnitRTL__PacketType_ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f__QueueType_None
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/OutputUnitRTL.py

module OutputUnitRTL__a64cebb0607bd9de
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);

  assign send__msg = recv__msg;
  assign recv__rdy = send__rdy;
  assign send__val = recv__val;

endmodule


// PyMTL Component XbarRouteUnitRTL Definition
// Full name: XbarRouteUnitRTL__PacketType_ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f__num_outports_1
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/xbar/XbarRouteUnitRTL.py

module XbarRouteUnitRTL__d152fa1eb71b3044
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f send__msg [0:0] ,
  input logic [0:0] send__rdy [0:0] ,
  output logic [0:0] send__val [0:0] 
);
  localparam logic [0:0] __const__num_outports_at_up_ru_routing  = 1'd1;
  logic [0:0] out_dir;
  logic [0:0] send_val;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/xbar/XbarRouteUnitRTL.py:51
  // @update
  // def up_ru_recv_rdy():
  //   s.recv.rdy @= s.send[ s.out_dir ].rdy > 0
  
  always_comb begin : up_ru_recv_rdy
    recv__rdy = send__rdy[out_dir] > 1'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/xbar/XbarRouteUnitRTL.py:41
  // @update
  // def up_ru_routing():
  //   s.out_dir @= trunc( s.recv.msg.dst, dir_nbits )
  // 
  //   for i in range( num_outports ):
  //     s.send[i].val @= b1(0)
  // 
  //   if s.recv.val:
  //     s.send[ s.out_dir ].val @= b1(1)
  
  always_comb begin : up_ru_routing
    out_dir = recv__msg.dst;
    for ( int unsigned i = 1'd0; i < 1'( __const__num_outports_at_up_ru_routing ); i += 1'd1 )
      send__val[1'(i)] = 1'd0;
    if ( recv__val ) begin
      send__val[out_dir] = 1'd1;
    end
  end

  assign send__msg[0] = recv__msg;
  assign send_val[0:0] = send__val[0];

endmodule


// PyMTL Component RegEnRst Definition
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/registers.py

module RegEnRst__Type_Bits5__reset_value_1
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [4:0] in_ ,
  output logic [4:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd1;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 5'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RoundRobinArbiterEn Definition
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py

module RoundRobinArbiterEn__nreqs_5
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  output logic [4:0] grants ,
  input  logic [4:0] reqs ,
  input  logic [0:0] reset 
);
  localparam logic [2:0] __const__nreqs_at_comb_reqs_int  = 3'd5;
  localparam logic [3:0] __const__nreqsX2_at_comb_reqs_int  = 4'd10;
  localparam logic [2:0] __const__nreqs_at_comb_grants  = 3'd5;
  localparam logic [2:0] __const__nreqs_at_comb_priority_int  = 3'd5;
  localparam logic [3:0] __const__nreqsX2_at_comb_priority_int  = 4'd10;
  localparam logic [3:0] __const__nreqsX2_at_comb_kills  = 4'd10;
  localparam logic [3:0] __const__nreqsX2_at_comb_grants_int  = 4'd10;
  logic [9:0] grants_int;
  logic [10:0] kills;
  logic [0:0] priority_en;
  logic [9:0] priority_int;
  logic [9:0] reqs_int;
  //-------------------------------------------------------------
  // Component priority_reg
  //-------------------------------------------------------------

  logic [0:0] priority_reg__clk;
  logic [0:0] priority_reg__en;
  logic [4:0] priority_reg__in_;
  logic [4:0] priority_reg__out;
  logic [0:0] priority_reg__reset;

  RegEnRst__Type_Bits5__reset_value_1 priority_reg
  (
    .clk( priority_reg__clk ),
    .en( priority_reg__en ),
    .in_( priority_reg__in_ ),
    .out( priority_reg__out ),
    .reset( priority_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component priority_reg
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:118
  // @update
  // def comb_grants():
  //   for i in range( nreqs ):
  //     s.grants[i] @= s.grants_int[i] | s.grants_int[nreqs+i]
  
  always_comb begin : comb_grants
    for ( int unsigned i = 1'd0; i < 3'( __const__nreqs_at_comb_grants ); i += 1'd1 )
      grants[3'(i)] = grants_int[4'(i)] | grants_int[4'( __const__nreqs_at_comb_grants ) + 4'(i)];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:141
  // @update
  // def comb_grants_int():
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.grants_int[i] @= s.reqs_int[i]
  //     else:
  //       s.grants_int[i] @= ~s.kills[i] & s.reqs_int[i]
  
  always_comb begin : comb_grants_int
    for ( int unsigned i = 1'd0; i < 4'( __const__nreqsX2_at_comb_grants_int ); i += 1'd1 )
      if ( priority_int[4'(i)] ) begin
        grants_int[4'(i)] = reqs_int[4'(i)];
      end
      else
        grants_int[4'(i)] = ( ~kills[4'(i)] ) & reqs_int[4'(i)];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:132
  // @update
  // def comb_kills():
  //   s.kills[0] @= 1
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.kills[i+1] @= s.reqs_int[i]
  //     else:
  //       s.kills[i+1] @= s.kills[i] | ( ~s.kills[i] & s.reqs_int[i] )
  
  always_comb begin : comb_kills
    kills[4'd0] = 1'd1;
    for ( int unsigned i = 1'd0; i < 4'( __const__nreqsX2_at_comb_kills ); i += 1'd1 )
      if ( priority_int[4'(i)] ) begin
        kills[4'(i) + 4'd1] = reqs_int[4'(i)];
      end
      else
        kills[4'(i) + 4'd1] = kills[4'(i)] | ( ( ~kills[4'(i)] ) & reqs_int[4'(i)] );
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:123
  // @update
  // def comb_priority_en():
  //   s.priority_en @= ( s.grants != 0 ) & s.en
  
  always_comb begin : comb_priority_en
    priority_en = ( grants != 5'd0 ) & en;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:127
  // @update
  // def comb_priority_int():
  //   s.priority_int[    0:nreqs  ] @= s.priority_reg.out
  //   s.priority_int[nreqs:nreqsX2] @= 0
  
  always_comb begin : comb_priority_int
    priority_int[4'd4:4'd0] = priority_reg__out;
    priority_int[4'd9:4'( __const__nreqs_at_comb_priority_int )] = 5'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:113
  // @update
  // def comb_reqs_int():
  //   s.reqs_int [    0:nreqs  ] @= s.reqs
  //   s.reqs_int [nreqs:nreqsX2] @= s.reqs
  
  always_comb begin : comb_reqs_int
    reqs_int[4'd4:4'd0] = reqs;
    reqs_int[4'd9:4'( __const__nreqs_at_comb_reqs_int )] = reqs;
  end

  assign priority_reg__clk = clk;
  assign priority_reg__reset = reset;
  assign priority_reg__en = priority_en;
  assign priority_reg__in_[4:1] = grants[3:0];
  assign priority_reg__in_[0:0] = grants[4:4];

endmodule


// PyMTL Component Encoder Definition
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/encoders.py

module Encoder__in_nbits_5__out_nbits_3
(
  input  logic [0:0] clk ,
  input  logic [4:0] in_ ,
  output logic [2:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/encoders.py:28
  // @update
  // def encode():
  //   s.out @= 0
  //   for i in range( s.in_nbits ):
  //     if s.in_[i]:
  //       s.out @= i
  
  always_comb begin : encode
    out = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'd5; i += 1'd1 )
      if ( in_[3'(i)] ) begin
        out = 3'(i);
      end
  end

endmodule


// PyMTL Component Mux Definition
// Full name: Mux__Type_ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f__ninputs_5
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py

module Mux__e53a1e3a89c21f3d
(
  input  logic [0:0] clk ,
  input  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f in_ [0:4],
  output ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f out ,
  input  logic [0:0] reset ,
  input  logic [2:0] sel 
);

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component SwitchUnitRTL Definition
// Full name: SwitchUnitRTL__PacketType_ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f__num_inports_5
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py

module SwitchUnitRTL__1442088dab23c291
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f recv__msg [0:4] ,
  output logic [0:0] recv__rdy [0:4] ,
  input logic [0:0] recv__val [0:4] ,
  output ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  localparam logic [2:0] __const__num_inports_at_up_get_en  = 3'd5;
  //-------------------------------------------------------------
  // Component arbiter
  //-------------------------------------------------------------

  logic [0:0] arbiter__clk;
  logic [0:0] arbiter__en;
  logic [4:0] arbiter__grants;
  logic [4:0] arbiter__reqs;
  logic [0:0] arbiter__reset;

  RoundRobinArbiterEn__nreqs_5 arbiter
  (
    .clk( arbiter__clk ),
    .en( arbiter__en ),
    .grants( arbiter__grants ),
    .reqs( arbiter__reqs ),
    .reset( arbiter__reset )
  );

  //-------------------------------------------------------------
  // End of component arbiter
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component encoder
  //-------------------------------------------------------------

  logic [0:0] encoder__clk;
  logic [4:0] encoder__in_;
  logic [2:0] encoder__out;
  logic [0:0] encoder__reset;

  Encoder__in_nbits_5__out_nbits_3 encoder
  (
    .clk( encoder__clk ),
    .in_( encoder__in_ ),
    .out( encoder__out ),
    .reset( encoder__reset )
  );

  //-------------------------------------------------------------
  // End of component encoder
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mux
  //-------------------------------------------------------------

  logic [0:0] mux__clk;
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f mux__in_ [0:4];
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f mux__out;
  logic [0:0] mux__reset;
  logic [2:0] mux__sel;

  Mux__e53a1e3a89c21f3d mux
  (
    .clk( mux__clk ),
    .in_( mux__in_ ),
    .out( mux__out ),
    .reset( mux__reset ),
    .sel( mux__sel )
  );

  //-------------------------------------------------------------
  // End of component mux
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py:56
  // @update
  // def up_get_en():
  //   for i in range( num_inports ):
  //     s.recv[i].rdy @= s.send.rdy & ( s.mux.sel == i )
  
  always_comb begin : up_get_en
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_up_get_en ); i += 1'd1 )
      recv__rdy[3'(i)] = send__rdy & ( mux__sel == 3'(i) );
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py:51
  // @update
  // def up_send_val():
  //   s.send.val @= s.arbiter.grants > 0
  
  always_comb begin : up_send_val
    send__val = arbiter__grants > 5'd0;
  end

  assign arbiter__clk = clk;
  assign arbiter__reset = reset;
  assign arbiter__en = 1'd1;
  assign mux__clk = clk;
  assign mux__reset = reset;
  assign send__msg = mux__out;
  assign encoder__clk = clk;
  assign encoder__reset = reset;
  assign encoder__in_ = arbiter__grants;
  assign mux__sel = encoder__out;
  assign arbiter__reqs[0:0] = recv__val[0];
  assign mux__in_[0] = recv__msg[0];
  assign arbiter__reqs[1:1] = recv__val[1];
  assign mux__in_[1] = recv__msg[1];
  assign arbiter__reqs[2:2] = recv__val[2];
  assign mux__in_[2] = recv__msg[2];
  assign arbiter__reqs[3:3] = recv__val[3];
  assign mux__in_[3] = recv__msg[3];
  assign arbiter__reqs[4:4] = recv__val[4];
  assign mux__in_[4] = recv__msg[4];

endmodule


// PyMTL Component XbarBypassQueueRTL Definition
// Full name: XbarBypassQueueRTL__PacketType_ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f__num_inports_5__num_outports_1__InputUnitType_InputUnitRTL__RouteUnitType_XbarRouteUnitRTL__SwitchUnitType_SwitchUnitRTL__OutputUnitType_OutputUnitRTL
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/xbar/XbarBypassQueueRTL.py

module XbarBypassQueueRTL__0960f4ecb35675d1
(
  input  logic [0:0] clk ,
  output ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f packet_on_input_units [0:4],
  input  logic [0:0] reset ,
  input ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f recv__msg [0:4] ,
  output logic [0:0] recv__rdy [0:4] ,
  input logic [0:0] recv__val [0:4] ,
  output ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f send__msg [0:0] ,
  input logic [0:0] send__rdy [0:0] ,
  output logic [0:0] send__val [0:0] 
);
  //-------------------------------------------------------------
  // Component input_units[0:4]
  //-------------------------------------------------------------

  logic [0:0] input_units__clk [0:4];
  logic [0:0] input_units__reset [0:4];
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f input_units__recv__msg [0:4];
  logic [0:0] input_units__recv__rdy [0:4];
  logic [0:0] input_units__recv__val [0:4];
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f input_units__send__msg [0:4];
  logic [0:0] input_units__send__rdy [0:4];
  logic [0:0] input_units__send__val [0:4];

  InputUnitRTL__2bc5d380f554ae63 input_units__0
  (
    .clk( input_units__clk[0] ),
    .reset( input_units__reset[0] ),
    .recv__msg( input_units__recv__msg[0] ),
    .recv__rdy( input_units__recv__rdy[0] ),
    .recv__val( input_units__recv__val[0] ),
    .send__msg( input_units__send__msg[0] ),
    .send__rdy( input_units__send__rdy[0] ),
    .send__val( input_units__send__val[0] )
  );

  InputUnitRTL__2bc5d380f554ae63 input_units__1
  (
    .clk( input_units__clk[1] ),
    .reset( input_units__reset[1] ),
    .recv__msg( input_units__recv__msg[1] ),
    .recv__rdy( input_units__recv__rdy[1] ),
    .recv__val( input_units__recv__val[1] ),
    .send__msg( input_units__send__msg[1] ),
    .send__rdy( input_units__send__rdy[1] ),
    .send__val( input_units__send__val[1] )
  );

  InputUnitRTL__2bc5d380f554ae63 input_units__2
  (
    .clk( input_units__clk[2] ),
    .reset( input_units__reset[2] ),
    .recv__msg( input_units__recv__msg[2] ),
    .recv__rdy( input_units__recv__rdy[2] ),
    .recv__val( input_units__recv__val[2] ),
    .send__msg( input_units__send__msg[2] ),
    .send__rdy( input_units__send__rdy[2] ),
    .send__val( input_units__send__val[2] )
  );

  InputUnitRTL__2bc5d380f554ae63 input_units__3
  (
    .clk( input_units__clk[3] ),
    .reset( input_units__reset[3] ),
    .recv__msg( input_units__recv__msg[3] ),
    .recv__rdy( input_units__recv__rdy[3] ),
    .recv__val( input_units__recv__val[3] ),
    .send__msg( input_units__send__msg[3] ),
    .send__rdy( input_units__send__rdy[3] ),
    .send__val( input_units__send__val[3] )
  );

  InputUnitRTL__2bc5d380f554ae63 input_units__4
  (
    .clk( input_units__clk[4] ),
    .reset( input_units__reset[4] ),
    .recv__msg( input_units__recv__msg[4] ),
    .recv__rdy( input_units__recv__rdy[4] ),
    .recv__val( input_units__recv__val[4] ),
    .send__msg( input_units__send__msg[4] ),
    .send__rdy( input_units__send__rdy[4] ),
    .send__val( input_units__send__val[4] )
  );

  //-------------------------------------------------------------
  // End of component input_units[0:4]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component output_units[0:0]
  //-------------------------------------------------------------

  logic [0:0] output_units__clk [0:0];
  logic [0:0] output_units__reset [0:0];
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f output_units__recv__msg [0:0];
  logic [0:0] output_units__recv__rdy [0:0];
  logic [0:0] output_units__recv__val [0:0];
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f output_units__send__msg [0:0];
  logic [0:0] output_units__send__rdy [0:0];
  logic [0:0] output_units__send__val [0:0];

  OutputUnitRTL__a64cebb0607bd9de output_units__0
  (
    .clk( output_units__clk[0] ),
    .reset( output_units__reset[0] ),
    .recv__msg( output_units__recv__msg[0] ),
    .recv__rdy( output_units__recv__rdy[0] ),
    .recv__val( output_units__recv__val[0] ),
    .send__msg( output_units__send__msg[0] ),
    .send__rdy( output_units__send__rdy[0] ),
    .send__val( output_units__send__val[0] )
  );

  //-------------------------------------------------------------
  // End of component output_units[0:0]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component route_units[0:4]
  //-------------------------------------------------------------

  logic [0:0] route_units__clk [0:4];
  logic [0:0] route_units__reset [0:4];
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f route_units__recv__msg [0:4];
  logic [0:0] route_units__recv__rdy [0:4];
  logic [0:0] route_units__recv__val [0:4];
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f route_units__send__msg [0:4][0:0];
  logic [0:0] route_units__send__rdy [0:4][0:0];
  logic [0:0] route_units__send__val [0:4][0:0];

  XbarRouteUnitRTL__d152fa1eb71b3044 route_units__0
  (
    .clk( route_units__clk[0] ),
    .reset( route_units__reset[0] ),
    .recv__msg( route_units__recv__msg[0] ),
    .recv__rdy( route_units__recv__rdy[0] ),
    .recv__val( route_units__recv__val[0] ),
    .send__msg( route_units__send__msg[0] ),
    .send__rdy( route_units__send__rdy[0] ),
    .send__val( route_units__send__val[0] )
  );

  XbarRouteUnitRTL__d152fa1eb71b3044 route_units__1
  (
    .clk( route_units__clk[1] ),
    .reset( route_units__reset[1] ),
    .recv__msg( route_units__recv__msg[1] ),
    .recv__rdy( route_units__recv__rdy[1] ),
    .recv__val( route_units__recv__val[1] ),
    .send__msg( route_units__send__msg[1] ),
    .send__rdy( route_units__send__rdy[1] ),
    .send__val( route_units__send__val[1] )
  );

  XbarRouteUnitRTL__d152fa1eb71b3044 route_units__2
  (
    .clk( route_units__clk[2] ),
    .reset( route_units__reset[2] ),
    .recv__msg( route_units__recv__msg[2] ),
    .recv__rdy( route_units__recv__rdy[2] ),
    .recv__val( route_units__recv__val[2] ),
    .send__msg( route_units__send__msg[2] ),
    .send__rdy( route_units__send__rdy[2] ),
    .send__val( route_units__send__val[2] )
  );

  XbarRouteUnitRTL__d152fa1eb71b3044 route_units__3
  (
    .clk( route_units__clk[3] ),
    .reset( route_units__reset[3] ),
    .recv__msg( route_units__recv__msg[3] ),
    .recv__rdy( route_units__recv__rdy[3] ),
    .recv__val( route_units__recv__val[3] ),
    .send__msg( route_units__send__msg[3] ),
    .send__rdy( route_units__send__rdy[3] ),
    .send__val( route_units__send__val[3] )
  );

  XbarRouteUnitRTL__d152fa1eb71b3044 route_units__4
  (
    .clk( route_units__clk[4] ),
    .reset( route_units__reset[4] ),
    .recv__msg( route_units__recv__msg[4] ),
    .recv__rdy( route_units__recv__rdy[4] ),
    .recv__val( route_units__recv__val[4] ),
    .send__msg( route_units__send__msg[4] ),
    .send__rdy( route_units__send__rdy[4] ),
    .send__val( route_units__send__val[4] )
  );

  //-------------------------------------------------------------
  // End of component route_units[0:4]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component switch_units[0:0]
  //-------------------------------------------------------------

  logic [0:0] switch_units__clk [0:0];
  logic [0:0] switch_units__reset [0:0];
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f switch_units__recv__msg [0:0][0:4];
  logic [0:0] switch_units__recv__rdy [0:0][0:4];
  logic [0:0] switch_units__recv__val [0:0][0:4];
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f switch_units__send__msg [0:0];
  logic [0:0] switch_units__send__rdy [0:0];
  logic [0:0] switch_units__send__val [0:0];

  SwitchUnitRTL__1442088dab23c291 switch_units__0
  (
    .clk( switch_units__clk[0] ),
    .reset( switch_units__reset[0] ),
    .recv__msg( switch_units__recv__msg[0] ),
    .recv__rdy( switch_units__recv__rdy[0] ),
    .recv__val( switch_units__recv__val[0] ),
    .send__msg( switch_units__send__msg[0] ),
    .send__rdy( switch_units__send__rdy[0] ),
    .send__val( switch_units__send__val[0] )
  );

  //-------------------------------------------------------------
  // End of component switch_units[0:0]
  //-------------------------------------------------------------

  assign input_units__clk[0] = clk;
  assign input_units__reset[0] = reset;
  assign input_units__clk[1] = clk;
  assign input_units__reset[1] = reset;
  assign input_units__clk[2] = clk;
  assign input_units__reset[2] = reset;
  assign input_units__clk[3] = clk;
  assign input_units__reset[3] = reset;
  assign input_units__clk[4] = clk;
  assign input_units__reset[4] = reset;
  assign route_units__clk[0] = clk;
  assign route_units__reset[0] = reset;
  assign route_units__clk[1] = clk;
  assign route_units__reset[1] = reset;
  assign route_units__clk[2] = clk;
  assign route_units__reset[2] = reset;
  assign route_units__clk[3] = clk;
  assign route_units__reset[3] = reset;
  assign route_units__clk[4] = clk;
  assign route_units__reset[4] = reset;
  assign switch_units__clk[0] = clk;
  assign switch_units__reset[0] = reset;
  assign output_units__clk[0] = clk;
  assign output_units__reset[0] = reset;
  assign packet_on_input_units[0] = input_units__send__msg[0];
  assign packet_on_input_units[1] = input_units__send__msg[1];
  assign packet_on_input_units[2] = input_units__send__msg[2];
  assign packet_on_input_units[3] = input_units__send__msg[3];
  assign packet_on_input_units[4] = input_units__send__msg[4];
  assign input_units__recv__msg[0] = recv__msg[0];
  assign recv__rdy[0] = input_units__recv__rdy[0];
  assign input_units__recv__val[0] = recv__val[0];
  assign route_units__recv__msg[0] = input_units__send__msg[0];
  assign input_units__send__rdy[0] = route_units__recv__rdy[0];
  assign route_units__recv__val[0] = input_units__send__val[0];
  assign input_units__recv__msg[1] = recv__msg[1];
  assign recv__rdy[1] = input_units__recv__rdy[1];
  assign input_units__recv__val[1] = recv__val[1];
  assign route_units__recv__msg[1] = input_units__send__msg[1];
  assign input_units__send__rdy[1] = route_units__recv__rdy[1];
  assign route_units__recv__val[1] = input_units__send__val[1];
  assign input_units__recv__msg[2] = recv__msg[2];
  assign recv__rdy[2] = input_units__recv__rdy[2];
  assign input_units__recv__val[2] = recv__val[2];
  assign route_units__recv__msg[2] = input_units__send__msg[2];
  assign input_units__send__rdy[2] = route_units__recv__rdy[2];
  assign route_units__recv__val[2] = input_units__send__val[2];
  assign input_units__recv__msg[3] = recv__msg[3];
  assign recv__rdy[3] = input_units__recv__rdy[3];
  assign input_units__recv__val[3] = recv__val[3];
  assign route_units__recv__msg[3] = input_units__send__msg[3];
  assign input_units__send__rdy[3] = route_units__recv__rdy[3];
  assign route_units__recv__val[3] = input_units__send__val[3];
  assign input_units__recv__msg[4] = recv__msg[4];
  assign recv__rdy[4] = input_units__recv__rdy[4];
  assign input_units__recv__val[4] = recv__val[4];
  assign route_units__recv__msg[4] = input_units__send__msg[4];
  assign input_units__send__rdy[4] = route_units__recv__rdy[4];
  assign route_units__recv__val[4] = input_units__send__val[4];
  assign switch_units__recv__msg[0][0] = route_units__send__msg[0][0];
  assign route_units__send__rdy[0][0] = switch_units__recv__rdy[0][0];
  assign switch_units__recv__val[0][0] = route_units__send__val[0][0];
  assign switch_units__recv__msg[0][1] = route_units__send__msg[1][0];
  assign route_units__send__rdy[1][0] = switch_units__recv__rdy[0][1];
  assign switch_units__recv__val[0][1] = route_units__send__val[1][0];
  assign switch_units__recv__msg[0][2] = route_units__send__msg[2][0];
  assign route_units__send__rdy[2][0] = switch_units__recv__rdy[0][2];
  assign switch_units__recv__val[0][2] = route_units__send__val[2][0];
  assign switch_units__recv__msg[0][3] = route_units__send__msg[3][0];
  assign route_units__send__rdy[3][0] = switch_units__recv__rdy[0][3];
  assign switch_units__recv__val[0][3] = route_units__send__val[3][0];
  assign switch_units__recv__msg[0][4] = route_units__send__msg[4][0];
  assign route_units__send__rdy[4][0] = switch_units__recv__rdy[0][4];
  assign switch_units__recv__val[0][4] = route_units__send__val[4][0];
  assign output_units__recv__msg[0] = switch_units__send__msg[0];
  assign switch_units__send__rdy[0] = output_units__recv__rdy[0];
  assign output_units__recv__val[0] = switch_units__send__val[0];
  assign send__msg[0] = output_units__send__msg[0];
  assign output_units__send__rdy[0] = send__rdy[0];
  assign send__val[0] = output_units__send__val[0];

endmodule


// PyMTL Component NormalQueueCtrlRTL Definition
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueCtrlRTL__num_entries_2
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  output logic [0:0] raddr ,
  output logic [0:0] recv_rdy ,
  input  logic [0:0] recv_val ,
  input  logic [0:0] reset ,
  input  logic [0:0] send_rdy ,
  output logic [0:0] send_val ,
  output logic [0:0] waddr ,
  output logic [0:0] wen 
);
  localparam logic [1:0] __const__num_entries_at__lambda__s_dut_cgra_0__controller_recv_from_cpu_pkt_queue_ctrl_recv_rdy  = 2'd2;
  localparam logic [1:0] __const__num_entries_at_up_reg  = 2'd2;
  logic [0:0] head;
  logic [0:0] recv_xfer;
  logic [0:0] send_xfer;
  logic [0:0] tail;

  // PyMTL Lambda Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py:121
  // s.recv_rdy  //= lambda: s.count < num_entries
  
  always_comb begin : _lambda__s_dut_cgra_0__controller_recv_from_cpu_pkt_queue_ctrl_recv_rdy
    recv_rdy = count < 2'( __const__num_entries_at__lambda__s_dut_cgra_0__controller_recv_from_cpu_pkt_queue_ctrl_recv_rdy );
  end

  // PyMTL Lambda Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py:124
  // s.recv_xfer //= lambda: s.recv_val & s.recv_rdy
  
  always_comb begin : _lambda__s_dut_cgra_0__controller_recv_from_cpu_pkt_queue_ctrl_recv_xfer
    recv_xfer = recv_val & recv_rdy;
  end

  // PyMTL Lambda Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py:122
  // s.send_val  //= lambda: s.count > 0
  
  always_comb begin : _lambda__s_dut_cgra_0__controller_recv_from_cpu_pkt_queue_ctrl_send_val
    send_val = count > 2'd0;
  end

  // PyMTL Lambda Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py:125
  // s.send_xfer //= lambda: s.send_val & s.send_rdy
  
  always_comb begin : _lambda__s_dut_cgra_0__controller_recv_from_cpu_pkt_queue_ctrl_send_xfer
    send_xfer = send_val & send_rdy;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py:127
  // @update_ff
  // def up_reg():
  // 
  //   if s.reset:
  //     s.head  <<= 0
  //     s.tail  <<= 0
  //     s.count <<= 0
  // 
  //   else:
  //     if s.recv_xfer:
  //       s.tail <<= s.tail + 1 if ( s.tail < num_entries - 1 ) else 0
  // 
  //     if s.send_xfer:
  //       s.head <<= s.head + 1 if ( s.head < num_entries -1 ) else 0
  // 
  //     if s.recv_xfer & ~s.send_xfer:
  //       s.count <<= s.count + 1
  //     elif ~s.recv_xfer & s.send_xfer:
  //       s.count <<= s.count - 1
  
  always_ff @(posedge clk) begin : up_reg
    if ( reset ) begin
      head <= 1'd0;
      tail <= 1'd0;
      count <= 2'd0;
    end
    else begin
      if ( recv_xfer ) begin
        tail <= ( tail < ( 1'( __const__num_entries_at_up_reg ) - 1'd1 ) ) ? tail + 1'd1 : 1'd0;
      end
      if ( send_xfer ) begin
        head <= ( head < ( 1'( __const__num_entries_at_up_reg ) - 1'd1 ) ) ? head + 1'd1 : 1'd0;
      end
      if ( recv_xfer & ( ~send_xfer ) ) begin
        count <= count + 2'd1;
      end
      else if ( ( ~recv_xfer ) & send_xfer ) begin
        count <= count - 2'd1;
      end
    end
  end

  assign wen = recv_xfer;
  assign waddr = tail;
  assign raddr = head;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py

module RegisterFile__56492c26522fbfc8
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 regs [0:1];

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueueDpathRTL Definition
// Full name: NormalQueueDpathRTL__EntryType_IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74__num_entries_2
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueDpathRTL__9578d8c7b27375fb
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr ,
  input  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv_msg ,
  input  logic [0:0] reset ,
  output IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send_msg ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component rf
  //-------------------------------------------------------------

  logic [0:0] rf__clk;
  logic [0:0] rf__raddr [0:0];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 rf__rdata [0:0];
  logic [0:0] rf__reset;
  logic [0:0] rf__waddr [0:0];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 rf__wdata [0:0];
  logic [0:0] rf__wen [0:0];

  RegisterFile__56492c26522fbfc8 rf
  (
    .clk( rf__clk ),
    .raddr( rf__raddr ),
    .rdata( rf__rdata ),
    .reset( rf__reset ),
    .waddr( rf__waddr ),
    .wdata( rf__wdata ),
    .wen( rf__wen )
  );

  //-------------------------------------------------------------
  // End of component rf
  //-------------------------------------------------------------

  assign rf__clk = clk;
  assign rf__reset = reset;
  assign rf__raddr[0] = raddr;
  assign send_msg = rf__rdata[0];
  assign rf__wen[0] = wen;
  assign rf__waddr[0] = waddr;
  assign rf__wdata[0] = recv_msg;

endmodule


// PyMTL Component NormalQueueRTL Definition
// Full name: NormalQueueRTL__EntryType_IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74__num_entries_2
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueRTL__9578d8c7b27375fb
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__recv_rdy;
  logic [0:0] ctrl__recv_val;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__send_rdy;
  logic [0:0] ctrl__send_val;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .raddr( ctrl__raddr ),
    .recv_rdy( ctrl__recv_rdy ),
    .recv_val( ctrl__recv_val ),
    .reset( ctrl__reset ),
    .send_rdy( ctrl__send_rdy ),
    .send_val( ctrl__send_val ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  logic [0:0] dpath__raddr;
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 dpath__recv_msg;
  logic [0:0] dpath__reset;
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 dpath__send_msg;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueueDpathRTL__9578d8c7b27375fb dpath
  (
    .clk( dpath__clk ),
    .raddr( dpath__raddr ),
    .recv_msg( dpath__recv_msg ),
    .reset( dpath__reset ),
    .send_msg( dpath__send_msg ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__recv_val = recv__val;
  assign recv__rdy = ctrl__recv_rdy;
  assign dpath__recv_msg = recv__msg;
  assign send__val = ctrl__send_val;
  assign ctrl__send_rdy = send__rdy;
  assign send__msg = dpath__send_msg;
  assign count = ctrl__count;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py

module RegisterFile__c17010fa10a5fd77
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d regs [0:1];

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueueDpathRTL Definition
// Full name: NormalQueueDpathRTL__EntryType_InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d__num_entries_2
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueDpathRTL__434823ce8c67ae61
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr ,
  input  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv_msg ,
  input  logic [0:0] reset ,
  output InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send_msg ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component rf
  //-------------------------------------------------------------

  logic [0:0] rf__clk;
  logic [0:0] rf__raddr [0:0];
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d rf__rdata [0:0];
  logic [0:0] rf__reset;
  logic [0:0] rf__waddr [0:0];
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d rf__wdata [0:0];
  logic [0:0] rf__wen [0:0];

  RegisterFile__c17010fa10a5fd77 rf
  (
    .clk( rf__clk ),
    .raddr( rf__raddr ),
    .rdata( rf__rdata ),
    .reset( rf__reset ),
    .waddr( rf__waddr ),
    .wdata( rf__wdata ),
    .wen( rf__wen )
  );

  //-------------------------------------------------------------
  // End of component rf
  //-------------------------------------------------------------

  assign rf__clk = clk;
  assign rf__reset = reset;
  assign rf__raddr[0] = raddr;
  assign send_msg = rf__rdata[0];
  assign rf__wen[0] = wen;
  assign rf__waddr[0] = waddr;
  assign rf__wdata[0] = recv_msg;

endmodule


// PyMTL Component NormalQueueRTL Definition
// Full name: NormalQueueRTL__EntryType_InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d__num_entries_2
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueRTL__434823ce8c67ae61
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__recv_rdy;
  logic [0:0] ctrl__recv_val;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__send_rdy;
  logic [0:0] ctrl__send_val;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .raddr( ctrl__raddr ),
    .recv_rdy( ctrl__recv_rdy ),
    .recv_val( ctrl__recv_val ),
    .reset( ctrl__reset ),
    .send_rdy( ctrl__send_rdy ),
    .send_val( ctrl__send_val ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  logic [0:0] dpath__raddr;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d dpath__recv_msg;
  logic [0:0] dpath__reset;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d dpath__send_msg;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueueDpathRTL__434823ce8c67ae61 dpath
  (
    .clk( dpath__clk ),
    .raddr( dpath__raddr ),
    .recv_msg( dpath__recv_msg ),
    .reset( dpath__reset ),
    .send_msg( dpath__send_msg ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__recv_val = recv__val;
  assign recv__rdy = ctrl__recv_rdy;
  assign dpath__recv_msg = recv__msg;
  assign send__val = ctrl__send_val;
  assign ctrl__send_rdy = send__rdy;
  assign send__msg = dpath__send_msg;
  assign count = ctrl__count;

endmodule


// PyMTL Component ChannelRTL Definition
// Full name: ChannelRTL__PacketType_InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d__QueueType_NormalQueueRTL__latency_1
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/channel/ChannelRTL.py

module ChannelRTL__fce4be61a0158680
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component queues[0:0]
  //-------------------------------------------------------------

  logic [0:0] queues__clk [0:0];
  logic [1:0] queues__count [0:0];
  logic [0:0] queues__reset [0:0];
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d queues__recv__msg [0:0];
  logic [0:0] queues__recv__rdy [0:0];
  logic [0:0] queues__recv__val [0:0];
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d queues__send__msg [0:0];
  logic [0:0] queues__send__rdy [0:0];
  logic [0:0] queues__send__val [0:0];

  NormalQueueRTL__434823ce8c67ae61 queues__0
  (
    .clk( queues__clk[0] ),
    .count( queues__count[0] ),
    .reset( queues__reset[0] ),
    .recv__msg( queues__recv__msg[0] ),
    .recv__rdy( queues__recv__rdy[0] ),
    .recv__val( queues__recv__val[0] ),
    .send__msg( queues__send__msg[0] ),
    .send__rdy( queues__send__rdy[0] ),
    .send__val( queues__send__val[0] )
  );

  //-------------------------------------------------------------
  // End of component queues[0:0]
  //-------------------------------------------------------------

  assign queues__clk[0] = clk;
  assign queues__reset[0] = reset;
  assign queues__recv__msg[0] = recv__msg;
  assign recv__rdy = queues__recv__rdy[0];
  assign queues__recv__val[0] = recv__val;
  assign send__msg = queues__send__msg[0];
  assign queues__send__rdy[0] = send__rdy;
  assign send__val = queues__send__val[0];

endmodule


// PyMTL Component ControllerRTL Definition
// Full name: ControllerRTL__CgraIdType_Bits4__IntraCgraPktType_IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74__InterCgraPktType_InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__DataAddrType_Bits9__multi_cgra_rows_3__multi_cgra_columns_3__num_tiles_4__controller2addr_map_{0: [0, 31], 1: [32, 63], 2: [64, 95], 3: [96, 127], 4: [128, 159], 5: [160, 191], 6: [192, 223], 7: [224, 255], 8: [256, 287]}__idTo2d_map_{0: (0, 0), 1: (1, 0), 2: (2, 0), 3: (0, 1), 4: (1, 1), 5: (2, 1), 6: (0, 2), 7: (1, 2), 8: (2, 2)}
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/controller/ControllerRTL.py

module ControllerRTL__78e9e7a7dc10be49
(
  input  logic [3:0] cgra_id ,
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv_from_cpu_pkt__msg  ,
  output logic [0:0] recv_from_cpu_pkt__rdy  ,
  input logic [0:0] recv_from_cpu_pkt__val  ,
  input IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv_from_ctrl_ring_pkt__msg  ,
  output logic [0:0] recv_from_ctrl_ring_pkt__rdy  ,
  input logic [0:0] recv_from_ctrl_ring_pkt__val  ,
  input InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv_from_inter_cgra_noc__msg  ,
  output logic [0:0] recv_from_inter_cgra_noc__rdy  ,
  input logic [0:0] recv_from_inter_cgra_noc__val  ,
  input InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv_from_tile_load_request_pkt__msg  ,
  output logic [0:0] recv_from_tile_load_request_pkt__rdy  ,
  input logic [0:0] recv_from_tile_load_request_pkt__val  ,
  input InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv_from_tile_load_response_pkt__msg  ,
  output logic [0:0] recv_from_tile_load_response_pkt__rdy  ,
  input logic [0:0] recv_from_tile_load_response_pkt__val  ,
  input InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv_from_tile_store_request_pkt__msg  ,
  output logic [0:0] recv_from_tile_store_request_pkt__rdy  ,
  input logic [0:0] recv_from_tile_store_request_pkt__val  ,
  output IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send_to_cpu_pkt__msg  ,
  input logic [0:0] send_to_cpu_pkt__rdy  ,
  output logic [0:0] send_to_cpu_pkt__val  ,
  output IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send_to_ctrl_ring_pkt__msg  ,
  input logic [0:0] send_to_ctrl_ring_pkt__rdy  ,
  output logic [0:0] send_to_ctrl_ring_pkt__val  ,
  output InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send_to_inter_cgra_noc__msg  ,
  input logic [0:0] send_to_inter_cgra_noc__rdy  ,
  output logic [0:0] send_to_inter_cgra_noc__val  ,
  output InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send_to_mem_load_request__msg  ,
  input logic [0:0] send_to_mem_load_request__rdy  ,
  output logic [0:0] send_to_mem_load_request__val  ,
  output InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send_to_mem_store_request__msg  ,
  input logic [0:0] send_to_mem_store_request__rdy  ,
  output logic [0:0] send_to_mem_store_request__val  ,
  output InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send_to_tile_load_response__msg  ,
  input logic [0:0] send_to_tile_load_response__rdy  ,
  output logic [0:0] send_to_tile_load_response__val  
);
  localparam logic [2:0] __const__num_tiles_at_update_received_msg  = 3'd4;
  localparam logic [3:0] __const__CMD_LOAD_REQUEST  = 4'd9;
  localparam logic [3:0] __const__CMD_STORE_REQUEST  = 4'd11;
  localparam logic [3:0] __const__CMD_LOAD_RESPONSE  = 4'd10;
  localparam logic [3:0] __const__CMD_COMPLETE  = 4'd13;
  localparam logic [1:0] __const__CMD_CONFIG  = 2'd3;
  localparam logic [2:0] __const__CMD_CONFIG_PROLOGUE_FU  = 3'd4;
  localparam logic [2:0] __const__CMD_CONFIG_PROLOGUE_FU_CROSSBAR  = 3'd5;
  localparam logic [2:0] __const__CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR  = 3'd6;
  localparam logic [2:0] __const__CMD_CONFIG_TOTAL_CTRL_COUNT  = 3'd7;
  localparam logic [3:0] __const__CMD_CONFIG_COUNT_PER_ITER  = 4'd8;
  localparam logic [3:0] __const__CMD_CONST  = 4'd12;
  localparam logic [0:0] __const__CMD_LAUNCH  = 1'd0;
  localparam logic [2:0] __const__addr_offset_nbits_at_update_sending_to_noc_msg  = 3'd5;
  logic [3:0] addr2controller_lut [0:8];
  logic [1:0] idTo2d_x_lut [0:8];
  logic [1:0] idTo2d_y_lut [0:8];
  //-------------------------------------------------------------
  // Component crossbar
  //-------------------------------------------------------------

  logic [0:0] crossbar__clk;
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f crossbar__packet_on_input_units [0:4];
  logic [0:0] crossbar__reset;
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f crossbar__recv__msg [0:4];
  logic [0:0] crossbar__recv__rdy [0:4];
  logic [0:0] crossbar__recv__val [0:4];
  ControllerNocXbarPacket_InterCgraPktType__859724d70e9b023f crossbar__send__msg [0:0];
  logic [0:0] crossbar__send__rdy [0:0];
  logic [0:0] crossbar__send__val [0:0];

  XbarBypassQueueRTL__0960f4ecb35675d1 crossbar
  (
    .clk( crossbar__clk ),
    .packet_on_input_units( crossbar__packet_on_input_units ),
    .reset( crossbar__reset ),
    .recv__msg( crossbar__recv__msg ),
    .recv__rdy( crossbar__recv__rdy ),
    .recv__val( crossbar__recv__val ),
    .send__msg( crossbar__send__msg ),
    .send__rdy( crossbar__send__rdy ),
    .send__val( crossbar__send__val )
  );

  //-------------------------------------------------------------
  // End of component crossbar
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component recv_from_cpu_pkt_queue
  //-------------------------------------------------------------

  logic [0:0] recv_from_cpu_pkt_queue__clk;
  logic [1:0] recv_from_cpu_pkt_queue__count;
  logic [0:0] recv_from_cpu_pkt_queue__reset;
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv_from_cpu_pkt_queue__recv__msg;
  logic [0:0] recv_from_cpu_pkt_queue__recv__rdy;
  logic [0:0] recv_from_cpu_pkt_queue__recv__val;
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv_from_cpu_pkt_queue__send__msg;
  logic [0:0] recv_from_cpu_pkt_queue__send__rdy;
  logic [0:0] recv_from_cpu_pkt_queue__send__val;

  NormalQueueRTL__9578d8c7b27375fb recv_from_cpu_pkt_queue
  (
    .clk( recv_from_cpu_pkt_queue__clk ),
    .count( recv_from_cpu_pkt_queue__count ),
    .reset( recv_from_cpu_pkt_queue__reset ),
    .recv__msg( recv_from_cpu_pkt_queue__recv__msg ),
    .recv__rdy( recv_from_cpu_pkt_queue__recv__rdy ),
    .recv__val( recv_from_cpu_pkt_queue__recv__val ),
    .send__msg( recv_from_cpu_pkt_queue__send__msg ),
    .send__rdy( recv_from_cpu_pkt_queue__send__rdy ),
    .send__val( recv_from_cpu_pkt_queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component recv_from_cpu_pkt_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component recv_from_tile_load_request_pkt_queue
  //-------------------------------------------------------------

  logic [0:0] recv_from_tile_load_request_pkt_queue__clk;
  logic [0:0] recv_from_tile_load_request_pkt_queue__reset;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv_from_tile_load_request_pkt_queue__recv__msg;
  logic [0:0] recv_from_tile_load_request_pkt_queue__recv__rdy;
  logic [0:0] recv_from_tile_load_request_pkt_queue__recv__val;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv_from_tile_load_request_pkt_queue__send__msg;
  logic [0:0] recv_from_tile_load_request_pkt_queue__send__rdy;
  logic [0:0] recv_from_tile_load_request_pkt_queue__send__val;

  ChannelRTL__fce4be61a0158680 recv_from_tile_load_request_pkt_queue
  (
    .clk( recv_from_tile_load_request_pkt_queue__clk ),
    .reset( recv_from_tile_load_request_pkt_queue__reset ),
    .recv__msg( recv_from_tile_load_request_pkt_queue__recv__msg ),
    .recv__rdy( recv_from_tile_load_request_pkt_queue__recv__rdy ),
    .recv__val( recv_from_tile_load_request_pkt_queue__recv__val ),
    .send__msg( recv_from_tile_load_request_pkt_queue__send__msg ),
    .send__rdy( recv_from_tile_load_request_pkt_queue__send__rdy ),
    .send__val( recv_from_tile_load_request_pkt_queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component recv_from_tile_load_request_pkt_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component recv_from_tile_load_response_pkt_queue
  //-------------------------------------------------------------

  logic [0:0] recv_from_tile_load_response_pkt_queue__clk;
  logic [0:0] recv_from_tile_load_response_pkt_queue__reset;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv_from_tile_load_response_pkt_queue__recv__msg;
  logic [0:0] recv_from_tile_load_response_pkt_queue__recv__rdy;
  logic [0:0] recv_from_tile_load_response_pkt_queue__recv__val;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv_from_tile_load_response_pkt_queue__send__msg;
  logic [0:0] recv_from_tile_load_response_pkt_queue__send__rdy;
  logic [0:0] recv_from_tile_load_response_pkt_queue__send__val;

  ChannelRTL__fce4be61a0158680 recv_from_tile_load_response_pkt_queue
  (
    .clk( recv_from_tile_load_response_pkt_queue__clk ),
    .reset( recv_from_tile_load_response_pkt_queue__reset ),
    .recv__msg( recv_from_tile_load_response_pkt_queue__recv__msg ),
    .recv__rdy( recv_from_tile_load_response_pkt_queue__recv__rdy ),
    .recv__val( recv_from_tile_load_response_pkt_queue__recv__val ),
    .send__msg( recv_from_tile_load_response_pkt_queue__send__msg ),
    .send__rdy( recv_from_tile_load_response_pkt_queue__send__rdy ),
    .send__val( recv_from_tile_load_response_pkt_queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component recv_from_tile_load_response_pkt_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component recv_from_tile_store_request_pkt_queue
  //-------------------------------------------------------------

  logic [0:0] recv_from_tile_store_request_pkt_queue__clk;
  logic [0:0] recv_from_tile_store_request_pkt_queue__reset;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv_from_tile_store_request_pkt_queue__recv__msg;
  logic [0:0] recv_from_tile_store_request_pkt_queue__recv__rdy;
  logic [0:0] recv_from_tile_store_request_pkt_queue__recv__val;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv_from_tile_store_request_pkt_queue__send__msg;
  logic [0:0] recv_from_tile_store_request_pkt_queue__send__rdy;
  logic [0:0] recv_from_tile_store_request_pkt_queue__send__val;

  ChannelRTL__fce4be61a0158680 recv_from_tile_store_request_pkt_queue
  (
    .clk( recv_from_tile_store_request_pkt_queue__clk ),
    .reset( recv_from_tile_store_request_pkt_queue__reset ),
    .recv__msg( recv_from_tile_store_request_pkt_queue__recv__msg ),
    .recv__rdy( recv_from_tile_store_request_pkt_queue__recv__rdy ),
    .recv__val( recv_from_tile_store_request_pkt_queue__recv__val ),
    .send__msg( recv_from_tile_store_request_pkt_queue__send__msg ),
    .send__rdy( recv_from_tile_store_request_pkt_queue__send__rdy ),
    .send__val( recv_from_tile_store_request_pkt_queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component recv_from_tile_store_request_pkt_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component send_to_cpu_pkt_queue
  //-------------------------------------------------------------

  logic [0:0] send_to_cpu_pkt_queue__clk;
  logic [1:0] send_to_cpu_pkt_queue__count;
  logic [0:0] send_to_cpu_pkt_queue__reset;
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send_to_cpu_pkt_queue__recv__msg;
  logic [0:0] send_to_cpu_pkt_queue__recv__rdy;
  logic [0:0] send_to_cpu_pkt_queue__recv__val;
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send_to_cpu_pkt_queue__send__msg;
  logic [0:0] send_to_cpu_pkt_queue__send__rdy;
  logic [0:0] send_to_cpu_pkt_queue__send__val;

  NormalQueueRTL__9578d8c7b27375fb send_to_cpu_pkt_queue
  (
    .clk( send_to_cpu_pkt_queue__clk ),
    .count( send_to_cpu_pkt_queue__count ),
    .reset( send_to_cpu_pkt_queue__reset ),
    .recv__msg( send_to_cpu_pkt_queue__recv__msg ),
    .recv__rdy( send_to_cpu_pkt_queue__recv__rdy ),
    .recv__val( send_to_cpu_pkt_queue__recv__val ),
    .send__msg( send_to_cpu_pkt_queue__send__msg ),
    .send__rdy( send_to_cpu_pkt_queue__send__rdy ),
    .send__val( send_to_cpu_pkt_queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component send_to_cpu_pkt_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component send_to_mem_load_request_queue
  //-------------------------------------------------------------

  logic [0:0] send_to_mem_load_request_queue__clk;
  logic [0:0] send_to_mem_load_request_queue__reset;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send_to_mem_load_request_queue__recv__msg;
  logic [0:0] send_to_mem_load_request_queue__recv__rdy;
  logic [0:0] send_to_mem_load_request_queue__recv__val;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send_to_mem_load_request_queue__send__msg;
  logic [0:0] send_to_mem_load_request_queue__send__rdy;
  logic [0:0] send_to_mem_load_request_queue__send__val;

  ChannelRTL__fce4be61a0158680 send_to_mem_load_request_queue
  (
    .clk( send_to_mem_load_request_queue__clk ),
    .reset( send_to_mem_load_request_queue__reset ),
    .recv__msg( send_to_mem_load_request_queue__recv__msg ),
    .recv__rdy( send_to_mem_load_request_queue__recv__rdy ),
    .recv__val( send_to_mem_load_request_queue__recv__val ),
    .send__msg( send_to_mem_load_request_queue__send__msg ),
    .send__rdy( send_to_mem_load_request_queue__send__rdy ),
    .send__val( send_to_mem_load_request_queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component send_to_mem_load_request_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component send_to_mem_store_request_queue
  //-------------------------------------------------------------

  logic [0:0] send_to_mem_store_request_queue__clk;
  logic [0:0] send_to_mem_store_request_queue__reset;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send_to_mem_store_request_queue__recv__msg;
  logic [0:0] send_to_mem_store_request_queue__recv__rdy;
  logic [0:0] send_to_mem_store_request_queue__recv__val;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send_to_mem_store_request_queue__send__msg;
  logic [0:0] send_to_mem_store_request_queue__send__rdy;
  logic [0:0] send_to_mem_store_request_queue__send__val;

  ChannelRTL__fce4be61a0158680 send_to_mem_store_request_queue
  (
    .clk( send_to_mem_store_request_queue__clk ),
    .reset( send_to_mem_store_request_queue__reset ),
    .recv__msg( send_to_mem_store_request_queue__recv__msg ),
    .recv__rdy( send_to_mem_store_request_queue__recv__rdy ),
    .recv__val( send_to_mem_store_request_queue__recv__val ),
    .send__msg( send_to_mem_store_request_queue__send__msg ),
    .send__rdy( send_to_mem_store_request_queue__send__rdy ),
    .send__val( send_to_mem_store_request_queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component send_to_mem_store_request_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component send_to_tile_load_response_queue
  //-------------------------------------------------------------

  logic [0:0] send_to_tile_load_response_queue__clk;
  logic [0:0] send_to_tile_load_response_queue__reset;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send_to_tile_load_response_queue__recv__msg;
  logic [0:0] send_to_tile_load_response_queue__recv__rdy;
  logic [0:0] send_to_tile_load_response_queue__recv__val;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send_to_tile_load_response_queue__send__msg;
  logic [0:0] send_to_tile_load_response_queue__send__rdy;
  logic [0:0] send_to_tile_load_response_queue__send__val;

  ChannelRTL__fce4be61a0158680 send_to_tile_load_response_queue
  (
    .clk( send_to_tile_load_response_queue__clk ),
    .reset( send_to_tile_load_response_queue__reset ),
    .recv__msg( send_to_tile_load_response_queue__recv__msg ),
    .recv__rdy( send_to_tile_load_response_queue__recv__rdy ),
    .recv__val( send_to_tile_load_response_queue__recv__val ),
    .send__msg( send_to_tile_load_response_queue__send__msg ),
    .send__rdy( send_to_tile_load_response_queue__send__rdy ),
    .send__val( send_to_tile_load_response_queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component send_to_tile_load_response_queue
  //-------------------------------------------------------------
  logic [0:0] __tmpvar__update_received_msg_kLoadRequestInportIdx;
  logic [0:0] __tmpvar__update_received_msg_kLoadResponseInportIdx;
  logic [1:0] __tmpvar__update_received_msg_kStoreRequestInportIdx;
  logic [1:0] __tmpvar__update_received_msg_kFromCpuCtrlAndDataIdx;
  logic [2:0] __tmpvar__update_received_msg_kFromInterTileRingIdx;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d __tmpvar__update_received_msg_received_pkt;
  logic [3:0] __tmpvar__update_sending_to_noc_msg_addr_dst_id;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/controller/ControllerRTL.py:122
  // @update
  // def update_received_msg():
  //   kLoadRequestInportIdx = 0
  //   kLoadResponseInportIdx = 1
  //   kStoreRequestInportIdx = 2
  //   kFromCpuCtrlAndDataIdx = 3
  //   kFromInterTileRingIdx = 4
  // 
  //   s.send_to_cpu_pkt_queue.recv.val @= 0
  //   s.send_to_cpu_pkt_queue.recv.msg @= IntraCgraPktType(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  //   s.recv_from_ctrl_ring_pkt.rdy @= 0
  // 
  //   # For the command signal from inter-tile/intra-cgra control ring.
  //   s.crossbar.recv[kFromInterTileRingIdx].val @= s.recv_from_ctrl_ring_pkt.val
  //   s.recv_from_ctrl_ring_pkt.rdy @= s.crossbar.recv[kFromInterTileRingIdx].rdy
  //   s.crossbar.recv[kFromInterTileRingIdx].msg @= \
  //       ControllerXbarPktType(0, # dst (always 0 to align with the single outport of the crossbar, i.e., NoC)
  //                             InterCgraPktType(s.cgra_id,
  //                                              s.recv_from_ctrl_ring_pkt.msg.dst_cgra_id,
  //                                              s.idTo2d_x_lut[s.cgra_id], # src_x
  //                                              s.idTo2d_y_lut[s.cgra_id], # src_y
  //                                              s.recv_from_ctrl_ring_pkt.msg.dst_cgra_x, # dst_x
  //                                              s.recv_from_ctrl_ring_pkt.msg.dst_cgra_y, # dst_y
  //                                              s.recv_from_ctrl_ring_pkt.msg.src, # src_tile_id
  //                                              s.recv_from_ctrl_ring_pkt.msg.dst, # dst_tile_id
  //                                              0, # opaque
  //                                              0, # vc_id. No need to specify vc_id for self produce-consume pkt thanks to the additional VC buffer.
  //                                              s.recv_from_ctrl_ring_pkt.msg.payload))
  // 
  //   # For the load request from local tiles.
  //   s.crossbar.recv[kLoadRequestInportIdx].val @= s.recv_from_tile_load_request_pkt_queue.send.val
  //   s.recv_from_tile_load_request_pkt_queue.send.rdy @= s.crossbar.recv[kLoadRequestInportIdx].rdy
  //   s.crossbar.recv[kLoadRequestInportIdx].msg @= \
  //       ControllerXbarPktType(0, # dst (always 0 to align with the single outport of the crossbar, i.e., NoC)
  //                             s.recv_from_tile_load_request_pkt_queue.send.msg)
  // 
  //   # For the store request from local tiles.
  //   s.crossbar.recv[kStoreRequestInportIdx].val @= s.recv_from_tile_store_request_pkt_queue.send.val
  //   s.recv_from_tile_store_request_pkt_queue.send.rdy @= s.crossbar.recv[kStoreRequestInportIdx].rdy
  //   s.crossbar.recv[kStoreRequestInportIdx].msg @= \
  //       ControllerXbarPktType(0, # dst (always 0 to align with the single outport of the crossbar, i.e., NoC)
  //                             s.recv_from_tile_store_request_pkt_queue.send.msg)
  // 
  //   # For the load response (i.e., the data towards other) from local memory.
  //   s.crossbar.recv[kLoadResponseInportIdx].val @= \
  //       s.recv_from_tile_load_response_pkt_queue.send.val
  //   s.recv_from_tile_load_response_pkt_queue.send.rdy @= s.crossbar.recv[kLoadResponseInportIdx].rdy
  //   s.crossbar.recv[kLoadResponseInportIdx].msg @= \
  //       ControllerXbarPktType(0, # dst (always 0 to align with the single outport of the crossbar, i.e., NoC)
  //                             s.recv_from_tile_load_response_pkt_queue.send.msg)
  // 
  //   # For the ctrl and data preloading.
  //   s.crossbar.recv[kFromCpuCtrlAndDataIdx].val @= \
  //       s.recv_from_cpu_pkt_queue.send.val
  //   s.recv_from_cpu_pkt_queue.send.rdy @= s.crossbar.recv[kFromCpuCtrlAndDataIdx].rdy
  //   s.crossbar.recv[kFromCpuCtrlAndDataIdx].msg @= \
  //       ControllerXbarPktType(0, # dst (always 0 to align with the single outport of the crossbar, i.e., NoC)
  //                             InterCgraPktType(s.cgra_id, # src
  //                                              s.recv_from_cpu_pkt_queue.send.msg.dst_cgra_id, # dst
  //                                              0, # src_x
  //                                              0, # src_y
  //                                              s.idTo2d_x_lut[s.recv_from_cpu_pkt_queue.send.msg.dst_cgra_id], # dst_x
  //                                              s.idTo2d_y_lut[s.recv_from_cpu_pkt_queue.send.msg.dst_cgra_id], # dst_y
  //                                              num_tiles, # src_tile_id, num_tiles is used to indicate the request is from CPU, so the LOAD response can come back.
  //                                              s.recv_from_cpu_pkt_queue.send.msg.dst, # dst_tile_id
  //                                              0, # opaque
  //                                              0, # vc_id
  //                                              s.recv_from_cpu_pkt_queue.send.msg.payload))
  // 
  //   # TODO: For the other cmd types.
  // 
  // 
  // # @update
  // # def update_received_msg_from_noc():
  // 
  //   # Initiates the signals.
  //   s.send_to_mem_load_request_queue.recv.val @= 0
  //   s.send_to_mem_store_request_queue.recv.val @= 0
  //   s.send_to_tile_load_response_queue.recv.val @= 0
  // 
  //   s.send_to_mem_load_request_queue.recv.msg @= InterCgraPktType(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  //   s.send_to_mem_store_request_queue.recv.msg @= InterCgraPktType(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  //   s.send_to_tile_load_response_queue.recv.msg @= InterCgraPktType(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  // 
  //   s.recv_from_inter_cgra_noc.rdy @= 0
  //   s.send_to_ctrl_ring_pkt.val @= 0
  //   s.send_to_ctrl_ring_pkt.msg @= IntraCgraPktType(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  // 
  //   # For the load request from NoC.
  //   received_pkt = s.recv_from_inter_cgra_noc.msg
  //   if s.recv_from_inter_cgra_noc.val:
  //     if s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_LOAD_REQUEST:
  //       s.send_to_mem_load_request_queue.recv.val @= 1
  // 
  //       if s.send_to_mem_load_request_queue.recv.rdy:
  //         s.recv_from_inter_cgra_noc.rdy @= 1
  //         s.send_to_mem_load_request_queue.recv.msg @= received_pkt
  // 
  //     elif s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_STORE_REQUEST:
  //       s.send_to_mem_store_request_queue.recv.msg @= received_pkt
  //       s.send_to_mem_store_request_queue.recv.val @= 1
  // 
  //       if s.send_to_mem_store_request_queue.recv.rdy:
  //         s.recv_from_inter_cgra_noc.rdy @= 1
  // 
  //     elif s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_LOAD_RESPONSE:
  //       # FIXME: This condition needs to check whether this controller is the
  //       # one connecting to CPU, and with the help from additional field indicating
  //       # whether the packet is originally from CPU.
  //       # https://github.com/tancheng/VectorCGRA/issues/116.
  //       if s.recv_from_inter_cgra_noc.msg.dst_tile_id == num_tiles:
  //         s.recv_from_inter_cgra_noc.rdy @= s.send_to_cpu_pkt_queue.recv.rdy
  //         s.send_to_cpu_pkt_queue.recv.val @= 1
  //         s.send_to_cpu_pkt_queue.recv.msg @= \
  //             IntraCgraPktType(s.recv_from_inter_cgra_noc.msg.src_tile_id, # src
  //                              s.recv_from_inter_cgra_noc.msg.dst_tile_id, # dst
  //                              s.recv_from_inter_cgra_noc.msg.src, # src_cgra_id
  //                              s.recv_from_inter_cgra_noc.msg.dst, # src_cgra_id
  //                              s.recv_from_inter_cgra_noc.msg.src_x, # src_cgra_x
  //                              s.recv_from_inter_cgra_noc.msg.src_y, # src_cgra_y
  //                              s.recv_from_inter_cgra_noc.msg.dst_x, # dst_cgra_x
  //                              s.recv_from_inter_cgra_noc.msg.dst_y, # dst_cgra_y
  //                              0, # opaque
  //                              0, # vc_id
  //                              s.recv_from_inter_cgra_noc.msg.payload)
  // 
  //       else:
  //         s.recv_from_inter_cgra_noc.rdy @= s.send_to_tile_load_response_queue.recv.rdy
  //         s.send_to_tile_load_response_queue.recv.msg @= received_pkt
  //         s.send_to_tile_load_response_queue.recv.val @= 1
  // 
  //     elif s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_COMPLETE:
  //       s.recv_from_inter_cgra_noc.rdy @= s.send_to_cpu_pkt_queue.recv.rdy
  //       s.send_to_cpu_pkt_queue.recv.val @= 1
  //       s.send_to_cpu_pkt_queue.recv.msg @= \
  //           IntraCgraPktType(s.recv_from_inter_cgra_noc.msg.src_tile_id, # src
  //                            s.recv_from_inter_cgra_noc.msg.dst_tile_id, # dst
  //                            s.recv_from_inter_cgra_noc.msg.src, # src_cgra_id
  //                            s.recv_from_inter_cgra_noc.msg.dst, # src_cgra_id
  //                            s.recv_from_inter_cgra_noc.msg.src_x, # src_cgra_x
  //                            s.recv_from_inter_cgra_noc.msg.src_y, # src_cgra_y
  //                            s.recv_from_inter_cgra_noc.msg.dst_x, # dst_cgra_x
  //                            s.recv_from_inter_cgra_noc.msg.dst_y, # dst_cgra_y
  //                            0, # opaque
  //                            0, # vc_id
  //                            s.recv_from_inter_cgra_noc.msg.payload)
  // 
  //     elif (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_CONFIG) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_CONFIG_PROLOGUE_FU) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_CONFIG_PROLOGUE_FU_CROSSBAR) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_CONFIG_TOTAL_CTRL_COUNT) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_CONFIG_COUNT_PER_ITER) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_CONST) | \
  //          (s.recv_from_inter_cgra_noc.msg.payload.cmd == CMD_LAUNCH):
  //       s.recv_from_inter_cgra_noc.rdy @= s.send_to_ctrl_ring_pkt.rdy
  //       s.send_to_ctrl_ring_pkt.val @= s.recv_from_inter_cgra_noc.val
  //       s.send_to_ctrl_ring_pkt.msg @= \
  //           IntraCgraPktType(s.recv_from_inter_cgra_noc.msg.src_tile_id, # src
  //                            s.recv_from_inter_cgra_noc.msg.dst_tile_id, # dst
  //                            s.recv_from_inter_cgra_noc.msg.src, # src_cgra_id
  //                            s.recv_from_inter_cgra_noc.msg.dst, # src_cgra_id
  //                            s.recv_from_inter_cgra_noc.msg.src_x, # src_cgra_x
  //                            s.recv_from_inter_cgra_noc.msg.src_y, # src_cgra_y
  //                            s.recv_from_inter_cgra_noc.msg.dst_x, # dst_cgra_x
  //                            s.recv_from_inter_cgra_noc.msg.dst_y, # dst_cgra_y
  //                            0, # opaque
  //                            0, # vc_id
  //                            s.recv_from_inter_cgra_noc.msg.payload)
  // 
  //     # else:
  //     #   # TODO: Handle other cmd types.
  //     #   assert(False)
  
  always_comb begin : update_received_msg
    __tmpvar__update_received_msg_kLoadRequestInportIdx = 1'd0;
    __tmpvar__update_received_msg_kLoadResponseInportIdx = 1'd1;
    __tmpvar__update_received_msg_kStoreRequestInportIdx = 2'd2;
    __tmpvar__update_received_msg_kFromCpuCtrlAndDataIdx = 2'd3;
    __tmpvar__update_received_msg_kFromInterTileRingIdx = 3'd4;
    send_to_cpu_pkt_queue__recv__val = 1'd0;
    send_to_cpu_pkt_queue__recv__msg = { 3'd0, 3'd0, 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 8'd0, 1'd0, 163'd0 };
    recv_from_ctrl_ring_pkt__rdy = 1'd0;
    crossbar__recv__val[__tmpvar__update_received_msg_kFromInterTileRingIdx] = recv_from_ctrl_ring_pkt__val;
    recv_from_ctrl_ring_pkt__rdy = crossbar__recv__rdy[3'(__tmpvar__update_received_msg_kFromInterTileRingIdx)];
    crossbar__recv__msg[__tmpvar__update_received_msg_kFromInterTileRingIdx] = { 1'd0, { cgra_id, recv_from_ctrl_ring_pkt__msg.dst_cgra_id, idTo2d_x_lut[cgra_id], idTo2d_y_lut[cgra_id], recv_from_ctrl_ring_pkt__msg.dst_cgra_x, recv_from_ctrl_ring_pkt__msg.dst_cgra_y, recv_from_ctrl_ring_pkt__msg.src, recv_from_ctrl_ring_pkt__msg.dst, 8'd0, 2'd0, recv_from_ctrl_ring_pkt__msg.payload } };
    crossbar__recv__val[__tmpvar__update_received_msg_kLoadRequestInportIdx] = recv_from_tile_load_request_pkt_queue__send__val;
    recv_from_tile_load_request_pkt_queue__send__rdy = crossbar__recv__rdy[3'(__tmpvar__update_received_msg_kLoadRequestInportIdx)];
    crossbar__recv__msg[__tmpvar__update_received_msg_kLoadRequestInportIdx] = { 1'd0, recv_from_tile_load_request_pkt_queue__send__msg };
    crossbar__recv__val[__tmpvar__update_received_msg_kStoreRequestInportIdx] = recv_from_tile_store_request_pkt_queue__send__val;
    recv_from_tile_store_request_pkt_queue__send__rdy = crossbar__recv__rdy[3'(__tmpvar__update_received_msg_kStoreRequestInportIdx)];
    crossbar__recv__msg[__tmpvar__update_received_msg_kStoreRequestInportIdx] = { 1'd0, recv_from_tile_store_request_pkt_queue__send__msg };
    crossbar__recv__val[__tmpvar__update_received_msg_kLoadResponseInportIdx] = recv_from_tile_load_response_pkt_queue__send__val;
    recv_from_tile_load_response_pkt_queue__send__rdy = crossbar__recv__rdy[3'(__tmpvar__update_received_msg_kLoadResponseInportIdx)];
    crossbar__recv__msg[__tmpvar__update_received_msg_kLoadResponseInportIdx] = { 1'd0, recv_from_tile_load_response_pkt_queue__send__msg };
    crossbar__recv__val[__tmpvar__update_received_msg_kFromCpuCtrlAndDataIdx] = recv_from_cpu_pkt_queue__send__val;
    recv_from_cpu_pkt_queue__send__rdy = crossbar__recv__rdy[3'(__tmpvar__update_received_msg_kFromCpuCtrlAndDataIdx)];
    crossbar__recv__msg[__tmpvar__update_received_msg_kFromCpuCtrlAndDataIdx] = { 1'd0, { cgra_id, recv_from_cpu_pkt_queue__send__msg.dst_cgra_id, 2'd0, 2'd0, idTo2d_x_lut[recv_from_cpu_pkt_queue__send__msg.dst_cgra_id], idTo2d_y_lut[recv_from_cpu_pkt_queue__send__msg.dst_cgra_id], 3'( __const__num_tiles_at_update_received_msg ), recv_from_cpu_pkt_queue__send__msg.dst, 8'd0, 2'd0, recv_from_cpu_pkt_queue__send__msg.payload } };
    send_to_mem_load_request_queue__recv__val = 1'd0;
    send_to_mem_store_request_queue__recv__val = 1'd0;
    send_to_tile_load_response_queue__recv__val = 1'd0;
    send_to_mem_load_request_queue__recv__msg = { 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 3'd0, 3'd0, 8'd0, 2'd0, 163'd0 };
    send_to_mem_store_request_queue__recv__msg = { 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 3'd0, 3'd0, 8'd0, 2'd0, 163'd0 };
    send_to_tile_load_response_queue__recv__msg = { 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 3'd0, 3'd0, 8'd0, 2'd0, 163'd0 };
    recv_from_inter_cgra_noc__rdy = 1'd0;
    send_to_ctrl_ring_pkt__val = 1'd0;
    send_to_ctrl_ring_pkt__msg = { 3'd0, 3'd0, 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 8'd0, 1'd0, 163'd0 };
    __tmpvar__update_received_msg_received_pkt = recv_from_inter_cgra_noc__msg;
    if ( recv_from_inter_cgra_noc__val ) begin
      if ( recv_from_inter_cgra_noc__msg.payload.cmd == 4'( __const__CMD_LOAD_REQUEST ) ) begin
        send_to_mem_load_request_queue__recv__val = 1'd1;
        if ( send_to_mem_load_request_queue__recv__rdy ) begin
          recv_from_inter_cgra_noc__rdy = 1'd1;
          send_to_mem_load_request_queue__recv__msg = __tmpvar__update_received_msg_received_pkt;
        end
      end
      else if ( recv_from_inter_cgra_noc__msg.payload.cmd == 4'( __const__CMD_STORE_REQUEST ) ) begin
        send_to_mem_store_request_queue__recv__msg = __tmpvar__update_received_msg_received_pkt;
        send_to_mem_store_request_queue__recv__val = 1'd1;
        if ( send_to_mem_store_request_queue__recv__rdy ) begin
          recv_from_inter_cgra_noc__rdy = 1'd1;
        end
      end
      else if ( recv_from_inter_cgra_noc__msg.payload.cmd == 4'( __const__CMD_LOAD_RESPONSE ) ) begin
        if ( recv_from_inter_cgra_noc__msg.dst_tile_id == 3'( __const__num_tiles_at_update_received_msg ) ) begin
          recv_from_inter_cgra_noc__rdy = send_to_cpu_pkt_queue__recv__rdy;
          send_to_cpu_pkt_queue__recv__val = 1'd1;
          send_to_cpu_pkt_queue__recv__msg = { recv_from_inter_cgra_noc__msg.src_tile_id, recv_from_inter_cgra_noc__msg.dst_tile_id, recv_from_inter_cgra_noc__msg.src, recv_from_inter_cgra_noc__msg.dst, recv_from_inter_cgra_noc__msg.src_x, recv_from_inter_cgra_noc__msg.src_y, recv_from_inter_cgra_noc__msg.dst_x, recv_from_inter_cgra_noc__msg.dst_y, 8'd0, 1'd0, recv_from_inter_cgra_noc__msg.payload };
        end
        else begin
          recv_from_inter_cgra_noc__rdy = send_to_tile_load_response_queue__recv__rdy;
          send_to_tile_load_response_queue__recv__msg = __tmpvar__update_received_msg_received_pkt;
          send_to_tile_load_response_queue__recv__val = 1'd1;
        end
      end
      else if ( recv_from_inter_cgra_noc__msg.payload.cmd == 4'( __const__CMD_COMPLETE ) ) begin
        recv_from_inter_cgra_noc__rdy = send_to_cpu_pkt_queue__recv__rdy;
        send_to_cpu_pkt_queue__recv__val = 1'd1;
        send_to_cpu_pkt_queue__recv__msg = { recv_from_inter_cgra_noc__msg.src_tile_id, recv_from_inter_cgra_noc__msg.dst_tile_id, recv_from_inter_cgra_noc__msg.src, recv_from_inter_cgra_noc__msg.dst, recv_from_inter_cgra_noc__msg.src_x, recv_from_inter_cgra_noc__msg.src_y, recv_from_inter_cgra_noc__msg.dst_x, recv_from_inter_cgra_noc__msg.dst_y, 8'd0, 1'd0, recv_from_inter_cgra_noc__msg.payload };
      end
      else if ( ( ( ( ( ( ( ( recv_from_inter_cgra_noc__msg.payload.cmd == 4'( __const__CMD_CONFIG ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 4'( __const__CMD_CONFIG_PROLOGUE_FU ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 4'( __const__CMD_CONFIG_PROLOGUE_FU_CROSSBAR ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 4'( __const__CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 4'( __const__CMD_CONFIG_TOTAL_CTRL_COUNT ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 4'( __const__CMD_CONFIG_COUNT_PER_ITER ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 4'( __const__CMD_CONST ) ) ) | ( recv_from_inter_cgra_noc__msg.payload.cmd == 4'( __const__CMD_LAUNCH ) ) ) begin
        recv_from_inter_cgra_noc__rdy = send_to_ctrl_ring_pkt__rdy;
        send_to_ctrl_ring_pkt__val = recv_from_inter_cgra_noc__val;
        send_to_ctrl_ring_pkt__msg = { recv_from_inter_cgra_noc__msg.src_tile_id, recv_from_inter_cgra_noc__msg.dst_tile_id, recv_from_inter_cgra_noc__msg.src, recv_from_inter_cgra_noc__msg.dst, recv_from_inter_cgra_noc__msg.src_x, recv_from_inter_cgra_noc__msg.src_y, recv_from_inter_cgra_noc__msg.dst_x, recv_from_inter_cgra_noc__msg.dst_y, 8'd0, 1'd0, recv_from_inter_cgra_noc__msg.payload };
      end
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/controller/ControllerRTL.py:296
  // @update
  // def update_sending_to_noc_msg():
  //   s.send_to_inter_cgra_noc.val @= s.crossbar.send[0].val
  //   s.crossbar.send[0].rdy @= s.send_to_inter_cgra_noc.rdy
  //   s.send_to_inter_cgra_noc.msg @= s.crossbar.send[0].msg.inter_cgra_pkt
  //   if (s.crossbar.send[0].msg.inter_cgra_pkt.payload.cmd == CMD_LOAD_REQUEST) | \
  //      (s.crossbar.send[0].msg.inter_cgra_pkt.payload.cmd == CMD_STORE_REQUEST):
  //     addr_dst_id = s.addr2controller_lut[trunc(s.crossbar.send[0].msg.inter_cgra_pkt.payload.data_addr >> addr_offset_nbits, CgraIdType)]
  //     s.send_to_inter_cgra_noc.msg.dst @= addr_dst_id
  //     s.send_to_inter_cgra_noc.msg.dst_x @= s.idTo2d_x_lut[addr_dst_id]
  //     s.send_to_inter_cgra_noc.msg.dst_y @= s.idTo2d_y_lut[addr_dst_id]
  
  always_comb begin : update_sending_to_noc_msg
    send_to_inter_cgra_noc__val = crossbar__send__val[1'd0];
    crossbar__send__rdy[1'd0] = send_to_inter_cgra_noc__rdy;
    send_to_inter_cgra_noc__msg = crossbar__send__msg[1'd0].inter_cgra_pkt;
    if ( ( crossbar__send__msg[1'd0].inter_cgra_pkt.payload.cmd == 4'( __const__CMD_LOAD_REQUEST ) ) | ( crossbar__send__msg[1'd0].inter_cgra_pkt.payload.cmd == 4'( __const__CMD_STORE_REQUEST ) ) ) begin
      __tmpvar__update_sending_to_noc_msg_addr_dst_id = addr2controller_lut[4'(crossbar__send__msg[1'd0].inter_cgra_pkt.payload.data_addr >> 3'( __const__addr_offset_nbits_at_update_sending_to_noc_msg ))];
      send_to_inter_cgra_noc__msg.dst = __tmpvar__update_sending_to_noc_msg_addr_dst_id;
      send_to_inter_cgra_noc__msg.dst_x = idTo2d_x_lut[__tmpvar__update_sending_to_noc_msg_addr_dst_id];
      send_to_inter_cgra_noc__msg.dst_y = idTo2d_y_lut[__tmpvar__update_sending_to_noc_msg_addr_dst_id];
    end
  end

  assign recv_from_tile_load_request_pkt_queue__clk = clk;
  assign recv_from_tile_load_request_pkt_queue__reset = reset;
  assign recv_from_tile_load_response_pkt_queue__clk = clk;
  assign recv_from_tile_load_response_pkt_queue__reset = reset;
  assign recv_from_tile_store_request_pkt_queue__clk = clk;
  assign recv_from_tile_store_request_pkt_queue__reset = reset;
  assign send_to_mem_load_request_queue__clk = clk;
  assign send_to_mem_load_request_queue__reset = reset;
  assign send_to_tile_load_response_queue__clk = clk;
  assign send_to_tile_load_response_queue__reset = reset;
  assign send_to_mem_store_request_queue__clk = clk;
  assign send_to_mem_store_request_queue__reset = reset;
  assign crossbar__clk = clk;
  assign crossbar__reset = reset;
  assign recv_from_cpu_pkt_queue__clk = clk;
  assign recv_from_cpu_pkt_queue__reset = reset;
  assign send_to_cpu_pkt_queue__clk = clk;
  assign send_to_cpu_pkt_queue__reset = reset;
  assign addr2controller_lut[0] = 4'd0;
  assign addr2controller_lut[1] = 4'd1;
  assign addr2controller_lut[2] = 4'd2;
  assign addr2controller_lut[3] = 4'd3;
  assign addr2controller_lut[4] = 4'd4;
  assign addr2controller_lut[5] = 4'd5;
  assign addr2controller_lut[6] = 4'd6;
  assign addr2controller_lut[7] = 4'd7;
  assign addr2controller_lut[8] = 4'd8;
  assign idTo2d_x_lut[0] = 2'd0;
  assign idTo2d_y_lut[0] = 2'd0;
  assign idTo2d_x_lut[1] = 2'd1;
  assign idTo2d_y_lut[1] = 2'd0;
  assign idTo2d_x_lut[2] = 2'd2;
  assign idTo2d_y_lut[2] = 2'd0;
  assign idTo2d_x_lut[3] = 2'd0;
  assign idTo2d_y_lut[3] = 2'd1;
  assign idTo2d_x_lut[4] = 2'd1;
  assign idTo2d_y_lut[4] = 2'd1;
  assign idTo2d_x_lut[5] = 2'd2;
  assign idTo2d_y_lut[5] = 2'd1;
  assign idTo2d_x_lut[6] = 2'd0;
  assign idTo2d_y_lut[6] = 2'd2;
  assign idTo2d_x_lut[7] = 2'd1;
  assign idTo2d_y_lut[7] = 2'd2;
  assign idTo2d_x_lut[8] = 2'd2;
  assign idTo2d_y_lut[8] = 2'd2;
  assign recv_from_tile_load_request_pkt_queue__recv__msg = recv_from_tile_load_request_pkt__msg;
  assign recv_from_tile_load_request_pkt__rdy = recv_from_tile_load_request_pkt_queue__recv__rdy;
  assign recv_from_tile_load_request_pkt_queue__recv__val = recv_from_tile_load_request_pkt__val;
  assign recv_from_tile_load_response_pkt_queue__recv__msg = recv_from_tile_load_response_pkt__msg;
  assign recv_from_tile_load_response_pkt__rdy = recv_from_tile_load_response_pkt_queue__recv__rdy;
  assign recv_from_tile_load_response_pkt_queue__recv__val = recv_from_tile_load_response_pkt__val;
  assign recv_from_tile_store_request_pkt_queue__recv__msg = recv_from_tile_store_request_pkt__msg;
  assign recv_from_tile_store_request_pkt__rdy = recv_from_tile_store_request_pkt_queue__recv__rdy;
  assign recv_from_tile_store_request_pkt_queue__recv__val = recv_from_tile_store_request_pkt__val;
  assign send_to_mem_load_request__msg = send_to_mem_load_request_queue__send__msg;
  assign send_to_mem_load_request_queue__send__rdy = send_to_mem_load_request__rdy;
  assign send_to_mem_load_request__val = send_to_mem_load_request_queue__send__val;
  assign send_to_tile_load_response__msg = send_to_tile_load_response_queue__send__msg;
  assign send_to_tile_load_response_queue__send__rdy = send_to_tile_load_response__rdy;
  assign send_to_tile_load_response__val = send_to_tile_load_response_queue__send__val;
  assign send_to_mem_store_request__msg = send_to_mem_store_request_queue__send__msg;
  assign send_to_mem_store_request_queue__send__rdy = send_to_mem_store_request__rdy;
  assign send_to_mem_store_request__val = send_to_mem_store_request_queue__send__val;
  assign recv_from_cpu_pkt_queue__recv__msg = recv_from_cpu_pkt__msg;
  assign recv_from_cpu_pkt__rdy = recv_from_cpu_pkt_queue__recv__rdy;
  assign recv_from_cpu_pkt_queue__recv__val = recv_from_cpu_pkt__val;
  assign send_to_cpu_pkt__msg = send_to_cpu_pkt_queue__send__msg;
  assign send_to_cpu_pkt_queue__send__rdy = send_to_cpu_pkt__rdy;
  assign send_to_cpu_pkt__val = send_to_cpu_pkt_queue__send__val;

endmodule


// PyMTL Component Counter Definition
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/ocnlib/rtl/Counter.py

module Counter__Type_Bits2__reset_value_2
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] decr ,
  input  logic [0:0] incr ,
  input  logic [0:0] load ,
  input  logic [1:0] load_value ,
  input  logic [0:0] reset 
);
  localparam logic [1:0] __const__reset_value_at_up_count  = 2'd2;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/ocnlib/rtl/Counter.py:28
  // @update_ff
  // def up_count():
  // 
  //   if s.reset:
  //     s.count <<= reset_value
  // 
  //   elif s.load:
  //     s.count <<= s.load_value
  // 
  //   elif s.incr & ~s.decr:
  //     s.count <<= s.count + 1
  // 
  //   elif ~s.incr & s.decr:
  //     s.count <<= s.count - 1
  
  always_ff @(posedge clk) begin : up_count
    if ( reset ) begin
      count <= 2'( __const__reset_value_at_up_count );
    end
    else if ( load ) begin
      count <= load_value;
    end
    else if ( incr & ( ~decr ) ) begin
      count <= count + 2'd1;
    end
    else if ( ( ~incr ) & decr ) begin
      count <= count - 2'd1;
    end
  end

endmodule


// PyMTL Component RecvRTL2CreditSendRTL Definition
// Full name: RecvRTL2CreditSendRTL__MsgType_IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74__vc_2__credit_line_2
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/ocnlib/ifcs/CreditIfc.py

module RecvRTL2CreditSendRTL__32ad184d10468f6d
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output logic [0:0] send__en  ,
  output IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send__msg  ,
  input logic [0:0] send__yum [0:1] 
);
  localparam logic [1:0] __const__vc_at_up_credit_send  = 2'd2;
  localparam logic [1:0] __const__vc_at_up_counter_decr  = 2'd2;
  //-------------------------------------------------------------
  // Component credit[0:1]
  //-------------------------------------------------------------

  logic [0:0] credit__clk [0:1];
  logic [1:0] credit__count [0:1];
  logic [0:0] credit__decr [0:1];
  logic [0:0] credit__incr [0:1];
  logic [0:0] credit__load [0:1];
  logic [1:0] credit__load_value [0:1];
  logic [0:0] credit__reset [0:1];

  Counter__Type_Bits2__reset_value_2 credit__0
  (
    .clk( credit__clk[0] ),
    .count( credit__count[0] ),
    .decr( credit__decr[0] ),
    .incr( credit__incr[0] ),
    .load( credit__load[0] ),
    .load_value( credit__load_value[0] ),
    .reset( credit__reset[0] )
  );

  Counter__Type_Bits2__reset_value_2 credit__1
  (
    .clk( credit__clk[1] ),
    .count( credit__count[1] ),
    .decr( credit__decr[1] ),
    .incr( credit__incr[1] ),
    .load( credit__load[1] ),
    .load_value( credit__load_value[1] ),
    .reset( credit__reset[1] )
  );

  //-------------------------------------------------------------
  // End of component credit[0:1]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/ocnlib/ifcs/CreditIfc.py:149
  // @update
  // def up_counter_decr():
  //   for i in range( vc ):
  //     s.credit[i].decr @= s.send.en & ( i == s.send.msg.vc_id )
  
  always_comb begin : up_counter_decr
    for ( int unsigned i = 1'd0; i < 2'( __const__vc_at_up_counter_decr ); i += 1'd1 )
      credit__decr[1'(i)] = send__en & ( 1'(i) == send__msg.vc_id );
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/ocnlib/ifcs/CreditIfc.py:137
  // @update
  // def up_credit_send():
  //   s.send.en  @= 0
  //   s.recv.rdy @= 0
  //   # NOTE: recv.rdy depends on recv.val.
  //   #       Be careful about combinationl loop.
  //   if s.recv.val:
  //     for i in range( vc ):
  //       if ( i == s.recv.msg.vc_id ) & ( s.credit[i].count > 0 ):
  //         s.send.en  @= 1
  //         s.recv.rdy @= 1
  
  always_comb begin : up_credit_send
    send__en = 1'd0;
    recv__rdy = 1'd0;
    if ( recv__val ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__vc_at_up_credit_send ); i += 1'd1 )
        if ( ( 1'(i) == recv__msg.vc_id ) & ( credit__count[1'(i)] > 2'd0 ) ) begin
          send__en = 1'd1;
          recv__rdy = 1'd1;
        end
    end
  end

  assign credit__clk[0] = clk;
  assign credit__reset[0] = reset;
  assign credit__clk[1] = clk;
  assign credit__reset[1] = reset;
  assign send__msg = recv__msg;
  assign credit__incr[0] = send__yum[0];
  assign credit__load[0] = 1'd0;
  assign credit__load_value[0] = 2'd0;
  assign credit__incr[1] = send__yum[1];
  assign credit__load[1] = 1'd0;
  assign credit__load_value[1] = 2'd0;

endmodule


// PyMTL Component InputUnitCreditRTL Definition
// Full name: InputUnitCreditRTL__PacketType_IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74__QueueType_NormalQueueRTL__vc_2__credit_line_2
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/InputUnitCreditRTL.py

module InputUnitCreditRTL__3310d4c884d771ee
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en  ,
  input IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv__msg  ,
  output logic [0:0] recv__yum [0:1] ,
  output IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send__msg [0:1] ,
  input logic [0:0] send__rdy [0:1] ,
  output logic [0:0] send__val [0:1] 
);
  localparam logic [0:0] __const__i_at__lambda__s_dut_cgra_0__ctrl_ring_routers_0__input_units_0__recv_yum_0_  = 1'd0;
  localparam logic [0:0] __const__i_at__lambda__s_dut_cgra_0__ctrl_ring_routers_0__input_units_0__recv_yum_1_  = 1'd1;
  localparam logic [1:0] __const__vc_at_up_enq  = 2'd2;
  //-------------------------------------------------------------
  // Component buffers[0:1]
  //-------------------------------------------------------------

  logic [0:0] buffers__clk [0:1];
  logic [1:0] buffers__count [0:1];
  logic [0:0] buffers__reset [0:1];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 buffers__recv__msg [0:1];
  logic [0:0] buffers__recv__rdy [0:1];
  logic [0:0] buffers__recv__val [0:1];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 buffers__send__msg [0:1];
  logic [0:0] buffers__send__rdy [0:1];
  logic [0:0] buffers__send__val [0:1];

  NormalQueueRTL__9578d8c7b27375fb buffers__0
  (
    .clk( buffers__clk[0] ),
    .count( buffers__count[0] ),
    .reset( buffers__reset[0] ),
    .recv__msg( buffers__recv__msg[0] ),
    .recv__rdy( buffers__recv__rdy[0] ),
    .recv__val( buffers__recv__val[0] ),
    .send__msg( buffers__send__msg[0] ),
    .send__rdy( buffers__send__rdy[0] ),
    .send__val( buffers__send__val[0] )
  );

  NormalQueueRTL__9578d8c7b27375fb buffers__1
  (
    .clk( buffers__clk[1] ),
    .count( buffers__count[1] ),
    .reset( buffers__reset[1] ),
    .recv__msg( buffers__recv__msg[1] ),
    .recv__rdy( buffers__recv__rdy[1] ),
    .recv__val( buffers__recv__val[1] ),
    .send__msg( buffers__send__msg[1] ),
    .send__rdy( buffers__send__rdy[1] ),
    .send__val( buffers__send__val[1] )
  );

  //-------------------------------------------------------------
  // End of component buffers[0:1]
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/InputUnitCreditRTL.py:39
  // s.recv.yum[i]         //= lambda: s.send[i].val & s.send[i].rdy
  
  always_comb begin : _lambda__s_dut_cgra_0__ctrl_ring_routers_0__input_units_0__recv_yum_0_
    recv__yum[1'd0] = send__val[1'( __const__i_at__lambda__s_dut_cgra_0__ctrl_ring_routers_0__input_units_0__recv_yum_0_ )] & send__rdy[1'( __const__i_at__lambda__s_dut_cgra_0__ctrl_ring_routers_0__input_units_0__recv_yum_0_ )];
  end

  // PyMTL Lambda Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/InputUnitCreditRTL.py:39
  // s.recv.yum[i]         //= lambda: s.send[i].val & s.send[i].rdy
  
  always_comb begin : _lambda__s_dut_cgra_0__ctrl_ring_routers_0__input_units_0__recv_yum_1_
    recv__yum[1'd1] = send__val[1'( __const__i_at__lambda__s_dut_cgra_0__ctrl_ring_routers_0__input_units_0__recv_yum_1_ )] & send__rdy[1'( __const__i_at__lambda__s_dut_cgra_0__ctrl_ring_routers_0__input_units_0__recv_yum_1_ )];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/InputUnitCreditRTL.py:41
  // @update
  // def up_enq():
  //   if s.recv.en:
  //     for i in range( vc ):
  //       s.buffers[i].recv.val @= ( s.recv.msg.vc_id == i )
  //   else:
  //     for i in range( vc ):
  //       s.buffers[i].recv.val @= 0
  
  always_comb begin : up_enq
    if ( recv__en ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__vc_at_up_enq ); i += 1'd1 )
        buffers__recv__val[1'(i)] = recv__msg.vc_id == 1'(i);
    end
    else
      for ( int unsigned i = 1'd0; i < 2'( __const__vc_at_up_enq ); i += 1'd1 )
        buffers__recv__val[1'(i)] = 1'd0;
  end

  assign buffers__clk[0] = clk;
  assign buffers__reset[0] = reset;
  assign buffers__clk[1] = clk;
  assign buffers__reset[1] = reset;
  assign buffers__recv__msg[0] = recv__msg;
  assign send__msg[0] = buffers__send__msg[0];
  assign buffers__send__rdy[0] = send__rdy[0];
  assign send__val[0] = buffers__send__val[0];
  assign buffers__recv__msg[1] = recv__msg;
  assign send__msg[1] = buffers__send__msg[1];
  assign buffers__send__rdy[1] = send__rdy[1];
  assign send__val[1] = buffers__send__val[1];

endmodule


// PyMTL Component OutputUnitCreditRTL Definition
// Full name: OutputUnitCreditRTL__MsgType_IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74__vc_2__credit_line_2
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/OutputUnitCreditRTL.py

module OutputUnitCreditRTL__32ad184d10468f6d
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output logic [0:0] send__en  ,
  output IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send__msg  ,
  input logic [0:0] send__yum [0:1] 
);
  localparam logic [1:0] __const__vc_at_up_credit_send  = 2'd2;
  localparam logic [1:0] __const__vc_at_up_counter_decr  = 2'd2;
  //-------------------------------------------------------------
  // Component credit[0:1]
  //-------------------------------------------------------------

  logic [0:0] credit__clk [0:1];
  logic [1:0] credit__count [0:1];
  logic [0:0] credit__decr [0:1];
  logic [0:0] credit__incr [0:1];
  logic [0:0] credit__load [0:1];
  logic [1:0] credit__load_value [0:1];
  logic [0:0] credit__reset [0:1];

  Counter__Type_Bits2__reset_value_2 credit__0
  (
    .clk( credit__clk[0] ),
    .count( credit__count[0] ),
    .decr( credit__decr[0] ),
    .incr( credit__incr[0] ),
    .load( credit__load[0] ),
    .load_value( credit__load_value[0] ),
    .reset( credit__reset[0] )
  );

  Counter__Type_Bits2__reset_value_2 credit__1
  (
    .clk( credit__clk[1] ),
    .count( credit__count[1] ),
    .decr( credit__decr[1] ),
    .incr( credit__incr[1] ),
    .load( credit__load[1] ),
    .load_value( credit__load_value[1] ),
    .reset( credit__reset[1] )
  );

  //-------------------------------------------------------------
  // End of component credit[0:1]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/OutputUnitCreditRTL.py:47
  // @update
  // def up_counter_decr():
  //   for i in range( vc ):
  //     s.credit[i].decr @= s.send.en & ( i == s.send.msg.vc_id )
  
  always_comb begin : up_counter_decr
    for ( int unsigned i = 1'd0; i < 2'( __const__vc_at_up_counter_decr ); i += 1'd1 )
      credit__decr[1'(i)] = send__en & ( 1'(i) == send__msg.vc_id );
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/OutputUnitCreditRTL.py:35
  // @update
  // def up_credit_send():
  //   s.send.en  @= 0
  //   s.recv.rdy @= 0
  //   # NOTE: Here the recv.rdy depends on recv.val.
  //   #       Be careful about combinational loop.
  //   if s.recv.val:
  //     for i in range( vc ):
  //       if (i == s.recv.msg.vc_id) & (s.credit[i].count > 0):
  //         s.send.en  @= 1
  //         s.recv.rdy @= 1
  
  always_comb begin : up_credit_send
    send__en = 1'd0;
    recv__rdy = 1'd0;
    if ( recv__val ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__vc_at_up_credit_send ); i += 1'd1 )
        if ( ( 1'(i) == recv__msg.vc_id ) & ( credit__count[1'(i)] > 2'd0 ) ) begin
          send__en = 1'd1;
          recv__rdy = 1'd1;
        end
    end
  end

  assign credit__clk[0] = clk;
  assign credit__reset[0] = reset;
  assign credit__clk[1] = clk;
  assign credit__reset[1] = reset;
  assign send__msg = recv__msg;
  assign credit__incr[0] = send__yum[0];
  assign credit__load[0] = 1'd0;
  assign credit__load_value[0] = 2'd0;
  assign credit__incr[1] = send__yum[1];
  assign credit__load[1] = 1'd0;
  assign credit__load_value[1] = 2'd0;

endmodule


// PyMTL Component RingRouteUnitRTL Definition
// Full name: RingRouteUnitRTL__PacketType_IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74__PositionType_Bits3__num_routers_5
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/ringnet/RingRouteUnitRTL.py

module RingRouteUnitRTL__d99b65a77b6962ed
(
  input  logic [0:0] clk ,
  input  logic [2:0] pos ,
  input  logic [0:0] reset ,
  input IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send__msg [0:2] ,
  input logic [0:0] send__rdy [0:2] ,
  output logic [0:0] send__val [0:2] 
);
  localparam logic [1:0] __const__SELF  = 2'd2;
  localparam logic [0:0] __const__LEFT  = 1'd0;
  localparam logic [0:0] __const__RIGHT  = 1'd1;
  logic [2:0] left_dist;
  logic [1:0] out_dir;
  logic [2:0] right_dist;
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send_msg_wire;
  logic [2:0] send_rdy;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/ringnet/RingRouteUnitRTL.py:51
  // @update
  // def up_left_right_dist():
  //   if s.recv.msg.dst < s.pos:
  //     s.left_dist  @= zext(s.pos, DistType) - zext(s.recv.msg.dst, DistType)
  //     s.right_dist @= zext(s.last_idx, DistType) - zext(s.pos, DistType) + zext(s.recv.msg.dst, DistType) + 1
  //   else:
  //     s.left_dist  @= 1 + zext(s.last_idx, DistType) + zext(s.pos, DistType) - zext(s.recv.msg.dst, DistType)
  //     s.right_dist @= zext(s.recv.msg.dst, DistType) - zext(s.pos, DistType)
  
  always_comb begin : up_left_right_dist
    if ( recv__msg.dst < pos ) begin
      left_dist = pos - recv__msg.dst;
      right_dist = ( ( 3'd4 - pos ) + recv__msg.dst ) + 3'd1;
    end
    else begin
      left_dist = ( ( 3'd1 + 3'd4 ) + pos ) - recv__msg.dst;
      right_dist = recv__msg.dst - pos;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/ringnet/RingRouteUnitRTL.py:85
  // @update
  // def up_ru_recv_rdy():
  //   s.recv.rdy @= s.send_rdy[ s.out_dir ]
  
  always_comb begin : up_ru_recv_rdy
    recv__rdy = send_rdy[out_dir];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/ringnet/RingRouteUnitRTL.py:60
  // @update
  // def up_ru_routing():
  // 
  //   s.out_dir @= 0
  //   s.send_msg_wire @= s.recv.msg
  //   for i in range( s.num_outports ):
  //     s.send[i].val @= 0
  //     s.send[i].msg @= s.recv.msg
  // 
  //   if s.recv.val:
  //     if s.pos == s.recv.msg.dst:
  //       s.out_dir @= SELF
  //     elif s.left_dist < s.right_dist:
  //       s.out_dir @= LEFT
  //     else:
  //       s.out_dir @= RIGHT
  // 
  //     if ( s.pos == s.last_idx ) & ( s.out_dir == RIGHT ):
  //       s.send_msg_wire.vc_id @= 1
  //     elif ( s.pos == 0 ) & ( s.out_dir == LEFT ):
  //       s.send_msg_wire.vc_id @= 1
  // 
  //     s.send[ s.out_dir ].val @= 1
  //     s.send[ s.out_dir ].msg @= s.send_msg_wire
  
  always_comb begin : up_ru_routing
    out_dir = 2'd0;
    send_msg_wire = recv__msg;
    for ( int unsigned i = 1'd0; i < 2'd3; i += 1'd1 ) begin
      send__val[2'(i)] = 1'd0;
      send__msg[2'(i)] = recv__msg;
    end
    if ( recv__val ) begin
      if ( pos == recv__msg.dst ) begin
        out_dir = 2'( __const__SELF );
      end
      else if ( left_dist < right_dist ) begin
        out_dir = 2'( __const__LEFT );
      end
      else
        out_dir = 2'( __const__RIGHT );
      if ( ( pos == 3'd4 ) & ( out_dir == 2'( __const__RIGHT ) ) ) begin
        send_msg_wire.vc_id = 1'd1;
      end
      else if ( ( pos == 3'd0 ) & ( out_dir == 2'( __const__LEFT ) ) ) begin
        send_msg_wire.vc_id = 1'd1;
      end
      send__val[out_dir] = 1'd1;
      send__msg[out_dir] = send_msg_wire;
    end
  end

  assign send_rdy[0:0] = send__rdy[0];
  assign send_rdy[1:1] = send__rdy[1];
  assign send_rdy[2:2] = send__rdy[2];

endmodule


// PyMTL Component RegEnRst Definition
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/registers.py

module RegEnRst__Type_Bits6__reset_value_1
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [5:0] in_ ,
  output logic [5:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd1;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 6'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RoundRobinArbiterEn Definition
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py

module RoundRobinArbiterEn__nreqs_6
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  output logic [5:0] grants ,
  input  logic [5:0] reqs ,
  input  logic [0:0] reset 
);
  localparam logic [2:0] __const__nreqs_at_comb_reqs_int  = 3'd6;
  localparam logic [3:0] __const__nreqsX2_at_comb_reqs_int  = 4'd12;
  localparam logic [2:0] __const__nreqs_at_comb_grants  = 3'd6;
  localparam logic [2:0] __const__nreqs_at_comb_priority_int  = 3'd6;
  localparam logic [3:0] __const__nreqsX2_at_comb_priority_int  = 4'd12;
  localparam logic [3:0] __const__nreqsX2_at_comb_kills  = 4'd12;
  localparam logic [3:0] __const__nreqsX2_at_comb_grants_int  = 4'd12;
  logic [11:0] grants_int;
  logic [12:0] kills;
  logic [0:0] priority_en;
  logic [11:0] priority_int;
  logic [11:0] reqs_int;
  //-------------------------------------------------------------
  // Component priority_reg
  //-------------------------------------------------------------

  logic [0:0] priority_reg__clk;
  logic [0:0] priority_reg__en;
  logic [5:0] priority_reg__in_;
  logic [5:0] priority_reg__out;
  logic [0:0] priority_reg__reset;

  RegEnRst__Type_Bits6__reset_value_1 priority_reg
  (
    .clk( priority_reg__clk ),
    .en( priority_reg__en ),
    .in_( priority_reg__in_ ),
    .out( priority_reg__out ),
    .reset( priority_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component priority_reg
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:118
  // @update
  // def comb_grants():
  //   for i in range( nreqs ):
  //     s.grants[i] @= s.grants_int[i] | s.grants_int[nreqs+i]
  
  always_comb begin : comb_grants
    for ( int unsigned i = 1'd0; i < 3'( __const__nreqs_at_comb_grants ); i += 1'd1 )
      grants[3'(i)] = grants_int[4'(i)] | grants_int[4'( __const__nreqs_at_comb_grants ) + 4'(i)];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:141
  // @update
  // def comb_grants_int():
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.grants_int[i] @= s.reqs_int[i]
  //     else:
  //       s.grants_int[i] @= ~s.kills[i] & s.reqs_int[i]
  
  always_comb begin : comb_grants_int
    for ( int unsigned i = 1'd0; i < 4'( __const__nreqsX2_at_comb_grants_int ); i += 1'd1 )
      if ( priority_int[4'(i)] ) begin
        grants_int[4'(i)] = reqs_int[4'(i)];
      end
      else
        grants_int[4'(i)] = ( ~kills[4'(i)] ) & reqs_int[4'(i)];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:132
  // @update
  // def comb_kills():
  //   s.kills[0] @= 1
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.kills[i+1] @= s.reqs_int[i]
  //     else:
  //       s.kills[i+1] @= s.kills[i] | ( ~s.kills[i] & s.reqs_int[i] )
  
  always_comb begin : comb_kills
    kills[4'd0] = 1'd1;
    for ( int unsigned i = 1'd0; i < 4'( __const__nreqsX2_at_comb_kills ); i += 1'd1 )
      if ( priority_int[4'(i)] ) begin
        kills[4'(i) + 4'd1] = reqs_int[4'(i)];
      end
      else
        kills[4'(i) + 4'd1] = kills[4'(i)] | ( ( ~kills[4'(i)] ) & reqs_int[4'(i)] );
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:123
  // @update
  // def comb_priority_en():
  //   s.priority_en @= ( s.grants != 0 ) & s.en
  
  always_comb begin : comb_priority_en
    priority_en = ( grants != 6'd0 ) & en;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:127
  // @update
  // def comb_priority_int():
  //   s.priority_int[    0:nreqs  ] @= s.priority_reg.out
  //   s.priority_int[nreqs:nreqsX2] @= 0
  
  always_comb begin : comb_priority_int
    priority_int[4'd5:4'd0] = priority_reg__out;
    priority_int[4'd11:4'( __const__nreqs_at_comb_priority_int )] = 6'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:113
  // @update
  // def comb_reqs_int():
  //   s.reqs_int [    0:nreqs  ] @= s.reqs
  //   s.reqs_int [nreqs:nreqsX2] @= s.reqs
  
  always_comb begin : comb_reqs_int
    reqs_int[4'd5:4'd0] = reqs;
    reqs_int[4'd11:4'( __const__nreqs_at_comb_reqs_int )] = reqs;
  end

  assign priority_reg__clk = clk;
  assign priority_reg__reset = reset;
  assign priority_reg__en = priority_en;
  assign priority_reg__in_[5:1] = grants[4:0];
  assign priority_reg__in_[0:0] = grants[5:5];

endmodule


// PyMTL Component Encoder Definition
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/encoders.py

module Encoder__in_nbits_6__out_nbits_3
(
  input  logic [0:0] clk ,
  input  logic [5:0] in_ ,
  output logic [2:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/encoders.py:28
  // @update
  // def encode():
  //   s.out @= 0
  //   for i in range( s.in_nbits ):
  //     if s.in_[i]:
  //       s.out @= i
  
  always_comb begin : encode
    out = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'd6; i += 1'd1 )
      if ( in_[3'(i)] ) begin
        out = 3'(i);
      end
  end

endmodule


// PyMTL Component Mux Definition
// Full name: Mux__Type_IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74__ninputs_6
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py

module Mux__a69d07d1d62bafa1
(
  input  logic [0:0] clk ,
  input  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 in_ [0:5],
  output IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 out ,
  input  logic [0:0] reset ,
  input  logic [2:0] sel 
);

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component SwitchUnitRTL Definition
// Full name: SwitchUnitRTL__PacketType_IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74__num_inports_6
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py

module SwitchUnitRTL__8c20764171b5af2c
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv__msg [0:5] ,
  output logic [0:0] recv__rdy [0:5] ,
  input logic [0:0] recv__val [0:5] ,
  output IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  localparam logic [2:0] __const__num_inports_at_up_get_en  = 3'd6;
  //-------------------------------------------------------------
  // Component arbiter
  //-------------------------------------------------------------

  logic [0:0] arbiter__clk;
  logic [0:0] arbiter__en;
  logic [5:0] arbiter__grants;
  logic [5:0] arbiter__reqs;
  logic [0:0] arbiter__reset;

  RoundRobinArbiterEn__nreqs_6 arbiter
  (
    .clk( arbiter__clk ),
    .en( arbiter__en ),
    .grants( arbiter__grants ),
    .reqs( arbiter__reqs ),
    .reset( arbiter__reset )
  );

  //-------------------------------------------------------------
  // End of component arbiter
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component encoder
  //-------------------------------------------------------------

  logic [0:0] encoder__clk;
  logic [5:0] encoder__in_;
  logic [2:0] encoder__out;
  logic [0:0] encoder__reset;

  Encoder__in_nbits_6__out_nbits_3 encoder
  (
    .clk( encoder__clk ),
    .in_( encoder__in_ ),
    .out( encoder__out ),
    .reset( encoder__reset )
  );

  //-------------------------------------------------------------
  // End of component encoder
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mux
  //-------------------------------------------------------------

  logic [0:0] mux__clk;
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 mux__in_ [0:5];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 mux__out;
  logic [0:0] mux__reset;
  logic [2:0] mux__sel;

  Mux__a69d07d1d62bafa1 mux
  (
    .clk( mux__clk ),
    .in_( mux__in_ ),
    .out( mux__out ),
    .reset( mux__reset ),
    .sel( mux__sel )
  );

  //-------------------------------------------------------------
  // End of component mux
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py:56
  // @update
  // def up_get_en():
  //   for i in range( num_inports ):
  //     s.recv[i].rdy @= s.send.rdy & ( s.mux.sel == i )
  
  always_comb begin : up_get_en
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_up_get_en ); i += 1'd1 )
      recv__rdy[3'(i)] = send__rdy & ( mux__sel == 3'(i) );
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py:51
  // @update
  // def up_send_val():
  //   s.send.val @= s.arbiter.grants > 0
  
  always_comb begin : up_send_val
    send__val = arbiter__grants > 6'd0;
  end

  assign arbiter__clk = clk;
  assign arbiter__reset = reset;
  assign arbiter__en = 1'd1;
  assign mux__clk = clk;
  assign mux__reset = reset;
  assign send__msg = mux__out;
  assign encoder__clk = clk;
  assign encoder__reset = reset;
  assign encoder__in_ = arbiter__grants;
  assign mux__sel = encoder__out;
  assign arbiter__reqs[0:0] = recv__val[0];
  assign mux__in_[0] = recv__msg[0];
  assign arbiter__reqs[1:1] = recv__val[1];
  assign mux__in_[1] = recv__msg[1];
  assign arbiter__reqs[2:2] = recv__val[2];
  assign mux__in_[2] = recv__msg[2];
  assign arbiter__reqs[3:3] = recv__val[3];
  assign mux__in_[3] = recv__msg[3];
  assign arbiter__reqs[4:4] = recv__val[4];
  assign mux__in_[4] = recv__msg[4];
  assign arbiter__reqs[5:5] = recv__val[5];
  assign mux__in_[5] = recv__msg[5];

endmodule


// PyMTL Component RingRouterRTL Definition
// Full name: RingRouterRTL__PacketType_IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74__PositionType_Bits3__num_routers_5__InputUnitType_InputUnitCreditRTL__RouteUnitType_RingRouteUnitRTL__SwitchUnitType_SwitchUnitRTL__OutputUnitType_OutputUnitCreditRTL__vc_2__credit_line_2
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/ringnet/RingRouterRTL.py

module RingRouterRTL__e70bd99851f09b15
(
  input  logic [0:0] clk ,
  input  logic [2:0] pos ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en [0:2] ,
  input IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv__msg [0:2] ,
  output logic [0:0] recv__yum [0:2][0:1] ,
  output logic [0:0] send__en [0:2] ,
  output IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send__msg [0:2] ,
  input logic [0:0] send__yum [0:2][0:1] 
);
  //-------------------------------------------------------------
  // Component input_units[0:2]
  //-------------------------------------------------------------

  logic [0:0] input_units__clk [0:2];
  logic [0:0] input_units__reset [0:2];
  logic [0:0] input_units__recv__en [0:2];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 input_units__recv__msg [0:2];
  logic [0:0] input_units__recv__yum [0:2][0:1];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 input_units__send__msg [0:2][0:1];
  logic [0:0] input_units__send__rdy [0:2][0:1];
  logic [0:0] input_units__send__val [0:2][0:1];

  InputUnitCreditRTL__3310d4c884d771ee input_units__0
  (
    .clk( input_units__clk[0] ),
    .reset( input_units__reset[0] ),
    .recv__en( input_units__recv__en[0] ),
    .recv__msg( input_units__recv__msg[0] ),
    .recv__yum( input_units__recv__yum[0] ),
    .send__msg( input_units__send__msg[0] ),
    .send__rdy( input_units__send__rdy[0] ),
    .send__val( input_units__send__val[0] )
  );

  InputUnitCreditRTL__3310d4c884d771ee input_units__1
  (
    .clk( input_units__clk[1] ),
    .reset( input_units__reset[1] ),
    .recv__en( input_units__recv__en[1] ),
    .recv__msg( input_units__recv__msg[1] ),
    .recv__yum( input_units__recv__yum[1] ),
    .send__msg( input_units__send__msg[1] ),
    .send__rdy( input_units__send__rdy[1] ),
    .send__val( input_units__send__val[1] )
  );

  InputUnitCreditRTL__3310d4c884d771ee input_units__2
  (
    .clk( input_units__clk[2] ),
    .reset( input_units__reset[2] ),
    .recv__en( input_units__recv__en[2] ),
    .recv__msg( input_units__recv__msg[2] ),
    .recv__yum( input_units__recv__yum[2] ),
    .send__msg( input_units__send__msg[2] ),
    .send__rdy( input_units__send__rdy[2] ),
    .send__val( input_units__send__val[2] )
  );

  //-------------------------------------------------------------
  // End of component input_units[0:2]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component output_units[0:2]
  //-------------------------------------------------------------

  logic [0:0] output_units__clk [0:2];
  logic [0:0] output_units__reset [0:2];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 output_units__recv__msg [0:2];
  logic [0:0] output_units__recv__rdy [0:2];
  logic [0:0] output_units__recv__val [0:2];
  logic [0:0] output_units__send__en [0:2];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 output_units__send__msg [0:2];
  logic [0:0] output_units__send__yum [0:2][0:1];

  OutputUnitCreditRTL__32ad184d10468f6d output_units__0
  (
    .clk( output_units__clk[0] ),
    .reset( output_units__reset[0] ),
    .recv__msg( output_units__recv__msg[0] ),
    .recv__rdy( output_units__recv__rdy[0] ),
    .recv__val( output_units__recv__val[0] ),
    .send__en( output_units__send__en[0] ),
    .send__msg( output_units__send__msg[0] ),
    .send__yum( output_units__send__yum[0] )
  );

  OutputUnitCreditRTL__32ad184d10468f6d output_units__1
  (
    .clk( output_units__clk[1] ),
    .reset( output_units__reset[1] ),
    .recv__msg( output_units__recv__msg[1] ),
    .recv__rdy( output_units__recv__rdy[1] ),
    .recv__val( output_units__recv__val[1] ),
    .send__en( output_units__send__en[1] ),
    .send__msg( output_units__send__msg[1] ),
    .send__yum( output_units__send__yum[1] )
  );

  OutputUnitCreditRTL__32ad184d10468f6d output_units__2
  (
    .clk( output_units__clk[2] ),
    .reset( output_units__reset[2] ),
    .recv__msg( output_units__recv__msg[2] ),
    .recv__rdy( output_units__recv__rdy[2] ),
    .recv__val( output_units__recv__val[2] ),
    .send__en( output_units__send__en[2] ),
    .send__msg( output_units__send__msg[2] ),
    .send__yum( output_units__send__yum[2] )
  );

  //-------------------------------------------------------------
  // End of component output_units[0:2]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component route_units[0:5]
  //-------------------------------------------------------------

  logic [0:0] route_units__clk [0:5];
  logic [2:0] route_units__pos [0:5];
  logic [0:0] route_units__reset [0:5];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 route_units__recv__msg [0:5];
  logic [0:0] route_units__recv__rdy [0:5];
  logic [0:0] route_units__recv__val [0:5];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 route_units__send__msg [0:5][0:2];
  logic [0:0] route_units__send__rdy [0:5][0:2];
  logic [0:0] route_units__send__val [0:5][0:2];

  RingRouteUnitRTL__d99b65a77b6962ed route_units__0
  (
    .clk( route_units__clk[0] ),
    .pos( route_units__pos[0] ),
    .reset( route_units__reset[0] ),
    .recv__msg( route_units__recv__msg[0] ),
    .recv__rdy( route_units__recv__rdy[0] ),
    .recv__val( route_units__recv__val[0] ),
    .send__msg( route_units__send__msg[0] ),
    .send__rdy( route_units__send__rdy[0] ),
    .send__val( route_units__send__val[0] )
  );

  RingRouteUnitRTL__d99b65a77b6962ed route_units__1
  (
    .clk( route_units__clk[1] ),
    .pos( route_units__pos[1] ),
    .reset( route_units__reset[1] ),
    .recv__msg( route_units__recv__msg[1] ),
    .recv__rdy( route_units__recv__rdy[1] ),
    .recv__val( route_units__recv__val[1] ),
    .send__msg( route_units__send__msg[1] ),
    .send__rdy( route_units__send__rdy[1] ),
    .send__val( route_units__send__val[1] )
  );

  RingRouteUnitRTL__d99b65a77b6962ed route_units__2
  (
    .clk( route_units__clk[2] ),
    .pos( route_units__pos[2] ),
    .reset( route_units__reset[2] ),
    .recv__msg( route_units__recv__msg[2] ),
    .recv__rdy( route_units__recv__rdy[2] ),
    .recv__val( route_units__recv__val[2] ),
    .send__msg( route_units__send__msg[2] ),
    .send__rdy( route_units__send__rdy[2] ),
    .send__val( route_units__send__val[2] )
  );

  RingRouteUnitRTL__d99b65a77b6962ed route_units__3
  (
    .clk( route_units__clk[3] ),
    .pos( route_units__pos[3] ),
    .reset( route_units__reset[3] ),
    .recv__msg( route_units__recv__msg[3] ),
    .recv__rdy( route_units__recv__rdy[3] ),
    .recv__val( route_units__recv__val[3] ),
    .send__msg( route_units__send__msg[3] ),
    .send__rdy( route_units__send__rdy[3] ),
    .send__val( route_units__send__val[3] )
  );

  RingRouteUnitRTL__d99b65a77b6962ed route_units__4
  (
    .clk( route_units__clk[4] ),
    .pos( route_units__pos[4] ),
    .reset( route_units__reset[4] ),
    .recv__msg( route_units__recv__msg[4] ),
    .recv__rdy( route_units__recv__rdy[4] ),
    .recv__val( route_units__recv__val[4] ),
    .send__msg( route_units__send__msg[4] ),
    .send__rdy( route_units__send__rdy[4] ),
    .send__val( route_units__send__val[4] )
  );

  RingRouteUnitRTL__d99b65a77b6962ed route_units__5
  (
    .clk( route_units__clk[5] ),
    .pos( route_units__pos[5] ),
    .reset( route_units__reset[5] ),
    .recv__msg( route_units__recv__msg[5] ),
    .recv__rdy( route_units__recv__rdy[5] ),
    .recv__val( route_units__recv__val[5] ),
    .send__msg( route_units__send__msg[5] ),
    .send__rdy( route_units__send__rdy[5] ),
    .send__val( route_units__send__val[5] )
  );

  //-------------------------------------------------------------
  // End of component route_units[0:5]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component switch_units[0:2]
  //-------------------------------------------------------------

  logic [0:0] switch_units__clk [0:2];
  logic [0:0] switch_units__reset [0:2];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 switch_units__recv__msg [0:2][0:5];
  logic [0:0] switch_units__recv__rdy [0:2][0:5];
  logic [0:0] switch_units__recv__val [0:2][0:5];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 switch_units__send__msg [0:2];
  logic [0:0] switch_units__send__rdy [0:2];
  logic [0:0] switch_units__send__val [0:2];

  SwitchUnitRTL__8c20764171b5af2c switch_units__0
  (
    .clk( switch_units__clk[0] ),
    .reset( switch_units__reset[0] ),
    .recv__msg( switch_units__recv__msg[0] ),
    .recv__rdy( switch_units__recv__rdy[0] ),
    .recv__val( switch_units__recv__val[0] ),
    .send__msg( switch_units__send__msg[0] ),
    .send__rdy( switch_units__send__rdy[0] ),
    .send__val( switch_units__send__val[0] )
  );

  SwitchUnitRTL__8c20764171b5af2c switch_units__1
  (
    .clk( switch_units__clk[1] ),
    .reset( switch_units__reset[1] ),
    .recv__msg( switch_units__recv__msg[1] ),
    .recv__rdy( switch_units__recv__rdy[1] ),
    .recv__val( switch_units__recv__val[1] ),
    .send__msg( switch_units__send__msg[1] ),
    .send__rdy( switch_units__send__rdy[1] ),
    .send__val( switch_units__send__val[1] )
  );

  SwitchUnitRTL__8c20764171b5af2c switch_units__2
  (
    .clk( switch_units__clk[2] ),
    .reset( switch_units__reset[2] ),
    .recv__msg( switch_units__recv__msg[2] ),
    .recv__rdy( switch_units__recv__rdy[2] ),
    .recv__val( switch_units__recv__val[2] ),
    .send__msg( switch_units__send__msg[2] ),
    .send__rdy( switch_units__send__rdy[2] ),
    .send__val( switch_units__send__val[2] )
  );

  //-------------------------------------------------------------
  // End of component switch_units[0:2]
  //-------------------------------------------------------------

  assign input_units__clk[0] = clk;
  assign input_units__reset[0] = reset;
  assign input_units__clk[1] = clk;
  assign input_units__reset[1] = reset;
  assign input_units__clk[2] = clk;
  assign input_units__reset[2] = reset;
  assign route_units__clk[0] = clk;
  assign route_units__reset[0] = reset;
  assign route_units__clk[1] = clk;
  assign route_units__reset[1] = reset;
  assign route_units__clk[2] = clk;
  assign route_units__reset[2] = reset;
  assign route_units__clk[3] = clk;
  assign route_units__reset[3] = reset;
  assign route_units__clk[4] = clk;
  assign route_units__reset[4] = reset;
  assign route_units__clk[5] = clk;
  assign route_units__reset[5] = reset;
  assign switch_units__clk[0] = clk;
  assign switch_units__reset[0] = reset;
  assign switch_units__clk[1] = clk;
  assign switch_units__reset[1] = reset;
  assign switch_units__clk[2] = clk;
  assign switch_units__reset[2] = reset;
  assign output_units__clk[0] = clk;
  assign output_units__reset[0] = reset;
  assign output_units__clk[1] = clk;
  assign output_units__reset[1] = reset;
  assign output_units__clk[2] = clk;
  assign output_units__reset[2] = reset;
  assign input_units__recv__en[0] = recv__en[0];
  assign input_units__recv__msg[0] = recv__msg[0];
  assign recv__yum[0][0] = input_units__recv__yum[0][0];
  assign recv__yum[0][1] = input_units__recv__yum[0][1];
  assign route_units__recv__msg[0] = input_units__send__msg[0][0];
  assign input_units__send__rdy[0][0] = route_units__recv__rdy[0];
  assign route_units__recv__val[0] = input_units__send__val[0][0];
  assign route_units__pos[0] = pos;
  assign route_units__recv__msg[1] = input_units__send__msg[0][1];
  assign input_units__send__rdy[0][1] = route_units__recv__rdy[1];
  assign route_units__recv__val[1] = input_units__send__val[0][1];
  assign route_units__pos[1] = pos;
  assign input_units__recv__en[1] = recv__en[1];
  assign input_units__recv__msg[1] = recv__msg[1];
  assign recv__yum[1][0] = input_units__recv__yum[1][0];
  assign recv__yum[1][1] = input_units__recv__yum[1][1];
  assign route_units__recv__msg[2] = input_units__send__msg[1][0];
  assign input_units__send__rdy[1][0] = route_units__recv__rdy[2];
  assign route_units__recv__val[2] = input_units__send__val[1][0];
  assign route_units__pos[2] = pos;
  assign route_units__recv__msg[3] = input_units__send__msg[1][1];
  assign input_units__send__rdy[1][1] = route_units__recv__rdy[3];
  assign route_units__recv__val[3] = input_units__send__val[1][1];
  assign route_units__pos[3] = pos;
  assign input_units__recv__en[2] = recv__en[2];
  assign input_units__recv__msg[2] = recv__msg[2];
  assign recv__yum[2][0] = input_units__recv__yum[2][0];
  assign recv__yum[2][1] = input_units__recv__yum[2][1];
  assign route_units__recv__msg[4] = input_units__send__msg[2][0];
  assign input_units__send__rdy[2][0] = route_units__recv__rdy[4];
  assign route_units__recv__val[4] = input_units__send__val[2][0];
  assign route_units__pos[4] = pos;
  assign route_units__recv__msg[5] = input_units__send__msg[2][1];
  assign input_units__send__rdy[2][1] = route_units__recv__rdy[5];
  assign route_units__recv__val[5] = input_units__send__val[2][1];
  assign route_units__pos[5] = pos;
  assign switch_units__recv__msg[0][0] = route_units__send__msg[0][0];
  assign route_units__send__rdy[0][0] = switch_units__recv__rdy[0][0];
  assign switch_units__recv__val[0][0] = route_units__send__val[0][0];
  assign switch_units__recv__msg[1][0] = route_units__send__msg[0][1];
  assign route_units__send__rdy[0][1] = switch_units__recv__rdy[1][0];
  assign switch_units__recv__val[1][0] = route_units__send__val[0][1];
  assign switch_units__recv__msg[2][0] = route_units__send__msg[0][2];
  assign route_units__send__rdy[0][2] = switch_units__recv__rdy[2][0];
  assign switch_units__recv__val[2][0] = route_units__send__val[0][2];
  assign switch_units__recv__msg[0][1] = route_units__send__msg[1][0];
  assign route_units__send__rdy[1][0] = switch_units__recv__rdy[0][1];
  assign switch_units__recv__val[0][1] = route_units__send__val[1][0];
  assign switch_units__recv__msg[1][1] = route_units__send__msg[1][1];
  assign route_units__send__rdy[1][1] = switch_units__recv__rdy[1][1];
  assign switch_units__recv__val[1][1] = route_units__send__val[1][1];
  assign switch_units__recv__msg[2][1] = route_units__send__msg[1][2];
  assign route_units__send__rdy[1][2] = switch_units__recv__rdy[2][1];
  assign switch_units__recv__val[2][1] = route_units__send__val[1][2];
  assign switch_units__recv__msg[0][2] = route_units__send__msg[2][0];
  assign route_units__send__rdy[2][0] = switch_units__recv__rdy[0][2];
  assign switch_units__recv__val[0][2] = route_units__send__val[2][0];
  assign switch_units__recv__msg[1][2] = route_units__send__msg[2][1];
  assign route_units__send__rdy[2][1] = switch_units__recv__rdy[1][2];
  assign switch_units__recv__val[1][2] = route_units__send__val[2][1];
  assign switch_units__recv__msg[2][2] = route_units__send__msg[2][2];
  assign route_units__send__rdy[2][2] = switch_units__recv__rdy[2][2];
  assign switch_units__recv__val[2][2] = route_units__send__val[2][2];
  assign switch_units__recv__msg[0][3] = route_units__send__msg[3][0];
  assign route_units__send__rdy[3][0] = switch_units__recv__rdy[0][3];
  assign switch_units__recv__val[0][3] = route_units__send__val[3][0];
  assign switch_units__recv__msg[1][3] = route_units__send__msg[3][1];
  assign route_units__send__rdy[3][1] = switch_units__recv__rdy[1][3];
  assign switch_units__recv__val[1][3] = route_units__send__val[3][1];
  assign switch_units__recv__msg[2][3] = route_units__send__msg[3][2];
  assign route_units__send__rdy[3][2] = switch_units__recv__rdy[2][3];
  assign switch_units__recv__val[2][3] = route_units__send__val[3][2];
  assign switch_units__recv__msg[0][4] = route_units__send__msg[4][0];
  assign route_units__send__rdy[4][0] = switch_units__recv__rdy[0][4];
  assign switch_units__recv__val[0][4] = route_units__send__val[4][0];
  assign switch_units__recv__msg[1][4] = route_units__send__msg[4][1];
  assign route_units__send__rdy[4][1] = switch_units__recv__rdy[1][4];
  assign switch_units__recv__val[1][4] = route_units__send__val[4][1];
  assign switch_units__recv__msg[2][4] = route_units__send__msg[4][2];
  assign route_units__send__rdy[4][2] = switch_units__recv__rdy[2][4];
  assign switch_units__recv__val[2][4] = route_units__send__val[4][2];
  assign switch_units__recv__msg[0][5] = route_units__send__msg[5][0];
  assign route_units__send__rdy[5][0] = switch_units__recv__rdy[0][5];
  assign switch_units__recv__val[0][5] = route_units__send__val[5][0];
  assign switch_units__recv__msg[1][5] = route_units__send__msg[5][1];
  assign route_units__send__rdy[5][1] = switch_units__recv__rdy[1][5];
  assign switch_units__recv__val[1][5] = route_units__send__val[5][1];
  assign switch_units__recv__msg[2][5] = route_units__send__msg[5][2];
  assign route_units__send__rdy[5][2] = switch_units__recv__rdy[2][5];
  assign switch_units__recv__val[2][5] = route_units__send__val[5][2];
  assign output_units__recv__msg[0] = switch_units__send__msg[0];
  assign switch_units__send__rdy[0] = output_units__recv__rdy[0];
  assign output_units__recv__val[0] = switch_units__send__val[0];
  assign send__en[0] = output_units__send__en[0];
  assign send__msg[0] = output_units__send__msg[0];
  assign output_units__send__yum[0][0] = send__yum[0][0];
  assign output_units__send__yum[0][1] = send__yum[0][1];
  assign output_units__recv__msg[1] = switch_units__send__msg[1];
  assign switch_units__send__rdy[1] = output_units__recv__rdy[1];
  assign output_units__recv__val[1] = switch_units__send__val[1];
  assign send__en[1] = output_units__send__en[1];
  assign send__msg[1] = output_units__send__msg[1];
  assign output_units__send__yum[1][0] = send__yum[1][0];
  assign output_units__send__yum[1][1] = send__yum[1][1];
  assign output_units__recv__msg[2] = switch_units__send__msg[2];
  assign switch_units__send__rdy[2] = output_units__recv__rdy[2];
  assign output_units__recv__val[2] = switch_units__send__val[2];
  assign send__en[2] = output_units__send__en[2];
  assign send__msg[2] = output_units__send__msg[2];
  assign output_units__send__yum[2][0] = send__yum[2][0];
  assign output_units__send__yum[2][1] = send__yum[2][1];

endmodule


// PyMTL Component RegEnRst Definition
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/registers.py

module RegEnRst__Type_Bits2__reset_value_1
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [1:0] in_ ,
  output logic [1:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd1;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 2'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RoundRobinArbiterEn Definition
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py

module RoundRobinArbiterEn__nreqs_2
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  output logic [1:0] grants ,
  input  logic [1:0] reqs ,
  input  logic [0:0] reset 
);
  localparam logic [1:0] __const__nreqs_at_comb_reqs_int  = 2'd2;
  localparam logic [2:0] __const__nreqsX2_at_comb_reqs_int  = 3'd4;
  localparam logic [1:0] __const__nreqs_at_comb_grants  = 2'd2;
  localparam logic [1:0] __const__nreqs_at_comb_priority_int  = 2'd2;
  localparam logic [2:0] __const__nreqsX2_at_comb_priority_int  = 3'd4;
  localparam logic [2:0] __const__nreqsX2_at_comb_kills  = 3'd4;
  localparam logic [2:0] __const__nreqsX2_at_comb_grants_int  = 3'd4;
  logic [3:0] grants_int;
  logic [4:0] kills;
  logic [0:0] priority_en;
  logic [3:0] priority_int;
  logic [3:0] reqs_int;
  //-------------------------------------------------------------
  // Component priority_reg
  //-------------------------------------------------------------

  logic [0:0] priority_reg__clk;
  logic [0:0] priority_reg__en;
  logic [1:0] priority_reg__in_;
  logic [1:0] priority_reg__out;
  logic [0:0] priority_reg__reset;

  RegEnRst__Type_Bits2__reset_value_1 priority_reg
  (
    .clk( priority_reg__clk ),
    .en( priority_reg__en ),
    .in_( priority_reg__in_ ),
    .out( priority_reg__out ),
    .reset( priority_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component priority_reg
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:118
  // @update
  // def comb_grants():
  //   for i in range( nreqs ):
  //     s.grants[i] @= s.grants_int[i] | s.grants_int[nreqs+i]
  
  always_comb begin : comb_grants
    for ( int unsigned i = 1'd0; i < 2'( __const__nreqs_at_comb_grants ); i += 1'd1 )
      grants[1'(i)] = grants_int[2'(i)] | grants_int[2'( __const__nreqs_at_comb_grants ) + 2'(i)];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:141
  // @update
  // def comb_grants_int():
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.grants_int[i] @= s.reqs_int[i]
  //     else:
  //       s.grants_int[i] @= ~s.kills[i] & s.reqs_int[i]
  
  always_comb begin : comb_grants_int
    for ( int unsigned i = 1'd0; i < 3'( __const__nreqsX2_at_comb_grants_int ); i += 1'd1 )
      if ( priority_int[2'(i)] ) begin
        grants_int[2'(i)] = reqs_int[2'(i)];
      end
      else
        grants_int[2'(i)] = ( ~kills[3'(i)] ) & reqs_int[2'(i)];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:132
  // @update
  // def comb_kills():
  //   s.kills[0] @= 1
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.kills[i+1] @= s.reqs_int[i]
  //     else:
  //       s.kills[i+1] @= s.kills[i] | ( ~s.kills[i] & s.reqs_int[i] )
  
  always_comb begin : comb_kills
    kills[3'd0] = 1'd1;
    for ( int unsigned i = 1'd0; i < 3'( __const__nreqsX2_at_comb_kills ); i += 1'd1 )
      if ( priority_int[2'(i)] ) begin
        kills[3'(i) + 3'd1] = reqs_int[2'(i)];
      end
      else
        kills[3'(i) + 3'd1] = kills[3'(i)] | ( ( ~kills[3'(i)] ) & reqs_int[2'(i)] );
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:123
  // @update
  // def comb_priority_en():
  //   s.priority_en @= ( s.grants != 0 ) & s.en
  
  always_comb begin : comb_priority_en
    priority_en = ( grants != 2'd0 ) & en;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:127
  // @update
  // def comb_priority_int():
  //   s.priority_int[    0:nreqs  ] @= s.priority_reg.out
  //   s.priority_int[nreqs:nreqsX2] @= 0
  
  always_comb begin : comb_priority_int
    priority_int[2'd1:2'd0] = priority_reg__out;
    priority_int[2'd3:2'( __const__nreqs_at_comb_priority_int )] = 2'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:113
  // @update
  // def comb_reqs_int():
  //   s.reqs_int [    0:nreqs  ] @= s.reqs
  //   s.reqs_int [nreqs:nreqsX2] @= s.reqs
  
  always_comb begin : comb_reqs_int
    reqs_int[2'd1:2'd0] = reqs;
    reqs_int[2'd3:2'( __const__nreqs_at_comb_reqs_int )] = reqs;
  end

  assign priority_reg__clk = clk;
  assign priority_reg__reset = reset;
  assign priority_reg__en = priority_en;
  assign priority_reg__in_[1:1] = grants[0:0];
  assign priority_reg__in_[0:0] = grants[1:1];

endmodule


// PyMTL Component Mux Definition
// Full name: Mux__Type_IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74__ninputs_2
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py

module Mux__64154152e248b941
(
  input  logic [0:0] clk ,
  input  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 in_ [0:1],
  output IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component BypassQueueDpathRTL Definition
// Full name: BypassQueueDpathRTL__EntryType_IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74__num_entries_2
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py

module BypassQueueDpathRTL__9578d8c7b27375fb
(
  input  logic [0:0] clk ,
  input  logic [0:0] mux_sel ,
  input  logic [0:0] raddr ,
  input  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv_msg ,
  input  logic [0:0] reset ,
  output IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send_msg ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component mux
  //-------------------------------------------------------------

  logic [0:0] mux__clk;
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 mux__in_ [0:1];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 mux__out;
  logic [0:0] mux__reset;
  logic [0:0] mux__sel;

  Mux__64154152e248b941 mux
  (
    .clk( mux__clk ),
    .in_( mux__in_ ),
    .out( mux__out ),
    .reset( mux__reset ),
    .sel( mux__sel )
  );

  //-------------------------------------------------------------
  // End of component mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component rf
  //-------------------------------------------------------------

  logic [0:0] rf__clk;
  logic [0:0] rf__raddr [0:0];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 rf__rdata [0:0];
  logic [0:0] rf__reset;
  logic [0:0] rf__waddr [0:0];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 rf__wdata [0:0];
  logic [0:0] rf__wen [0:0];

  RegisterFile__56492c26522fbfc8 rf
  (
    .clk( rf__clk ),
    .raddr( rf__raddr ),
    .rdata( rf__rdata ),
    .reset( rf__reset ),
    .waddr( rf__waddr ),
    .wdata( rf__wdata ),
    .wen( rf__wen )
  );

  //-------------------------------------------------------------
  // End of component rf
  //-------------------------------------------------------------

  assign rf__clk = clk;
  assign rf__reset = reset;
  assign rf__raddr[0] = raddr;
  assign rf__wen[0] = wen;
  assign rf__waddr[0] = waddr;
  assign rf__wdata[0] = recv_msg;
  assign mux__clk = clk;
  assign mux__reset = reset;
  assign mux__sel = mux_sel;
  assign mux__in_[0] = rf__rdata[0];
  assign mux__in_[1] = recv_msg;
  assign send_msg = mux__out;

endmodule


// PyMTL Component BypassQueueRTL Definition
// Full name: BypassQueueRTL__EntryType_IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74__num_entries_2
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py

module BypassQueueRTL__9578d8c7b27375fb
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__mux_sel;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__recv_rdy;
  logic [0:0] ctrl__recv_val;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__send_rdy;
  logic [0:0] ctrl__send_val;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  BypassQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .mux_sel( ctrl__mux_sel ),
    .raddr( ctrl__raddr ),
    .recv_rdy( ctrl__recv_rdy ),
    .recv_val( ctrl__recv_val ),
    .reset( ctrl__reset ),
    .send_rdy( ctrl__send_rdy ),
    .send_val( ctrl__send_val ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  logic [0:0] dpath__mux_sel;
  logic [0:0] dpath__raddr;
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 dpath__recv_msg;
  logic [0:0] dpath__reset;
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 dpath__send_msg;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  BypassQueueDpathRTL__9578d8c7b27375fb dpath
  (
    .clk( dpath__clk ),
    .mux_sel( dpath__mux_sel ),
    .raddr( dpath__raddr ),
    .recv_msg( dpath__recv_msg ),
    .reset( dpath__reset ),
    .send_msg( dpath__send_msg ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign dpath__mux_sel = ctrl__mux_sel;
  assign ctrl__recv_val = recv__val;
  assign recv__rdy = ctrl__recv_rdy;
  assign send__val = ctrl__send_val;
  assign ctrl__send_rdy = send__rdy;
  assign count = ctrl__count;
  assign dpath__recv_msg = recv__msg;
  assign send__msg = dpath__send_msg;

endmodule


// PyMTL Component Encoder Definition
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/encoders.py

module Encoder__in_nbits_2__out_nbits_1
(
  input  logic [0:0] clk ,
  input  logic [1:0] in_ ,
  output logic [0:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/encoders.py:28
  // @update
  // def encode():
  //   s.out @= 0
  //   for i in range( s.in_nbits ):
  //     if s.in_[i]:
  //       s.out @= i
  
  always_comb begin : encode
    out = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'd2; i += 1'd1 )
      if ( in_[1'(i)] ) begin
        out = 1'(i);
      end
  end

endmodule


// PyMTL Component CreditRecvRTL2SendRTL Definition
// Full name: CreditRecvRTL2SendRTL__MsgType_IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74__vc_2__credit_line_2__QType_BypassQueueRTL
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/ocnlib/ifcs/CreditIfc.py

module CreditRecvRTL2SendRTL__cc254bf95e0e391a
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en  ,
  input IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv__msg  ,
  output logic [0:0] recv__yum [0:1] ,
  output IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  localparam logic [1:0] __const__vc_at_up_enq  = 2'd2;
  localparam logic [1:0] __const__vc_at_up_deq_and_send  = 2'd2;
  localparam logic [1:0] __const__vc_at_up_yummy  = 2'd2;
  //-------------------------------------------------------------
  // Component arbiter
  //-------------------------------------------------------------

  logic [0:0] arbiter__clk;
  logic [0:0] arbiter__en;
  logic [1:0] arbiter__grants;
  logic [1:0] arbiter__reqs;
  logic [0:0] arbiter__reset;

  RoundRobinArbiterEn__nreqs_2 arbiter
  (
    .clk( arbiter__clk ),
    .en( arbiter__en ),
    .grants( arbiter__grants ),
    .reqs( arbiter__reqs ),
    .reset( arbiter__reset )
  );

  //-------------------------------------------------------------
  // End of component arbiter
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component buffers[0:1]
  //-------------------------------------------------------------

  logic [0:0] buffers__clk [0:1];
  logic [1:0] buffers__count [0:1];
  logic [0:0] buffers__reset [0:1];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 buffers__recv__msg [0:1];
  logic [0:0] buffers__recv__rdy [0:1];
  logic [0:0] buffers__recv__val [0:1];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 buffers__send__msg [0:1];
  logic [0:0] buffers__send__rdy [0:1];
  logic [0:0] buffers__send__val [0:1];

  BypassQueueRTL__9578d8c7b27375fb buffers__0
  (
    .clk( buffers__clk[0] ),
    .count( buffers__count[0] ),
    .reset( buffers__reset[0] ),
    .recv__msg( buffers__recv__msg[0] ),
    .recv__rdy( buffers__recv__rdy[0] ),
    .recv__val( buffers__recv__val[0] ),
    .send__msg( buffers__send__msg[0] ),
    .send__rdy( buffers__send__rdy[0] ),
    .send__val( buffers__send__val[0] )
  );

  BypassQueueRTL__9578d8c7b27375fb buffers__1
  (
    .clk( buffers__clk[1] ),
    .count( buffers__count[1] ),
    .reset( buffers__reset[1] ),
    .recv__msg( buffers__recv__msg[1] ),
    .recv__rdy( buffers__recv__rdy[1] ),
    .recv__val( buffers__recv__val[1] ),
    .send__msg( buffers__send__msg[1] ),
    .send__rdy( buffers__send__rdy[1] ),
    .send__val( buffers__send__val[1] )
  );

  //-------------------------------------------------------------
  // End of component buffers[0:1]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component encoder
  //-------------------------------------------------------------

  logic [0:0] encoder__clk;
  logic [1:0] encoder__in_;
  logic [0:0] encoder__out;
  logic [0:0] encoder__reset;

  Encoder__in_nbits_2__out_nbits_1 encoder
  (
    .clk( encoder__clk ),
    .in_( encoder__in_ ),
    .out( encoder__out ),
    .reset( encoder__reset )
  );

  //-------------------------------------------------------------
  // End of component encoder
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/ocnlib/ifcs/CreditIfc.py:205
  // @update
  // def up_deq_and_send():
  //   for i in range( vc ):
  //     s.buffers[i].send.rdy @= 0
  // 
  //   s.send.msg @= s.buffers[ s.encoder.out ].send.msg
  // 
  //   if s.arbiter.grants > 0:
  //     s.send.val @= 1
  //     s.buffers[ s.encoder.out ].send.rdy @= s.send.rdy
  //   else:
  //     s.send.val @= 0
  
  always_comb begin : up_deq_and_send
    for ( int unsigned i = 1'd0; i < 2'( __const__vc_at_up_deq_and_send ); i += 1'd1 )
      buffers__send__rdy[1'(i)] = 1'd0;
    send__msg = buffers__send__msg[encoder__out];
    if ( arbiter__grants > 2'd0 ) begin
      send__val = 1'd1;
      buffers__send__rdy[encoder__out] = send__rdy;
    end
    else
      send__val = 1'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/ocnlib/ifcs/CreditIfc.py:194
  // @update
  // def up_enq():
  //   if s.recv.en:
  //     for i in range( vc ):
  //       s.buffers[i].recv.val @= ( s.recv.msg.vc_id == i )
  //   else:
  //     for i in range( vc ):
  //       s.buffers[i].recv.val @= 0
  
  always_comb begin : up_enq
    if ( recv__en ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__vc_at_up_enq ); i += 1'd1 )
        buffers__recv__val[1'(i)] = recv__msg.vc_id == 1'(i);
    end
    else
      for ( int unsigned i = 1'd0; i < 2'( __const__vc_at_up_enq ); i += 1'd1 )
        buffers__recv__val[1'(i)] = 1'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/ocnlib/ifcs/CreditIfc.py:218
  // @update
  // def up_yummy():
  //   for i in range( vc ):
  //     s.recv.yum[i] @= s.buffers[i].send.val & s.buffers[i].send.rdy
  
  always_comb begin : up_yummy
    for ( int unsigned i = 1'd0; i < 2'( __const__vc_at_up_yummy ); i += 1'd1 )
      recv__yum[1'(i)] = buffers__send__val[1'(i)] & buffers__send__rdy[1'(i)];
  end

  assign buffers__clk[0] = clk;
  assign buffers__reset[0] = reset;
  assign buffers__clk[1] = clk;
  assign buffers__reset[1] = reset;
  assign arbiter__clk = clk;
  assign arbiter__reset = reset;
  assign encoder__clk = clk;
  assign encoder__reset = reset;
  assign buffers__recv__msg[0] = recv__msg;
  assign arbiter__reqs[0:0] = buffers__send__val[0];
  assign buffers__recv__msg[1] = recv__msg;
  assign arbiter__reqs[1:1] = buffers__send__val[1];
  assign encoder__in_ = arbiter__grants;
  assign arbiter__en = send__val;

endmodule


// PyMTL Component RingNetworkRTL Definition
// Full name: RingNetworkRTL__PacketType_IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74__PositionType_Bits3__num_routers_5__chl_lat_1__vc_2__credit_line_2
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/ringnet/RingNetworkRTL.py

module RingNetworkRTL__b40416c8553f9b4d
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv__msg [0:4] ,
  output logic [0:0] recv__rdy [0:4] ,
  input logic [0:0] recv__val [0:4] ,
  output IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send__msg [0:4] ,
  input logic [0:0] send__rdy [0:4] ,
  output logic [0:0] send__val [0:4] 
);
  //-------------------------------------------------------------
  // Component recv_adp[0:4]
  //-------------------------------------------------------------

  logic [0:0] recv_adp__clk [0:4];
  logic [0:0] recv_adp__reset [0:4];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv_adp__recv__msg [0:4];
  logic [0:0] recv_adp__recv__rdy [0:4];
  logic [0:0] recv_adp__recv__val [0:4];
  logic [0:0] recv_adp__send__en [0:4];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv_adp__send__msg [0:4];
  logic [0:0] recv_adp__send__yum [0:4][0:1];

  RecvRTL2CreditSendRTL__32ad184d10468f6d recv_adp__0
  (
    .clk( recv_adp__clk[0] ),
    .reset( recv_adp__reset[0] ),
    .recv__msg( recv_adp__recv__msg[0] ),
    .recv__rdy( recv_adp__recv__rdy[0] ),
    .recv__val( recv_adp__recv__val[0] ),
    .send__en( recv_adp__send__en[0] ),
    .send__msg( recv_adp__send__msg[0] ),
    .send__yum( recv_adp__send__yum[0] )
  );

  RecvRTL2CreditSendRTL__32ad184d10468f6d recv_adp__1
  (
    .clk( recv_adp__clk[1] ),
    .reset( recv_adp__reset[1] ),
    .recv__msg( recv_adp__recv__msg[1] ),
    .recv__rdy( recv_adp__recv__rdy[1] ),
    .recv__val( recv_adp__recv__val[1] ),
    .send__en( recv_adp__send__en[1] ),
    .send__msg( recv_adp__send__msg[1] ),
    .send__yum( recv_adp__send__yum[1] )
  );

  RecvRTL2CreditSendRTL__32ad184d10468f6d recv_adp__2
  (
    .clk( recv_adp__clk[2] ),
    .reset( recv_adp__reset[2] ),
    .recv__msg( recv_adp__recv__msg[2] ),
    .recv__rdy( recv_adp__recv__rdy[2] ),
    .recv__val( recv_adp__recv__val[2] ),
    .send__en( recv_adp__send__en[2] ),
    .send__msg( recv_adp__send__msg[2] ),
    .send__yum( recv_adp__send__yum[2] )
  );

  RecvRTL2CreditSendRTL__32ad184d10468f6d recv_adp__3
  (
    .clk( recv_adp__clk[3] ),
    .reset( recv_adp__reset[3] ),
    .recv__msg( recv_adp__recv__msg[3] ),
    .recv__rdy( recv_adp__recv__rdy[3] ),
    .recv__val( recv_adp__recv__val[3] ),
    .send__en( recv_adp__send__en[3] ),
    .send__msg( recv_adp__send__msg[3] ),
    .send__yum( recv_adp__send__yum[3] )
  );

  RecvRTL2CreditSendRTL__32ad184d10468f6d recv_adp__4
  (
    .clk( recv_adp__clk[4] ),
    .reset( recv_adp__reset[4] ),
    .recv__msg( recv_adp__recv__msg[4] ),
    .recv__rdy( recv_adp__recv__rdy[4] ),
    .recv__val( recv_adp__recv__val[4] ),
    .send__en( recv_adp__send__en[4] ),
    .send__msg( recv_adp__send__msg[4] ),
    .send__yum( recv_adp__send__yum[4] )
  );

  //-------------------------------------------------------------
  // End of component recv_adp[0:4]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component routers[0:4]
  //-------------------------------------------------------------

  logic [0:0] routers__clk [0:4];
  logic [2:0] routers__pos [0:4];
  logic [0:0] routers__reset [0:4];
  logic [0:0] routers__recv__en [0:4][0:2];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 routers__recv__msg [0:4][0:2];
  logic [0:0] routers__recv__yum [0:4][0:2][0:1];
  logic [0:0] routers__send__en [0:4][0:2];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 routers__send__msg [0:4][0:2];
  logic [0:0] routers__send__yum [0:4][0:2][0:1];

  RingRouterRTL__e70bd99851f09b15 routers__0
  (
    .clk( routers__clk[0] ),
    .pos( routers__pos[0] ),
    .reset( routers__reset[0] ),
    .recv__en( routers__recv__en[0] ),
    .recv__msg( routers__recv__msg[0] ),
    .recv__yum( routers__recv__yum[0] ),
    .send__en( routers__send__en[0] ),
    .send__msg( routers__send__msg[0] ),
    .send__yum( routers__send__yum[0] )
  );

  RingRouterRTL__e70bd99851f09b15 routers__1
  (
    .clk( routers__clk[1] ),
    .pos( routers__pos[1] ),
    .reset( routers__reset[1] ),
    .recv__en( routers__recv__en[1] ),
    .recv__msg( routers__recv__msg[1] ),
    .recv__yum( routers__recv__yum[1] ),
    .send__en( routers__send__en[1] ),
    .send__msg( routers__send__msg[1] ),
    .send__yum( routers__send__yum[1] )
  );

  RingRouterRTL__e70bd99851f09b15 routers__2
  (
    .clk( routers__clk[2] ),
    .pos( routers__pos[2] ),
    .reset( routers__reset[2] ),
    .recv__en( routers__recv__en[2] ),
    .recv__msg( routers__recv__msg[2] ),
    .recv__yum( routers__recv__yum[2] ),
    .send__en( routers__send__en[2] ),
    .send__msg( routers__send__msg[2] ),
    .send__yum( routers__send__yum[2] )
  );

  RingRouterRTL__e70bd99851f09b15 routers__3
  (
    .clk( routers__clk[3] ),
    .pos( routers__pos[3] ),
    .reset( routers__reset[3] ),
    .recv__en( routers__recv__en[3] ),
    .recv__msg( routers__recv__msg[3] ),
    .recv__yum( routers__recv__yum[3] ),
    .send__en( routers__send__en[3] ),
    .send__msg( routers__send__msg[3] ),
    .send__yum( routers__send__yum[3] )
  );

  RingRouterRTL__e70bd99851f09b15 routers__4
  (
    .clk( routers__clk[4] ),
    .pos( routers__pos[4] ),
    .reset( routers__reset[4] ),
    .recv__en( routers__recv__en[4] ),
    .recv__msg( routers__recv__msg[4] ),
    .recv__yum( routers__recv__yum[4] ),
    .send__en( routers__send__en[4] ),
    .send__msg( routers__send__msg[4] ),
    .send__yum( routers__send__yum[4] )
  );

  //-------------------------------------------------------------
  // End of component routers[0:4]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component send_adp[0:4]
  //-------------------------------------------------------------

  logic [0:0] send_adp__clk [0:4];
  logic [0:0] send_adp__reset [0:4];
  logic [0:0] send_adp__recv__en [0:4];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send_adp__recv__msg [0:4];
  logic [0:0] send_adp__recv__yum [0:4][0:1];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send_adp__send__msg [0:4];
  logic [0:0] send_adp__send__rdy [0:4];
  logic [0:0] send_adp__send__val [0:4];

  CreditRecvRTL2SendRTL__cc254bf95e0e391a send_adp__0
  (
    .clk( send_adp__clk[0] ),
    .reset( send_adp__reset[0] ),
    .recv__en( send_adp__recv__en[0] ),
    .recv__msg( send_adp__recv__msg[0] ),
    .recv__yum( send_adp__recv__yum[0] ),
    .send__msg( send_adp__send__msg[0] ),
    .send__rdy( send_adp__send__rdy[0] ),
    .send__val( send_adp__send__val[0] )
  );

  CreditRecvRTL2SendRTL__cc254bf95e0e391a send_adp__1
  (
    .clk( send_adp__clk[1] ),
    .reset( send_adp__reset[1] ),
    .recv__en( send_adp__recv__en[1] ),
    .recv__msg( send_adp__recv__msg[1] ),
    .recv__yum( send_adp__recv__yum[1] ),
    .send__msg( send_adp__send__msg[1] ),
    .send__rdy( send_adp__send__rdy[1] ),
    .send__val( send_adp__send__val[1] )
  );

  CreditRecvRTL2SendRTL__cc254bf95e0e391a send_adp__2
  (
    .clk( send_adp__clk[2] ),
    .reset( send_adp__reset[2] ),
    .recv__en( send_adp__recv__en[2] ),
    .recv__msg( send_adp__recv__msg[2] ),
    .recv__yum( send_adp__recv__yum[2] ),
    .send__msg( send_adp__send__msg[2] ),
    .send__rdy( send_adp__send__rdy[2] ),
    .send__val( send_adp__send__val[2] )
  );

  CreditRecvRTL2SendRTL__cc254bf95e0e391a send_adp__3
  (
    .clk( send_adp__clk[3] ),
    .reset( send_adp__reset[3] ),
    .recv__en( send_adp__recv__en[3] ),
    .recv__msg( send_adp__recv__msg[3] ),
    .recv__yum( send_adp__recv__yum[3] ),
    .send__msg( send_adp__send__msg[3] ),
    .send__rdy( send_adp__send__rdy[3] ),
    .send__val( send_adp__send__val[3] )
  );

  CreditRecvRTL2SendRTL__cc254bf95e0e391a send_adp__4
  (
    .clk( send_adp__clk[4] ),
    .reset( send_adp__reset[4] ),
    .recv__en( send_adp__recv__en[4] ),
    .recv__msg( send_adp__recv__msg[4] ),
    .recv__yum( send_adp__recv__yum[4] ),
    .send__msg( send_adp__send__msg[4] ),
    .send__rdy( send_adp__send__rdy[4] ),
    .send__val( send_adp__send__val[4] )
  );

  //-------------------------------------------------------------
  // End of component send_adp[0:4]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/ringnet/RingNetworkRTL.py:58
  // @update
  // def up_pos():
  //   for r in range( s.num_routers ):
  //     s.routers[r].pos @= r
  
  always_comb begin : up_pos
    for ( int unsigned r = 1'd0; r < 3'd5; r += 1'd1 )
      routers__pos[3'(r)] = 3'(r);
  end

  assign routers__clk[0] = clk;
  assign routers__reset[0] = reset;
  assign routers__clk[1] = clk;
  assign routers__reset[1] = reset;
  assign routers__clk[2] = clk;
  assign routers__reset[2] = reset;
  assign routers__clk[3] = clk;
  assign routers__reset[3] = reset;
  assign routers__clk[4] = clk;
  assign routers__reset[4] = reset;
  assign recv_adp__clk[0] = clk;
  assign recv_adp__reset[0] = reset;
  assign recv_adp__clk[1] = clk;
  assign recv_adp__reset[1] = reset;
  assign recv_adp__clk[2] = clk;
  assign recv_adp__reset[2] = reset;
  assign recv_adp__clk[3] = clk;
  assign recv_adp__reset[3] = reset;
  assign recv_adp__clk[4] = clk;
  assign recv_adp__reset[4] = reset;
  assign send_adp__clk[0] = clk;
  assign send_adp__reset[0] = reset;
  assign send_adp__clk[1] = clk;
  assign send_adp__reset[1] = reset;
  assign send_adp__clk[2] = clk;
  assign send_adp__reset[2] = reset;
  assign send_adp__clk[3] = clk;
  assign send_adp__reset[3] = reset;
  assign send_adp__clk[4] = clk;
  assign send_adp__reset[4] = reset;
  assign routers__recv__en[1][0] = routers__send__en[0][1];
  assign routers__recv__msg[1][0] = routers__send__msg[0][1];
  assign routers__send__yum[0][1][0] = routers__recv__yum[1][0][0];
  assign routers__send__yum[0][1][1] = routers__recv__yum[1][0][1];
  assign routers__recv__en[0][1] = routers__send__en[1][0];
  assign routers__recv__msg[0][1] = routers__send__msg[1][0];
  assign routers__send__yum[1][0][0] = routers__recv__yum[0][1][0];
  assign routers__send__yum[1][0][1] = routers__recv__yum[0][1][1];
  assign recv_adp__recv__msg[0] = recv__msg[0];
  assign recv__rdy[0] = recv_adp__recv__rdy[0];
  assign recv_adp__recv__val[0] = recv__val[0];
  assign routers__recv__en[0][2] = recv_adp__send__en[0];
  assign routers__recv__msg[0][2] = recv_adp__send__msg[0];
  assign recv_adp__send__yum[0][0] = routers__recv__yum[0][2][0];
  assign recv_adp__send__yum[0][1] = routers__recv__yum[0][2][1];
  assign send_adp__recv__en[0] = routers__send__en[0][2];
  assign send_adp__recv__msg[0] = routers__send__msg[0][2];
  assign routers__send__yum[0][2][0] = send_adp__recv__yum[0][0];
  assign routers__send__yum[0][2][1] = send_adp__recv__yum[0][1];
  assign send__msg[0] = send_adp__send__msg[0];
  assign send_adp__send__rdy[0] = send__rdy[0];
  assign send__val[0] = send_adp__send__val[0];
  assign routers__recv__en[2][0] = routers__send__en[1][1];
  assign routers__recv__msg[2][0] = routers__send__msg[1][1];
  assign routers__send__yum[1][1][0] = routers__recv__yum[2][0][0];
  assign routers__send__yum[1][1][1] = routers__recv__yum[2][0][1];
  assign routers__recv__en[1][1] = routers__send__en[2][0];
  assign routers__recv__msg[1][1] = routers__send__msg[2][0];
  assign routers__send__yum[2][0][0] = routers__recv__yum[1][1][0];
  assign routers__send__yum[2][0][1] = routers__recv__yum[1][1][1];
  assign recv_adp__recv__msg[1] = recv__msg[1];
  assign recv__rdy[1] = recv_adp__recv__rdy[1];
  assign recv_adp__recv__val[1] = recv__val[1];
  assign routers__recv__en[1][2] = recv_adp__send__en[1];
  assign routers__recv__msg[1][2] = recv_adp__send__msg[1];
  assign recv_adp__send__yum[1][0] = routers__recv__yum[1][2][0];
  assign recv_adp__send__yum[1][1] = routers__recv__yum[1][2][1];
  assign send_adp__recv__en[1] = routers__send__en[1][2];
  assign send_adp__recv__msg[1] = routers__send__msg[1][2];
  assign routers__send__yum[1][2][0] = send_adp__recv__yum[1][0];
  assign routers__send__yum[1][2][1] = send_adp__recv__yum[1][1];
  assign send__msg[1] = send_adp__send__msg[1];
  assign send_adp__send__rdy[1] = send__rdy[1];
  assign send__val[1] = send_adp__send__val[1];
  assign routers__recv__en[3][0] = routers__send__en[2][1];
  assign routers__recv__msg[3][0] = routers__send__msg[2][1];
  assign routers__send__yum[2][1][0] = routers__recv__yum[3][0][0];
  assign routers__send__yum[2][1][1] = routers__recv__yum[3][0][1];
  assign routers__recv__en[2][1] = routers__send__en[3][0];
  assign routers__recv__msg[2][1] = routers__send__msg[3][0];
  assign routers__send__yum[3][0][0] = routers__recv__yum[2][1][0];
  assign routers__send__yum[3][0][1] = routers__recv__yum[2][1][1];
  assign recv_adp__recv__msg[2] = recv__msg[2];
  assign recv__rdy[2] = recv_adp__recv__rdy[2];
  assign recv_adp__recv__val[2] = recv__val[2];
  assign routers__recv__en[2][2] = recv_adp__send__en[2];
  assign routers__recv__msg[2][2] = recv_adp__send__msg[2];
  assign recv_adp__send__yum[2][0] = routers__recv__yum[2][2][0];
  assign recv_adp__send__yum[2][1] = routers__recv__yum[2][2][1];
  assign send_adp__recv__en[2] = routers__send__en[2][2];
  assign send_adp__recv__msg[2] = routers__send__msg[2][2];
  assign routers__send__yum[2][2][0] = send_adp__recv__yum[2][0];
  assign routers__send__yum[2][2][1] = send_adp__recv__yum[2][1];
  assign send__msg[2] = send_adp__send__msg[2];
  assign send_adp__send__rdy[2] = send__rdy[2];
  assign send__val[2] = send_adp__send__val[2];
  assign routers__recv__en[4][0] = routers__send__en[3][1];
  assign routers__recv__msg[4][0] = routers__send__msg[3][1];
  assign routers__send__yum[3][1][0] = routers__recv__yum[4][0][0];
  assign routers__send__yum[3][1][1] = routers__recv__yum[4][0][1];
  assign routers__recv__en[3][1] = routers__send__en[4][0];
  assign routers__recv__msg[3][1] = routers__send__msg[4][0];
  assign routers__send__yum[4][0][0] = routers__recv__yum[3][1][0];
  assign routers__send__yum[4][0][1] = routers__recv__yum[3][1][1];
  assign recv_adp__recv__msg[3] = recv__msg[3];
  assign recv__rdy[3] = recv_adp__recv__rdy[3];
  assign recv_adp__recv__val[3] = recv__val[3];
  assign routers__recv__en[3][2] = recv_adp__send__en[3];
  assign routers__recv__msg[3][2] = recv_adp__send__msg[3];
  assign recv_adp__send__yum[3][0] = routers__recv__yum[3][2][0];
  assign recv_adp__send__yum[3][1] = routers__recv__yum[3][2][1];
  assign send_adp__recv__en[3] = routers__send__en[3][2];
  assign send_adp__recv__msg[3] = routers__send__msg[3][2];
  assign routers__send__yum[3][2][0] = send_adp__recv__yum[3][0];
  assign routers__send__yum[3][2][1] = send_adp__recv__yum[3][1];
  assign send__msg[3] = send_adp__send__msg[3];
  assign send_adp__send__rdy[3] = send__rdy[3];
  assign send__val[3] = send_adp__send__val[3];
  assign routers__recv__en[0][0] = routers__send__en[4][1];
  assign routers__recv__msg[0][0] = routers__send__msg[4][1];
  assign routers__send__yum[4][1][0] = routers__recv__yum[0][0][0];
  assign routers__send__yum[4][1][1] = routers__recv__yum[0][0][1];
  assign routers__recv__en[4][1] = routers__send__en[0][0];
  assign routers__recv__msg[4][1] = routers__send__msg[0][0];
  assign routers__send__yum[0][0][0] = routers__recv__yum[4][1][0];
  assign routers__send__yum[0][0][1] = routers__recv__yum[4][1][1];
  assign recv_adp__recv__msg[4] = recv__msg[4];
  assign recv__rdy[4] = recv_adp__recv__rdy[4];
  assign recv_adp__recv__val[4] = recv__val[4];
  assign routers__recv__en[4][2] = recv_adp__send__en[4];
  assign routers__recv__msg[4][2] = recv_adp__send__msg[4];
  assign recv_adp__send__yum[4][0] = routers__recv__yum[4][2][0];
  assign recv_adp__send__yum[4][1] = routers__recv__yum[4][2][1];
  assign send_adp__recv__en[4] = routers__send__en[4][2];
  assign send_adp__recv__msg[4] = routers__send__msg[4][2];
  assign routers__send__yum[4][2][0] = send_adp__recv__yum[4][0];
  assign routers__send__yum[4][2][1] = send_adp__recv__yum[4][1];
  assign send__msg[4] = send_adp__send__msg[4];
  assign send_adp__send__rdy[4] = send__rdy[4];
  assign send__val[4] = send_adp__send__val[4];

endmodule


// PyMTL Component Mux Definition
// Full name: Mux__Type_TileSramXbarPacket_4_3_288__c14254250acb3a03__ninputs_2
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py

module Mux__7c8b747d82bfe31b
(
  input  logic [0:0] clk ,
  input  TileSramXbarPacket_4_3_288__c14254250acb3a03 in_ [0:1],
  output TileSramXbarPacket_4_3_288__c14254250acb3a03 out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_TileSramXbarPacket_4_3_288__c14254250acb3a03__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py

module RegisterFile__b93a4fbd9d50c4ef
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output TileSramXbarPacket_4_3_288__c14254250acb3a03 rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  TileSramXbarPacket_4_3_288__c14254250acb3a03 wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  TileSramXbarPacket_4_3_288__c14254250acb3a03 regs [0:1];

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component BypassQueueDpathRTL Definition
// Full name: BypassQueueDpathRTL__EntryType_TileSramXbarPacket_4_3_288__c14254250acb3a03__num_entries_2
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py

module BypassQueueDpathRTL__d7b088666f28cada
(
  input  logic [0:0] clk ,
  input  logic [0:0] mux_sel ,
  input  logic [0:0] raddr ,
  input  TileSramXbarPacket_4_3_288__c14254250acb3a03 recv_msg ,
  input  logic [0:0] reset ,
  output TileSramXbarPacket_4_3_288__c14254250acb3a03 send_msg ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component mux
  //-------------------------------------------------------------

  logic [0:0] mux__clk;
  TileSramXbarPacket_4_3_288__c14254250acb3a03 mux__in_ [0:1];
  TileSramXbarPacket_4_3_288__c14254250acb3a03 mux__out;
  logic [0:0] mux__reset;
  logic [0:0] mux__sel;

  Mux__7c8b747d82bfe31b mux
  (
    .clk( mux__clk ),
    .in_( mux__in_ ),
    .out( mux__out ),
    .reset( mux__reset ),
    .sel( mux__sel )
  );

  //-------------------------------------------------------------
  // End of component mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component rf
  //-------------------------------------------------------------

  logic [0:0] rf__clk;
  logic [0:0] rf__raddr [0:0];
  TileSramXbarPacket_4_3_288__c14254250acb3a03 rf__rdata [0:0];
  logic [0:0] rf__reset;
  logic [0:0] rf__waddr [0:0];
  TileSramXbarPacket_4_3_288__c14254250acb3a03 rf__wdata [0:0];
  logic [0:0] rf__wen [0:0];

  RegisterFile__b93a4fbd9d50c4ef rf
  (
    .clk( rf__clk ),
    .raddr( rf__raddr ),
    .rdata( rf__rdata ),
    .reset( rf__reset ),
    .waddr( rf__waddr ),
    .wdata( rf__wdata ),
    .wen( rf__wen )
  );

  //-------------------------------------------------------------
  // End of component rf
  //-------------------------------------------------------------

  assign rf__clk = clk;
  assign rf__reset = reset;
  assign rf__raddr[0] = raddr;
  assign rf__wen[0] = wen;
  assign rf__waddr[0] = waddr;
  assign rf__wdata[0] = recv_msg;
  assign mux__clk = clk;
  assign mux__reset = reset;
  assign mux__sel = mux_sel;
  assign mux__in_[0] = rf__rdata[0];
  assign mux__in_[1] = recv_msg;
  assign send_msg = mux__out;

endmodule


// PyMTL Component BypassQueueRTL Definition
// Full name: BypassQueueRTL__EntryType_TileSramXbarPacket_4_3_288__c14254250acb3a03__num_entries_2
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py

module BypassQueueRTL__d7b088666f28cada
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input TileSramXbarPacket_4_3_288__c14254250acb3a03 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output TileSramXbarPacket_4_3_288__c14254250acb3a03 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__mux_sel;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__recv_rdy;
  logic [0:0] ctrl__recv_val;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__send_rdy;
  logic [0:0] ctrl__send_val;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  BypassQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .mux_sel( ctrl__mux_sel ),
    .raddr( ctrl__raddr ),
    .recv_rdy( ctrl__recv_rdy ),
    .recv_val( ctrl__recv_val ),
    .reset( ctrl__reset ),
    .send_rdy( ctrl__send_rdy ),
    .send_val( ctrl__send_val ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  logic [0:0] dpath__mux_sel;
  logic [0:0] dpath__raddr;
  TileSramXbarPacket_4_3_288__c14254250acb3a03 dpath__recv_msg;
  logic [0:0] dpath__reset;
  TileSramXbarPacket_4_3_288__c14254250acb3a03 dpath__send_msg;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  BypassQueueDpathRTL__d7b088666f28cada dpath
  (
    .clk( dpath__clk ),
    .mux_sel( dpath__mux_sel ),
    .raddr( dpath__raddr ),
    .recv_msg( dpath__recv_msg ),
    .reset( dpath__reset ),
    .send_msg( dpath__send_msg ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign dpath__mux_sel = ctrl__mux_sel;
  assign ctrl__recv_val = recv__val;
  assign recv__rdy = ctrl__recv_rdy;
  assign send__val = ctrl__send_val;
  assign ctrl__send_rdy = send__rdy;
  assign count = ctrl__count;
  assign dpath__recv_msg = recv__msg;
  assign send__msg = dpath__send_msg;

endmodule


// PyMTL Component InputUnitRTL Definition
// Full name: InputUnitRTL__PacketType_TileSramXbarPacket_4_3_288__c14254250acb3a03__QueueType_BypassQueueRTL
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/InputUnitRTL.py

module InputUnitRTL__550e8522a09b3984
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input TileSramXbarPacket_4_3_288__c14254250acb3a03 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output TileSramXbarPacket_4_3_288__c14254250acb3a03 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [1:0] queue__count;
  logic [0:0] queue__reset;
  TileSramXbarPacket_4_3_288__c14254250acb3a03 queue__recv__msg;
  logic [0:0] queue__recv__rdy;
  logic [0:0] queue__recv__val;
  TileSramXbarPacket_4_3_288__c14254250acb3a03 queue__send__msg;
  logic [0:0] queue__send__rdy;
  logic [0:0] queue__send__val;

  BypassQueueRTL__d7b088666f28cada queue
  (
    .clk( queue__clk ),
    .count( queue__count ),
    .reset( queue__reset ),
    .recv__msg( queue__recv__msg ),
    .recv__rdy( queue__recv__rdy ),
    .recv__val( queue__recv__val ),
    .send__msg( queue__send__msg ),
    .send__rdy( queue__send__rdy ),
    .send__val( queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__recv__msg = recv__msg;
  assign recv__rdy = queue__recv__rdy;
  assign queue__recv__val = recv__val;
  assign send__msg = queue__send__msg;
  assign queue__send__rdy = send__rdy;
  assign send__val = queue__send__val;

endmodule


// PyMTL Component OutputUnitRTL Definition
// Full name: OutputUnitRTL__PacketType_TileSramXbarPacket_4_3_288__c14254250acb3a03__QueueType_None
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/OutputUnitRTL.py

module OutputUnitRTL__8ef2f6019de4e02b
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input TileSramXbarPacket_4_3_288__c14254250acb3a03 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output TileSramXbarPacket_4_3_288__c14254250acb3a03 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);

  assign send__msg = recv__msg;
  assign recv__rdy = send__rdy;
  assign send__val = recv__val;

endmodule


// PyMTL Component XbarRouteUnitRTL Definition
// Full name: XbarRouteUnitRTL__PacketType_TileSramXbarPacket_4_3_288__c14254250acb3a03__num_outports_3
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/xbar/XbarRouteUnitRTL.py

module XbarRouteUnitRTL__b3574c93ca92022a
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input TileSramXbarPacket_4_3_288__c14254250acb3a03 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output TileSramXbarPacket_4_3_288__c14254250acb3a03 send__msg [0:2] ,
  input logic [0:0] send__rdy [0:2] ,
  output logic [0:0] send__val [0:2] 
);
  localparam logic [1:0] __const__num_outports_at_up_ru_routing  = 2'd3;
  logic [1:0] out_dir;
  logic [2:0] send_val;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/xbar/XbarRouteUnitRTL.py:51
  // @update
  // def up_ru_recv_rdy():
  //   s.recv.rdy @= s.send[ s.out_dir ].rdy > 0
  
  always_comb begin : up_ru_recv_rdy
    recv__rdy = send__rdy[out_dir] > 1'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/xbar/XbarRouteUnitRTL.py:41
  // @update
  // def up_ru_routing():
  //   s.out_dir @= trunc( s.recv.msg.dst, dir_nbits )
  // 
  //   for i in range( num_outports ):
  //     s.send[i].val @= b1(0)
  // 
  //   if s.recv.val:
  //     s.send[ s.out_dir ].val @= b1(1)
  
  always_comb begin : up_ru_routing
    out_dir = recv__msg.dst;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_up_ru_routing ); i += 1'd1 )
      send__val[2'(i)] = 1'd0;
    if ( recv__val ) begin
      send__val[out_dir] = 1'd1;
    end
  end

  assign send__msg[0] = recv__msg;
  assign send_val[0:0] = send__val[0];
  assign send__msg[1] = recv__msg;
  assign send_val[1:1] = send__val[1];
  assign send__msg[2] = recv__msg;
  assign send_val[2:2] = send__val[2];

endmodule


// PyMTL Component RegEnRst Definition
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/registers.py

module RegEnRst__Type_Bits4__reset_value_1
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [3:0] in_ ,
  output logic [3:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd1;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 4'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RoundRobinArbiterEn Definition
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py

module RoundRobinArbiterEn__nreqs_4
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  output logic [3:0] grants ,
  input  logic [3:0] reqs ,
  input  logic [0:0] reset 
);
  localparam logic [2:0] __const__nreqs_at_comb_reqs_int  = 3'd4;
  localparam logic [3:0] __const__nreqsX2_at_comb_reqs_int  = 4'd8;
  localparam logic [2:0] __const__nreqs_at_comb_grants  = 3'd4;
  localparam logic [2:0] __const__nreqs_at_comb_priority_int  = 3'd4;
  localparam logic [3:0] __const__nreqsX2_at_comb_priority_int  = 4'd8;
  localparam logic [3:0] __const__nreqsX2_at_comb_kills  = 4'd8;
  localparam logic [3:0] __const__nreqsX2_at_comb_grants_int  = 4'd8;
  logic [7:0] grants_int;
  logic [8:0] kills;
  logic [0:0] priority_en;
  logic [7:0] priority_int;
  logic [7:0] reqs_int;
  //-------------------------------------------------------------
  // Component priority_reg
  //-------------------------------------------------------------

  logic [0:0] priority_reg__clk;
  logic [0:0] priority_reg__en;
  logic [3:0] priority_reg__in_;
  logic [3:0] priority_reg__out;
  logic [0:0] priority_reg__reset;

  RegEnRst__Type_Bits4__reset_value_1 priority_reg
  (
    .clk( priority_reg__clk ),
    .en( priority_reg__en ),
    .in_( priority_reg__in_ ),
    .out( priority_reg__out ),
    .reset( priority_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component priority_reg
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:118
  // @update
  // def comb_grants():
  //   for i in range( nreqs ):
  //     s.grants[i] @= s.grants_int[i] | s.grants_int[nreqs+i]
  
  always_comb begin : comb_grants
    for ( int unsigned i = 1'd0; i < 3'( __const__nreqs_at_comb_grants ); i += 1'd1 )
      grants[2'(i)] = grants_int[3'(i)] | grants_int[3'( __const__nreqs_at_comb_grants ) + 3'(i)];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:141
  // @update
  // def comb_grants_int():
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.grants_int[i] @= s.reqs_int[i]
  //     else:
  //       s.grants_int[i] @= ~s.kills[i] & s.reqs_int[i]
  
  always_comb begin : comb_grants_int
    for ( int unsigned i = 1'd0; i < 4'( __const__nreqsX2_at_comb_grants_int ); i += 1'd1 )
      if ( priority_int[3'(i)] ) begin
        grants_int[3'(i)] = reqs_int[3'(i)];
      end
      else
        grants_int[3'(i)] = ( ~kills[4'(i)] ) & reqs_int[3'(i)];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:132
  // @update
  // def comb_kills():
  //   s.kills[0] @= 1
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.kills[i+1] @= s.reqs_int[i]
  //     else:
  //       s.kills[i+1] @= s.kills[i] | ( ~s.kills[i] & s.reqs_int[i] )
  
  always_comb begin : comb_kills
    kills[4'd0] = 1'd1;
    for ( int unsigned i = 1'd0; i < 4'( __const__nreqsX2_at_comb_kills ); i += 1'd1 )
      if ( priority_int[3'(i)] ) begin
        kills[4'(i) + 4'd1] = reqs_int[3'(i)];
      end
      else
        kills[4'(i) + 4'd1] = kills[4'(i)] | ( ( ~kills[4'(i)] ) & reqs_int[3'(i)] );
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:123
  // @update
  // def comb_priority_en():
  //   s.priority_en @= ( s.grants != 0 ) & s.en
  
  always_comb begin : comb_priority_en
    priority_en = ( grants != 4'd0 ) & en;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:127
  // @update
  // def comb_priority_int():
  //   s.priority_int[    0:nreqs  ] @= s.priority_reg.out
  //   s.priority_int[nreqs:nreqsX2] @= 0
  
  always_comb begin : comb_priority_int
    priority_int[3'd3:3'd0] = priority_reg__out;
    priority_int[3'd7:3'( __const__nreqs_at_comb_priority_int )] = 4'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arbiters.py:113
  // @update
  // def comb_reqs_int():
  //   s.reqs_int [    0:nreqs  ] @= s.reqs
  //   s.reqs_int [nreqs:nreqsX2] @= s.reqs
  
  always_comb begin : comb_reqs_int
    reqs_int[3'd3:3'd0] = reqs;
    reqs_int[3'd7:3'( __const__nreqs_at_comb_reqs_int )] = reqs;
  end

  assign priority_reg__clk = clk;
  assign priority_reg__reset = reset;
  assign priority_reg__en = priority_en;
  assign priority_reg__in_[3:1] = grants[2:0];
  assign priority_reg__in_[0:0] = grants[3:3];

endmodule


// PyMTL Component Encoder Definition
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/encoders.py

module Encoder__in_nbits_4__out_nbits_2
(
  input  logic [0:0] clk ,
  input  logic [3:0] in_ ,
  output logic [1:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/encoders.py:28
  // @update
  // def encode():
  //   s.out @= 0
  //   for i in range( s.in_nbits ):
  //     if s.in_[i]:
  //       s.out @= i
  
  always_comb begin : encode
    out = 2'd0;
    for ( int unsigned i = 1'd0; i < 3'd4; i += 1'd1 )
      if ( in_[2'(i)] ) begin
        out = 2'(i);
      end
  end

endmodule


// PyMTL Component Mux Definition
// Full name: Mux__Type_TileSramXbarPacket_4_3_288__c14254250acb3a03__ninputs_4
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py

module Mux__67d608921b6e44c3
(
  input  logic [0:0] clk ,
  input  TileSramXbarPacket_4_3_288__c14254250acb3a03 in_ [0:3],
  output TileSramXbarPacket_4_3_288__c14254250acb3a03 out ,
  input  logic [0:0] reset ,
  input  logic [1:0] sel 
);

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component SwitchUnitRTL Definition
// Full name: SwitchUnitRTL__PacketType_TileSramXbarPacket_4_3_288__c14254250acb3a03__num_inports_4
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py

module SwitchUnitRTL__7f5084d0de79158b
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input TileSramXbarPacket_4_3_288__c14254250acb3a03 recv__msg [0:3] ,
  output logic [0:0] recv__rdy [0:3] ,
  input logic [0:0] recv__val [0:3] ,
  output TileSramXbarPacket_4_3_288__c14254250acb3a03 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  localparam logic [2:0] __const__num_inports_at_up_get_en  = 3'd4;
  //-------------------------------------------------------------
  // Component arbiter
  //-------------------------------------------------------------

  logic [0:0] arbiter__clk;
  logic [0:0] arbiter__en;
  logic [3:0] arbiter__grants;
  logic [3:0] arbiter__reqs;
  logic [0:0] arbiter__reset;

  RoundRobinArbiterEn__nreqs_4 arbiter
  (
    .clk( arbiter__clk ),
    .en( arbiter__en ),
    .grants( arbiter__grants ),
    .reqs( arbiter__reqs ),
    .reset( arbiter__reset )
  );

  //-------------------------------------------------------------
  // End of component arbiter
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component encoder
  //-------------------------------------------------------------

  logic [0:0] encoder__clk;
  logic [3:0] encoder__in_;
  logic [1:0] encoder__out;
  logic [0:0] encoder__reset;

  Encoder__in_nbits_4__out_nbits_2 encoder
  (
    .clk( encoder__clk ),
    .in_( encoder__in_ ),
    .out( encoder__out ),
    .reset( encoder__reset )
  );

  //-------------------------------------------------------------
  // End of component encoder
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mux
  //-------------------------------------------------------------

  logic [0:0] mux__clk;
  TileSramXbarPacket_4_3_288__c14254250acb3a03 mux__in_ [0:3];
  TileSramXbarPacket_4_3_288__c14254250acb3a03 mux__out;
  logic [0:0] mux__reset;
  logic [1:0] mux__sel;

  Mux__67d608921b6e44c3 mux
  (
    .clk( mux__clk ),
    .in_( mux__in_ ),
    .out( mux__out ),
    .reset( mux__reset ),
    .sel( mux__sel )
  );

  //-------------------------------------------------------------
  // End of component mux
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py:56
  // @update
  // def up_get_en():
  //   for i in range( num_inports ):
  //     s.recv[i].rdy @= s.send.rdy & ( s.mux.sel == i )
  
  always_comb begin : up_get_en
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_up_get_en ); i += 1'd1 )
      recv__rdy[2'(i)] = send__rdy & ( mux__sel == 2'(i) );
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py:51
  // @update
  // def up_send_val():
  //   s.send.val @= s.arbiter.grants > 0
  
  always_comb begin : up_send_val
    send__val = arbiter__grants > 4'd0;
  end

  assign arbiter__clk = clk;
  assign arbiter__reset = reset;
  assign arbiter__en = 1'd1;
  assign mux__clk = clk;
  assign mux__reset = reset;
  assign send__msg = mux__out;
  assign encoder__clk = clk;
  assign encoder__reset = reset;
  assign encoder__in_ = arbiter__grants;
  assign mux__sel = encoder__out;
  assign arbiter__reqs[0:0] = recv__val[0];
  assign mux__in_[0] = recv__msg[0];
  assign arbiter__reqs[1:1] = recv__val[1];
  assign mux__in_[1] = recv__msg[1];
  assign arbiter__reqs[2:2] = recv__val[2];
  assign mux__in_[2] = recv__msg[2];
  assign arbiter__reqs[3:3] = recv__val[3];
  assign mux__in_[3] = recv__msg[3];

endmodule


// PyMTL Component XbarBypassQueueRTL Definition
// Full name: XbarBypassQueueRTL__PacketType_TileSramXbarPacket_4_3_288__c14254250acb3a03__num_inports_4__num_outports_3__InputUnitType_InputUnitRTL__RouteUnitType_XbarRouteUnitRTL__SwitchUnitType_SwitchUnitRTL__OutputUnitType_OutputUnitRTL
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/xbar/XbarBypassQueueRTL.py

module XbarBypassQueueRTL__7b5fa573f9efe6f9
(
  input  logic [0:0] clk ,
  output TileSramXbarPacket_4_3_288__c14254250acb3a03 packet_on_input_units [0:3],
  input  logic [0:0] reset ,
  input TileSramXbarPacket_4_3_288__c14254250acb3a03 recv__msg [0:3] ,
  output logic [0:0] recv__rdy [0:3] ,
  input logic [0:0] recv__val [0:3] ,
  output TileSramXbarPacket_4_3_288__c14254250acb3a03 send__msg [0:2] ,
  input logic [0:0] send__rdy [0:2] ,
  output logic [0:0] send__val [0:2] 
);
  //-------------------------------------------------------------
  // Component input_units[0:3]
  //-------------------------------------------------------------

  logic [0:0] input_units__clk [0:3];
  logic [0:0] input_units__reset [0:3];
  TileSramXbarPacket_4_3_288__c14254250acb3a03 input_units__recv__msg [0:3];
  logic [0:0] input_units__recv__rdy [0:3];
  logic [0:0] input_units__recv__val [0:3];
  TileSramXbarPacket_4_3_288__c14254250acb3a03 input_units__send__msg [0:3];
  logic [0:0] input_units__send__rdy [0:3];
  logic [0:0] input_units__send__val [0:3];

  InputUnitRTL__550e8522a09b3984 input_units__0
  (
    .clk( input_units__clk[0] ),
    .reset( input_units__reset[0] ),
    .recv__msg( input_units__recv__msg[0] ),
    .recv__rdy( input_units__recv__rdy[0] ),
    .recv__val( input_units__recv__val[0] ),
    .send__msg( input_units__send__msg[0] ),
    .send__rdy( input_units__send__rdy[0] ),
    .send__val( input_units__send__val[0] )
  );

  InputUnitRTL__550e8522a09b3984 input_units__1
  (
    .clk( input_units__clk[1] ),
    .reset( input_units__reset[1] ),
    .recv__msg( input_units__recv__msg[1] ),
    .recv__rdy( input_units__recv__rdy[1] ),
    .recv__val( input_units__recv__val[1] ),
    .send__msg( input_units__send__msg[1] ),
    .send__rdy( input_units__send__rdy[1] ),
    .send__val( input_units__send__val[1] )
  );

  InputUnitRTL__550e8522a09b3984 input_units__2
  (
    .clk( input_units__clk[2] ),
    .reset( input_units__reset[2] ),
    .recv__msg( input_units__recv__msg[2] ),
    .recv__rdy( input_units__recv__rdy[2] ),
    .recv__val( input_units__recv__val[2] ),
    .send__msg( input_units__send__msg[2] ),
    .send__rdy( input_units__send__rdy[2] ),
    .send__val( input_units__send__val[2] )
  );

  InputUnitRTL__550e8522a09b3984 input_units__3
  (
    .clk( input_units__clk[3] ),
    .reset( input_units__reset[3] ),
    .recv__msg( input_units__recv__msg[3] ),
    .recv__rdy( input_units__recv__rdy[3] ),
    .recv__val( input_units__recv__val[3] ),
    .send__msg( input_units__send__msg[3] ),
    .send__rdy( input_units__send__rdy[3] ),
    .send__val( input_units__send__val[3] )
  );

  //-------------------------------------------------------------
  // End of component input_units[0:3]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component output_units[0:2]
  //-------------------------------------------------------------

  logic [0:0] output_units__clk [0:2];
  logic [0:0] output_units__reset [0:2];
  TileSramXbarPacket_4_3_288__c14254250acb3a03 output_units__recv__msg [0:2];
  logic [0:0] output_units__recv__rdy [0:2];
  logic [0:0] output_units__recv__val [0:2];
  TileSramXbarPacket_4_3_288__c14254250acb3a03 output_units__send__msg [0:2];
  logic [0:0] output_units__send__rdy [0:2];
  logic [0:0] output_units__send__val [0:2];

  OutputUnitRTL__8ef2f6019de4e02b output_units__0
  (
    .clk( output_units__clk[0] ),
    .reset( output_units__reset[0] ),
    .recv__msg( output_units__recv__msg[0] ),
    .recv__rdy( output_units__recv__rdy[0] ),
    .recv__val( output_units__recv__val[0] ),
    .send__msg( output_units__send__msg[0] ),
    .send__rdy( output_units__send__rdy[0] ),
    .send__val( output_units__send__val[0] )
  );

  OutputUnitRTL__8ef2f6019de4e02b output_units__1
  (
    .clk( output_units__clk[1] ),
    .reset( output_units__reset[1] ),
    .recv__msg( output_units__recv__msg[1] ),
    .recv__rdy( output_units__recv__rdy[1] ),
    .recv__val( output_units__recv__val[1] ),
    .send__msg( output_units__send__msg[1] ),
    .send__rdy( output_units__send__rdy[1] ),
    .send__val( output_units__send__val[1] )
  );

  OutputUnitRTL__8ef2f6019de4e02b output_units__2
  (
    .clk( output_units__clk[2] ),
    .reset( output_units__reset[2] ),
    .recv__msg( output_units__recv__msg[2] ),
    .recv__rdy( output_units__recv__rdy[2] ),
    .recv__val( output_units__recv__val[2] ),
    .send__msg( output_units__send__msg[2] ),
    .send__rdy( output_units__send__rdy[2] ),
    .send__val( output_units__send__val[2] )
  );

  //-------------------------------------------------------------
  // End of component output_units[0:2]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component route_units[0:3]
  //-------------------------------------------------------------

  logic [0:0] route_units__clk [0:3];
  logic [0:0] route_units__reset [0:3];
  TileSramXbarPacket_4_3_288__c14254250acb3a03 route_units__recv__msg [0:3];
  logic [0:0] route_units__recv__rdy [0:3];
  logic [0:0] route_units__recv__val [0:3];
  TileSramXbarPacket_4_3_288__c14254250acb3a03 route_units__send__msg [0:3][0:2];
  logic [0:0] route_units__send__rdy [0:3][0:2];
  logic [0:0] route_units__send__val [0:3][0:2];

  XbarRouteUnitRTL__b3574c93ca92022a route_units__0
  (
    .clk( route_units__clk[0] ),
    .reset( route_units__reset[0] ),
    .recv__msg( route_units__recv__msg[0] ),
    .recv__rdy( route_units__recv__rdy[0] ),
    .recv__val( route_units__recv__val[0] ),
    .send__msg( route_units__send__msg[0] ),
    .send__rdy( route_units__send__rdy[0] ),
    .send__val( route_units__send__val[0] )
  );

  XbarRouteUnitRTL__b3574c93ca92022a route_units__1
  (
    .clk( route_units__clk[1] ),
    .reset( route_units__reset[1] ),
    .recv__msg( route_units__recv__msg[1] ),
    .recv__rdy( route_units__recv__rdy[1] ),
    .recv__val( route_units__recv__val[1] ),
    .send__msg( route_units__send__msg[1] ),
    .send__rdy( route_units__send__rdy[1] ),
    .send__val( route_units__send__val[1] )
  );

  XbarRouteUnitRTL__b3574c93ca92022a route_units__2
  (
    .clk( route_units__clk[2] ),
    .reset( route_units__reset[2] ),
    .recv__msg( route_units__recv__msg[2] ),
    .recv__rdy( route_units__recv__rdy[2] ),
    .recv__val( route_units__recv__val[2] ),
    .send__msg( route_units__send__msg[2] ),
    .send__rdy( route_units__send__rdy[2] ),
    .send__val( route_units__send__val[2] )
  );

  XbarRouteUnitRTL__b3574c93ca92022a route_units__3
  (
    .clk( route_units__clk[3] ),
    .reset( route_units__reset[3] ),
    .recv__msg( route_units__recv__msg[3] ),
    .recv__rdy( route_units__recv__rdy[3] ),
    .recv__val( route_units__recv__val[3] ),
    .send__msg( route_units__send__msg[3] ),
    .send__rdy( route_units__send__rdy[3] ),
    .send__val( route_units__send__val[3] )
  );

  //-------------------------------------------------------------
  // End of component route_units[0:3]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component switch_units[0:2]
  //-------------------------------------------------------------

  logic [0:0] switch_units__clk [0:2];
  logic [0:0] switch_units__reset [0:2];
  TileSramXbarPacket_4_3_288__c14254250acb3a03 switch_units__recv__msg [0:2][0:3];
  logic [0:0] switch_units__recv__rdy [0:2][0:3];
  logic [0:0] switch_units__recv__val [0:2][0:3];
  TileSramXbarPacket_4_3_288__c14254250acb3a03 switch_units__send__msg [0:2];
  logic [0:0] switch_units__send__rdy [0:2];
  logic [0:0] switch_units__send__val [0:2];

  SwitchUnitRTL__7f5084d0de79158b switch_units__0
  (
    .clk( switch_units__clk[0] ),
    .reset( switch_units__reset[0] ),
    .recv__msg( switch_units__recv__msg[0] ),
    .recv__rdy( switch_units__recv__rdy[0] ),
    .recv__val( switch_units__recv__val[0] ),
    .send__msg( switch_units__send__msg[0] ),
    .send__rdy( switch_units__send__rdy[0] ),
    .send__val( switch_units__send__val[0] )
  );

  SwitchUnitRTL__7f5084d0de79158b switch_units__1
  (
    .clk( switch_units__clk[1] ),
    .reset( switch_units__reset[1] ),
    .recv__msg( switch_units__recv__msg[1] ),
    .recv__rdy( switch_units__recv__rdy[1] ),
    .recv__val( switch_units__recv__val[1] ),
    .send__msg( switch_units__send__msg[1] ),
    .send__rdy( switch_units__send__rdy[1] ),
    .send__val( switch_units__send__val[1] )
  );

  SwitchUnitRTL__7f5084d0de79158b switch_units__2
  (
    .clk( switch_units__clk[2] ),
    .reset( switch_units__reset[2] ),
    .recv__msg( switch_units__recv__msg[2] ),
    .recv__rdy( switch_units__recv__rdy[2] ),
    .recv__val( switch_units__recv__val[2] ),
    .send__msg( switch_units__send__msg[2] ),
    .send__rdy( switch_units__send__rdy[2] ),
    .send__val( switch_units__send__val[2] )
  );

  //-------------------------------------------------------------
  // End of component switch_units[0:2]
  //-------------------------------------------------------------

  assign input_units__clk[0] = clk;
  assign input_units__reset[0] = reset;
  assign input_units__clk[1] = clk;
  assign input_units__reset[1] = reset;
  assign input_units__clk[2] = clk;
  assign input_units__reset[2] = reset;
  assign input_units__clk[3] = clk;
  assign input_units__reset[3] = reset;
  assign route_units__clk[0] = clk;
  assign route_units__reset[0] = reset;
  assign route_units__clk[1] = clk;
  assign route_units__reset[1] = reset;
  assign route_units__clk[2] = clk;
  assign route_units__reset[2] = reset;
  assign route_units__clk[3] = clk;
  assign route_units__reset[3] = reset;
  assign switch_units__clk[0] = clk;
  assign switch_units__reset[0] = reset;
  assign switch_units__clk[1] = clk;
  assign switch_units__reset[1] = reset;
  assign switch_units__clk[2] = clk;
  assign switch_units__reset[2] = reset;
  assign output_units__clk[0] = clk;
  assign output_units__reset[0] = reset;
  assign output_units__clk[1] = clk;
  assign output_units__reset[1] = reset;
  assign output_units__clk[2] = clk;
  assign output_units__reset[2] = reset;
  assign packet_on_input_units[0] = input_units__send__msg[0];
  assign packet_on_input_units[1] = input_units__send__msg[1];
  assign packet_on_input_units[2] = input_units__send__msg[2];
  assign packet_on_input_units[3] = input_units__send__msg[3];
  assign input_units__recv__msg[0] = recv__msg[0];
  assign recv__rdy[0] = input_units__recv__rdy[0];
  assign input_units__recv__val[0] = recv__val[0];
  assign route_units__recv__msg[0] = input_units__send__msg[0];
  assign input_units__send__rdy[0] = route_units__recv__rdy[0];
  assign route_units__recv__val[0] = input_units__send__val[0];
  assign input_units__recv__msg[1] = recv__msg[1];
  assign recv__rdy[1] = input_units__recv__rdy[1];
  assign input_units__recv__val[1] = recv__val[1];
  assign route_units__recv__msg[1] = input_units__send__msg[1];
  assign input_units__send__rdy[1] = route_units__recv__rdy[1];
  assign route_units__recv__val[1] = input_units__send__val[1];
  assign input_units__recv__msg[2] = recv__msg[2];
  assign recv__rdy[2] = input_units__recv__rdy[2];
  assign input_units__recv__val[2] = recv__val[2];
  assign route_units__recv__msg[2] = input_units__send__msg[2];
  assign input_units__send__rdy[2] = route_units__recv__rdy[2];
  assign route_units__recv__val[2] = input_units__send__val[2];
  assign input_units__recv__msg[3] = recv__msg[3];
  assign recv__rdy[3] = input_units__recv__rdy[3];
  assign input_units__recv__val[3] = recv__val[3];
  assign route_units__recv__msg[3] = input_units__send__msg[3];
  assign input_units__send__rdy[3] = route_units__recv__rdy[3];
  assign route_units__recv__val[3] = input_units__send__val[3];
  assign switch_units__recv__msg[0][0] = route_units__send__msg[0][0];
  assign route_units__send__rdy[0][0] = switch_units__recv__rdy[0][0];
  assign switch_units__recv__val[0][0] = route_units__send__val[0][0];
  assign switch_units__recv__msg[1][0] = route_units__send__msg[0][1];
  assign route_units__send__rdy[0][1] = switch_units__recv__rdy[1][0];
  assign switch_units__recv__val[1][0] = route_units__send__val[0][1];
  assign switch_units__recv__msg[2][0] = route_units__send__msg[0][2];
  assign route_units__send__rdy[0][2] = switch_units__recv__rdy[2][0];
  assign switch_units__recv__val[2][0] = route_units__send__val[0][2];
  assign switch_units__recv__msg[0][1] = route_units__send__msg[1][0];
  assign route_units__send__rdy[1][0] = switch_units__recv__rdy[0][1];
  assign switch_units__recv__val[0][1] = route_units__send__val[1][0];
  assign switch_units__recv__msg[1][1] = route_units__send__msg[1][1];
  assign route_units__send__rdy[1][1] = switch_units__recv__rdy[1][1];
  assign switch_units__recv__val[1][1] = route_units__send__val[1][1];
  assign switch_units__recv__msg[2][1] = route_units__send__msg[1][2];
  assign route_units__send__rdy[1][2] = switch_units__recv__rdy[2][1];
  assign switch_units__recv__val[2][1] = route_units__send__val[1][2];
  assign switch_units__recv__msg[0][2] = route_units__send__msg[2][0];
  assign route_units__send__rdy[2][0] = switch_units__recv__rdy[0][2];
  assign switch_units__recv__val[0][2] = route_units__send__val[2][0];
  assign switch_units__recv__msg[1][2] = route_units__send__msg[2][1];
  assign route_units__send__rdy[2][1] = switch_units__recv__rdy[1][2];
  assign switch_units__recv__val[1][2] = route_units__send__val[2][1];
  assign switch_units__recv__msg[2][2] = route_units__send__msg[2][2];
  assign route_units__send__rdy[2][2] = switch_units__recv__rdy[2][2];
  assign switch_units__recv__val[2][2] = route_units__send__val[2][2];
  assign switch_units__recv__msg[0][3] = route_units__send__msg[3][0];
  assign route_units__send__rdy[3][0] = switch_units__recv__rdy[0][3];
  assign switch_units__recv__val[0][3] = route_units__send__val[3][0];
  assign switch_units__recv__msg[1][3] = route_units__send__msg[3][1];
  assign route_units__send__rdy[3][1] = switch_units__recv__rdy[1][3];
  assign switch_units__recv__val[1][3] = route_units__send__val[3][1];
  assign switch_units__recv__msg[2][3] = route_units__send__msg[3][2];
  assign route_units__send__rdy[3][2] = switch_units__recv__rdy[2][3];
  assign switch_units__recv__val[2][3] = route_units__send__val[3][2];
  assign output_units__recv__msg[0] = switch_units__send__msg[0];
  assign switch_units__send__rdy[0] = output_units__recv__rdy[0];
  assign output_units__recv__val[0] = switch_units__send__val[0];
  assign send__msg[0] = output_units__send__msg[0];
  assign output_units__send__rdy[0] = send__rdy[0];
  assign send__val[0] = output_units__send__val[0];
  assign output_units__recv__msg[1] = switch_units__send__msg[1];
  assign switch_units__send__rdy[1] = output_units__recv__rdy[1];
  assign output_units__recv__val[1] = switch_units__send__val[1];
  assign send__msg[1] = output_units__send__msg[1];
  assign output_units__send__rdy[1] = send__rdy[1];
  assign send__val[1] = output_units__send__val[1];
  assign output_units__recv__msg[2] = switch_units__send__msg[2];
  assign switch_units__send__rdy[2] = output_units__recv__rdy[2];
  assign output_units__recv__val[2] = switch_units__send__val[2];
  assign send__msg[2] = output_units__send__msg[2];
  assign output_units__send__rdy[2] = send__rdy[2];
  assign send__val[2] = output_units__send__val[2];

endmodule


// PyMTL Component Mux Definition
// Full name: Mux__Type_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__ninputs_2
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py

module Mux__85c058ea4b7b52c4
(
  input  logic [0:0] clk ,
  input  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 in_ [0:1],
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component BypassQueue1EntryRTL Definition
// Full name: BypassQueue1EntryRTL__EntryType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py

module BypassQueue1EntryRTL__6d09b133f21c8770
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 entry;
  logic [0:0] full;
  //-------------------------------------------------------------
  // Component bypass_mux
  //-------------------------------------------------------------

  logic [0:0] bypass_mux__clk;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 bypass_mux__in_ [0:1];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 bypass_mux__out;
  logic [0:0] bypass_mux__reset;
  logic [0:0] bypass_mux__sel;

  Mux__85c058ea4b7b52c4 bypass_mux
  (
    .clk( bypass_mux__clk ),
    .in_( bypass_mux__in_ ),
    .out( bypass_mux__out ),
    .reset( bypass_mux__reset ),
    .sel( bypass_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component bypass_mux
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py:392
  // s.recv.rdy //= lambda: ~s.full
  
  always_comb begin : _lambda__s_dut_cgra_0__data_mem_recv_wdata_bypass_q_0__q_recv_rdy
    recv__rdy = ~full;
  end

  // PyMTL Lambda Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py:391
  // s.send.val //= lambda: s.full | s.recv.val
  
  always_comb begin : _lambda__s_dut_cgra_0__data_mem_recv_wdata_bypass_q_0__q_send_val
    send__val = full | recv__val;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py:394
  // @update_ff
  // def ff_bypass1():
  //   if s.reset:
  //     s.full <<= 0
  //   else:
  //     s.full <<= ~s.send.rdy & (s.full | s.recv.val)
  // 
  //   # buffer the incoming message if we cannot directly send it out
  //   if ~s.send.rdy & ~s.full & s.recv.val:
  //     s.entry <<= s.recv.msg
  
  always_ff @(posedge clk) begin : ff_bypass1
    if ( reset ) begin
      full <= 1'd0;
    end
    else
      full <= ( ~send__rdy ) & ( full | recv__val );
    if ( ( ( ~send__rdy ) & ( ~full ) ) & recv__val ) begin
      entry <= recv__msg;
    end
  end

  assign bypass_mux__clk = clk;
  assign bypass_mux__reset = reset;
  assign bypass_mux__in_[0] = recv__msg;
  assign bypass_mux__in_[1] = entry;
  assign send__msg = bypass_mux__out;
  assign bypass_mux__sel = full;
  assign count = full;

endmodule


// PyMTL Component BypassQueueRTL Definition
// Full name: BypassQueueRTL__EntryType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__num_entries_1
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py

module BypassQueueRTL__7aa446127d3c2270
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component q
  //-------------------------------------------------------------

  logic [0:0] q__clk;
  logic [0:0] q__count;
  logic [0:0] q__reset;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 q__recv__msg;
  logic [0:0] q__recv__rdy;
  logic [0:0] q__recv__val;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 q__send__msg;
  logic [0:0] q__send__rdy;
  logic [0:0] q__send__val;

  BypassQueue1EntryRTL__6d09b133f21c8770 q
  (
    .clk( q__clk ),
    .count( q__count ),
    .reset( q__reset ),
    .recv__msg( q__recv__msg ),
    .recv__rdy( q__recv__rdy ),
    .recv__val( q__recv__val ),
    .send__msg( q__send__msg ),
    .send__rdy( q__send__rdy ),
    .send__val( q__send__val )
  );

  //-------------------------------------------------------------
  // End of component q
  //-------------------------------------------------------------

  assign q__clk = clk;
  assign q__reset = reset;
  assign q__recv__msg = recv__msg;
  assign recv__rdy = q__recv__rdy;
  assign q__recv__val = recv__val;
  assign send__msg = q__send__msg;
  assign q__send__rdy = send__rdy;
  assign send__val = q__send__val;
  assign count = q__count;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__nregs_16__rd_ports_1__wr_ports_1__const_zero_False
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py

module RegisterFile__84f0703fd9bfd535
(
  input  logic [0:0] clk ,
  input  logic [3:0] raddr [0:0],
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [3:0] waddr [0:0],
  input  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 regs [0:15];

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component DataMemWithCrossbarRTL Definition
// Full name: DataMemWithCrossbarRTL__NocPktType_InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d__CgraPayloadType_MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__cc89ed621b71ae36__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__data_mem_size_global_288__data_mem_size_per_bank_16__num_banks_per_cgra_2__num_rd_tiles_3__num_wr_tiles_3__multi_cgra_rows_3__multi_cgra_columns_3__num_tiles_4__idTo2d_map_{0: (0, 0), 1: (1, 0), 2: (2, 0), 3: (0, 1), 4: (1, 1), 5: (2, 1), 6: (0, 2), 7: (1, 2), 8: (2, 2)}__preload_data_per_bank_None
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/data/DataMemWithCrossbarRTL.py

module DataMemWithCrossbarRTL__419c8a366359e511
(
  input  logic [8:0] address_lower ,
  input  logic [8:0] address_upper ,
  input  logic [3:0] cgra_id ,
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv_from_noc_load_request__msg  ,
  output logic [0:0] recv_from_noc_load_request__rdy  ,
  input logic [0:0] recv_from_noc_load_request__val  ,
  input InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv_from_noc_load_response_pkt__msg  ,
  output logic [0:0] recv_from_noc_load_response_pkt__rdy  ,
  input logic [0:0] recv_from_noc_load_response_pkt__val  ,
  input InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv_from_noc_store_request__msg  ,
  output logic [0:0] recv_from_noc_store_request__rdy  ,
  input logic [0:0] recv_from_noc_store_request__val  ,
  input logic [8:0] recv_raddr__msg [0:2] ,
  output logic [0:0] recv_raddr__rdy [0:2] ,
  input logic [0:0] recv_raddr__val [0:2] ,
  input logic [8:0] recv_waddr__msg [0:2] ,
  output logic [0:0] recv_waddr__rdy [0:2] ,
  input logic [0:0] recv_waddr__val [0:2] ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_wdata__msg [0:2] ,
  output logic [0:0] recv_wdata__rdy [0:2] ,
  input logic [0:0] recv_wdata__val [0:2] ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_rdata__msg [0:2] ,
  input logic [0:0] send_rdata__rdy [0:2] ,
  output logic [0:0] send_rdata__val [0:2] ,
  output InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send_to_noc_load_request_pkt__msg  ,
  input logic [0:0] send_to_noc_load_request_pkt__rdy  ,
  output logic [0:0] send_to_noc_load_request_pkt__val  ,
  output InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send_to_noc_load_response_pkt__msg  ,
  input logic [0:0] send_to_noc_load_response_pkt__rdy  ,
  output logic [0:0] send_to_noc_load_response_pkt__val  ,
  output InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send_to_noc_store_pkt__msg  ,
  input logic [0:0] send_to_noc_store_pkt__rdy  ,
  output logic [0:0] send_to_noc_store_pkt__val  
);
  localparam logic [2:0] __const__num_xbar_in_rd_ports_at_assemble_xbar_pkt  = 3'd4;
  localparam logic [2:0] __const__num_xbar_in_wr_ports_at_assemble_xbar_pkt  = 3'd4;
  localparam logic [1:0] __const__num_rd_tiles_at_assemble_xbar_pkt  = 2'd3;
  localparam logic [2:0] __const__per_bank_addr_nbits_at_assemble_xbar_pkt  = 3'd4;
  localparam logic [1:0] __const__num_banks_per_cgra_at_assemble_xbar_pkt  = 2'd2;
  localparam logic [1:0] __const__num_wr_tiles_at_assemble_xbar_pkt  = 2'd3;
  localparam logic [1:0] __const__num_rd_tiles_at_update_all  = 2'd3;
  localparam logic [1:0] __const__num_wr_tiles_at_update_all  = 2'd3;
  localparam logic [2:0] __const__num_xbar_in_rd_ports_at_update_all  = 3'd4;
  localparam logic [2:0] __const__num_xbar_in_wr_ports_at_update_all  = 3'd4;
  localparam logic [1:0] __const__num_xbar_out_wr_ports_at_update_all  = 2'd3;
  localparam logic [1:0] __const__num_xbar_out_rd_ports_at_update_all  = 2'd3;
  localparam logic [1:0] __const__num_banks_per_cgra_at_update_all  = 2'd2;
  localparam logic [4:0] __const__data_mem_size_per_bank_at_update_all  = 5'd16;
  localparam logic [3:0] __const__CMD_LOAD_RESPONSE  = 4'd10;
  localparam logic [3:0] __const__CMD_LOAD_REQUEST  = 4'd9;
  localparam logic [3:0] __const__CMD_STORE_REQUEST  = 4'd11;
  logic [1:0] idTo2d_x_lut [0:8];
  logic [1:0] idTo2d_y_lut [0:8];
  logic [0:0] initWrites [0:1][0:15];
  logic [3:0] init_mem_addr;
  logic [0:0] init_mem_done;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 preload_data_per_bank [0:1][0:0];
  TileSramXbarPacket_4_3_288__c14254250acb3a03 rd_pkt [0:3];
  logic [0:0] send_to_noc_load_pending;
  TileSramXbarPacket_4_3_288__c14254250acb3a03 wr_pkt [0:3];
  //-------------------------------------------------------------
  // Component read_crossbar
  //-------------------------------------------------------------

  logic [0:0] read_crossbar__clk;
  TileSramXbarPacket_4_3_288__c14254250acb3a03 read_crossbar__packet_on_input_units [0:3];
  logic [0:0] read_crossbar__reset;
  TileSramXbarPacket_4_3_288__c14254250acb3a03 read_crossbar__recv__msg [0:3];
  logic [0:0] read_crossbar__recv__rdy [0:3];
  logic [0:0] read_crossbar__recv__val [0:3];
  TileSramXbarPacket_4_3_288__c14254250acb3a03 read_crossbar__send__msg [0:2];
  logic [0:0] read_crossbar__send__rdy [0:2];
  logic [0:0] read_crossbar__send__val [0:2];

  XbarBypassQueueRTL__7b5fa573f9efe6f9 read_crossbar
  (
    .clk( read_crossbar__clk ),
    .packet_on_input_units( read_crossbar__packet_on_input_units ),
    .reset( read_crossbar__reset ),
    .recv__msg( read_crossbar__recv__msg ),
    .recv__rdy( read_crossbar__recv__rdy ),
    .recv__val( read_crossbar__recv__val ),
    .send__msg( read_crossbar__send__msg ),
    .send__rdy( read_crossbar__send__rdy ),
    .send__val( read_crossbar__send__val )
  );

  //-------------------------------------------------------------
  // End of component read_crossbar
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component recv_wdata_bypass_q[0:3]
  //-------------------------------------------------------------

  logic [0:0] recv_wdata_bypass_q__clk [0:3];
  logic [0:0] recv_wdata_bypass_q__count [0:3];
  logic [0:0] recv_wdata_bypass_q__reset [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_wdata_bypass_q__recv__msg [0:3];
  logic [0:0] recv_wdata_bypass_q__recv__rdy [0:3];
  logic [0:0] recv_wdata_bypass_q__recv__val [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_wdata_bypass_q__send__msg [0:3];
  logic [0:0] recv_wdata_bypass_q__send__rdy [0:3];
  logic [0:0] recv_wdata_bypass_q__send__val [0:3];

  BypassQueueRTL__7aa446127d3c2270 recv_wdata_bypass_q__0
  (
    .clk( recv_wdata_bypass_q__clk[0] ),
    .count( recv_wdata_bypass_q__count[0] ),
    .reset( recv_wdata_bypass_q__reset[0] ),
    .recv__msg( recv_wdata_bypass_q__recv__msg[0] ),
    .recv__rdy( recv_wdata_bypass_q__recv__rdy[0] ),
    .recv__val( recv_wdata_bypass_q__recv__val[0] ),
    .send__msg( recv_wdata_bypass_q__send__msg[0] ),
    .send__rdy( recv_wdata_bypass_q__send__rdy[0] ),
    .send__val( recv_wdata_bypass_q__send__val[0] )
  );

  BypassQueueRTL__7aa446127d3c2270 recv_wdata_bypass_q__1
  (
    .clk( recv_wdata_bypass_q__clk[1] ),
    .count( recv_wdata_bypass_q__count[1] ),
    .reset( recv_wdata_bypass_q__reset[1] ),
    .recv__msg( recv_wdata_bypass_q__recv__msg[1] ),
    .recv__rdy( recv_wdata_bypass_q__recv__rdy[1] ),
    .recv__val( recv_wdata_bypass_q__recv__val[1] ),
    .send__msg( recv_wdata_bypass_q__send__msg[1] ),
    .send__rdy( recv_wdata_bypass_q__send__rdy[1] ),
    .send__val( recv_wdata_bypass_q__send__val[1] )
  );

  BypassQueueRTL__7aa446127d3c2270 recv_wdata_bypass_q__2
  (
    .clk( recv_wdata_bypass_q__clk[2] ),
    .count( recv_wdata_bypass_q__count[2] ),
    .reset( recv_wdata_bypass_q__reset[2] ),
    .recv__msg( recv_wdata_bypass_q__recv__msg[2] ),
    .recv__rdy( recv_wdata_bypass_q__recv__rdy[2] ),
    .recv__val( recv_wdata_bypass_q__recv__val[2] ),
    .send__msg( recv_wdata_bypass_q__send__msg[2] ),
    .send__rdy( recv_wdata_bypass_q__send__rdy[2] ),
    .send__val( recv_wdata_bypass_q__send__val[2] )
  );

  BypassQueueRTL__7aa446127d3c2270 recv_wdata_bypass_q__3
  (
    .clk( recv_wdata_bypass_q__clk[3] ),
    .count( recv_wdata_bypass_q__count[3] ),
    .reset( recv_wdata_bypass_q__reset[3] ),
    .recv__msg( recv_wdata_bypass_q__recv__msg[3] ),
    .recv__rdy( recv_wdata_bypass_q__recv__rdy[3] ),
    .recv__val( recv_wdata_bypass_q__recv__val[3] ),
    .send__msg( recv_wdata_bypass_q__send__msg[3] ),
    .send__rdy( recv_wdata_bypass_q__send__rdy[3] ),
    .send__val( recv_wdata_bypass_q__send__val[3] )
  );

  //-------------------------------------------------------------
  // End of component recv_wdata_bypass_q[0:3]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component reg_file[0:1]
  //-------------------------------------------------------------

  logic [0:0] reg_file__clk [0:1];
  logic [3:0] reg_file__raddr [0:1][0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__rdata [0:1][0:0];
  logic [0:0] reg_file__reset [0:1];
  logic [3:0] reg_file__waddr [0:1][0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__wdata [0:1][0:0];
  logic [0:0] reg_file__wen [0:1][0:0];

  RegisterFile__84f0703fd9bfd535 reg_file__0
  (
    .clk( reg_file__clk[0] ),
    .raddr( reg_file__raddr[0] ),
    .rdata( reg_file__rdata[0] ),
    .reset( reg_file__reset[0] ),
    .waddr( reg_file__waddr[0] ),
    .wdata( reg_file__wdata[0] ),
    .wen( reg_file__wen[0] )
  );

  RegisterFile__84f0703fd9bfd535 reg_file__1
  (
    .clk( reg_file__clk[1] ),
    .raddr( reg_file__raddr[1] ),
    .rdata( reg_file__rdata[1] ),
    .reset( reg_file__reset[1] ),
    .waddr( reg_file__waddr[1] ),
    .wdata( reg_file__wdata[1] ),
    .wen( reg_file__wen[1] )
  );

  //-------------------------------------------------------------
  // End of component reg_file[0:1]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component write_crossbar
  //-------------------------------------------------------------

  logic [0:0] write_crossbar__clk;
  TileSramXbarPacket_4_3_288__c14254250acb3a03 write_crossbar__packet_on_input_units [0:3];
  logic [0:0] write_crossbar__reset;
  TileSramXbarPacket_4_3_288__c14254250acb3a03 write_crossbar__recv__msg [0:3];
  logic [0:0] write_crossbar__recv__rdy [0:3];
  logic [0:0] write_crossbar__recv__val [0:3];
  TileSramXbarPacket_4_3_288__c14254250acb3a03 write_crossbar__send__msg [0:2];
  logic [0:0] write_crossbar__send__rdy [0:2];
  logic [0:0] write_crossbar__send__val [0:2];

  XbarBypassQueueRTL__7b5fa573f9efe6f9 write_crossbar
  (
    .clk( write_crossbar__clk ),
    .packet_on_input_units( write_crossbar__packet_on_input_units ),
    .reset( write_crossbar__reset ),
    .recv__msg( write_crossbar__recv__msg ),
    .recv__rdy( write_crossbar__recv__rdy ),
    .recv__val( write_crossbar__recv__val ),
    .send__msg( write_crossbar__send__msg ),
    .send__rdy( write_crossbar__send__rdy ),
    .send__val( write_crossbar__send__val )
  );

  //-------------------------------------------------------------
  // End of component write_crossbar
  //-------------------------------------------------------------
  logic [8:0] __tmpvar__assemble_xbar_pkt_recv_raddr;
  logic [1:0] __tmpvar__assemble_xbar_pkt_bank_index_load_local;
  logic [8:0] __tmpvar__assemble_xbar_pkt_recv_raddr_from_noc;
  logic [1:0] __tmpvar__assemble_xbar_pkt_bank_index_load_from_noc;
  logic [8:0] __tmpvar__assemble_xbar_pkt_recv_waddr;
  logic [1:0] __tmpvar__assemble_xbar_pkt_bank_index_store_local;
  logic [8:0] __tmpvar__assemble_xbar_pkt_recv_waddr_from_noc;
  logic [1:0] __tmpvar__assemble_xbar_pkt_bank_index_store_from_noc;
  logic [3:0] __tmpvar__update_all_from_cgra_id;
  logic [2:0] __tmpvar__update_all_from_tile_id;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/data/DataMemWithCrossbarRTL.py:169
  // @update
  // def assemble_xbar_pkt():
  //   for i in range(num_xbar_in_rd_ports):
  //     s.rd_pkt[i] @= TileSramXbarRdPktType(i, 0, 0, 0, 0)
  // 
  //   for i in range(num_xbar_in_wr_ports):
  //     s.wr_pkt[i] @= TileSramXbarWrPktType(i, 0, 0, 0, 0)
  // 
  //   if s.init_mem_done != b1(0):
  //     for i in range(num_rd_tiles):
  //       recv_raddr = s.recv_raddr[i].msg
  //       # Calculates the target bank index for load.
  //       if (recv_raddr >= s.address_lower) & (recv_raddr <= s.address_upper):
  //         bank_index_load_local = trunc((recv_raddr - s.address_lower) >> per_bank_addr_nbits, XbarOutRdType)
  //       else:
  //         bank_index_load_local = XbarOutRdType(num_banks_per_cgra)
  //       # FIXME: change to exact tile id.
  //       s.rd_pkt[i] @= TileSramXbarRdPktType(i,                       # src
  //                                            bank_index_load_local,   # dst
  //                                            recv_raddr,              # addr
  //                                            s.cgra_id,               # src_cgra
  //                                            0)                       # src_tile
  // 
  //     recv_raddr_from_noc = s.recv_from_noc_load_request.msg.payload.data_addr
  //     # Calculates the target bank index.
  //     if (recv_raddr_from_noc >= s.address_lower) & (recv_raddr_from_noc <= s.address_upper):
  //       bank_index_load_from_noc = trunc((recv_raddr_from_noc - s.address_lower) >> per_bank_addr_nbits, XbarOutRdType)
  //     else:
  //       bank_index_load_from_noc = XbarOutRdType(num_banks_per_cgra)
  //     s.rd_pkt[num_rd_tiles] @= TileSramXbarRdPktType(num_rd_tiles,                                   # src
  //                                                     bank_index_load_from_noc,                       # dst
  //                                                     recv_raddr_from_noc,                            # addr
  //                                                     s.recv_from_noc_load_request.msg.src,           # src_cgra
  //                                                     s.recv_from_noc_load_request.msg.src_tile_id)   # src_tile
  // 
  //     for i in range(num_wr_tiles):
  //       recv_waddr = s.recv_waddr[i].msg
  //       # Calculates the target bank index for store.
  //       if (recv_waddr >= s.address_lower) & (recv_waddr <= s.address_upper):
  //         bank_index_store_local = trunc((recv_waddr - s.address_lower) >> per_bank_addr_nbits, XbarOutWrType)
  //       else:
  //         bank_index_store_local = XbarOutWrType(num_banks_per_cgra)
  //       s.wr_pkt[i] @= TileSramXbarWrPktType(i,                       # src
  //                                            bank_index_store_local,  # dst
  //                                            recv_waddr,              # addr
  //                                            0,                       # src_cgra
  //                                            0)                       # src_tile
  // 
  //     recv_waddr_from_noc = s.recv_from_noc_store_request.msg.payload.data_addr
  //     if (recv_waddr_from_noc >= s.address_lower) & (recv_waddr_from_noc <= s.address_upper):
  //       bank_index_store_from_noc = trunc((recv_waddr_from_noc - s.address_lower) >> per_bank_addr_nbits, XbarOutWrType)
  //     else:
  //       bank_index_store_from_noc = XbarOutWrType(num_banks_per_cgra)
  //     s.wr_pkt[num_wr_tiles] @= TileSramXbarWrPktType(num_wr_tiles,               # src
  //                                                     bank_index_store_from_noc,  # dst
  //                                                     recv_waddr_from_noc,        # addr
  //                                                     0,                          # src_cgra
  //                                                     0)                          # src_tile
  
  always_comb begin : assemble_xbar_pkt
    for ( int unsigned i = 1'd0; i < 3'( __const__num_xbar_in_rd_ports_at_assemble_xbar_pkt ); i += 1'd1 )
      rd_pkt[2'(i)] = { 2'(i), 2'd0, 9'd0, 4'd0, 3'd0 };
    for ( int unsigned i = 1'd0; i < 3'( __const__num_xbar_in_wr_ports_at_assemble_xbar_pkt ); i += 1'd1 )
      wr_pkt[2'(i)] = { 2'(i), 2'd0, 9'd0, 4'd0, 3'd0 };
    if ( init_mem_done != 1'd0 ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__num_rd_tiles_at_assemble_xbar_pkt ); i += 1'd1 ) begin
        __tmpvar__assemble_xbar_pkt_recv_raddr = recv_raddr__msg[2'(i)];
        if ( ( __tmpvar__assemble_xbar_pkt_recv_raddr >= address_lower ) & ( __tmpvar__assemble_xbar_pkt_recv_raddr <= address_upper ) ) begin
          __tmpvar__assemble_xbar_pkt_bank_index_load_local = 2'(( __tmpvar__assemble_xbar_pkt_recv_raddr - address_lower ) >> 3'( __const__per_bank_addr_nbits_at_assemble_xbar_pkt ));
        end
        else
          __tmpvar__assemble_xbar_pkt_bank_index_load_local = 2'd2;
        rd_pkt[2'(i)] = { 2'(i), __tmpvar__assemble_xbar_pkt_bank_index_load_local, __tmpvar__assemble_xbar_pkt_recv_raddr, cgra_id, 3'd0 };
      end
      __tmpvar__assemble_xbar_pkt_recv_raddr_from_noc = recv_from_noc_load_request__msg.payload.data_addr;
      if ( ( __tmpvar__assemble_xbar_pkt_recv_raddr_from_noc >= address_lower ) & ( __tmpvar__assemble_xbar_pkt_recv_raddr_from_noc <= address_upper ) ) begin
        __tmpvar__assemble_xbar_pkt_bank_index_load_from_noc = 2'(( __tmpvar__assemble_xbar_pkt_recv_raddr_from_noc - address_lower ) >> 3'( __const__per_bank_addr_nbits_at_assemble_xbar_pkt ));
      end
      else
        __tmpvar__assemble_xbar_pkt_bank_index_load_from_noc = 2'd2;
      rd_pkt[2'( __const__num_rd_tiles_at_assemble_xbar_pkt )] = { 2'( __const__num_rd_tiles_at_assemble_xbar_pkt ), __tmpvar__assemble_xbar_pkt_bank_index_load_from_noc, __tmpvar__assemble_xbar_pkt_recv_raddr_from_noc, recv_from_noc_load_request__msg.src, recv_from_noc_load_request__msg.src_tile_id };
      for ( int unsigned i = 1'd0; i < 2'( __const__num_wr_tiles_at_assemble_xbar_pkt ); i += 1'd1 ) begin
        __tmpvar__assemble_xbar_pkt_recv_waddr = recv_waddr__msg[2'(i)];
        if ( ( __tmpvar__assemble_xbar_pkt_recv_waddr >= address_lower ) & ( __tmpvar__assemble_xbar_pkt_recv_waddr <= address_upper ) ) begin
          __tmpvar__assemble_xbar_pkt_bank_index_store_local = 2'(( __tmpvar__assemble_xbar_pkt_recv_waddr - address_lower ) >> 3'( __const__per_bank_addr_nbits_at_assemble_xbar_pkt ));
        end
        else
          __tmpvar__assemble_xbar_pkt_bank_index_store_local = 2'd2;
        wr_pkt[2'(i)] = { 2'(i), __tmpvar__assemble_xbar_pkt_bank_index_store_local, __tmpvar__assemble_xbar_pkt_recv_waddr, 4'd0, 3'd0 };
      end
      __tmpvar__assemble_xbar_pkt_recv_waddr_from_noc = recv_from_noc_store_request__msg.payload.data_addr;
      if ( ( __tmpvar__assemble_xbar_pkt_recv_waddr_from_noc >= address_lower ) & ( __tmpvar__assemble_xbar_pkt_recv_waddr_from_noc <= address_upper ) ) begin
        __tmpvar__assemble_xbar_pkt_bank_index_store_from_noc = 2'(( __tmpvar__assemble_xbar_pkt_recv_waddr_from_noc - address_lower ) >> 3'( __const__per_bank_addr_nbits_at_assemble_xbar_pkt ));
      end
      else
        __tmpvar__assemble_xbar_pkt_bank_index_store_from_noc = 2'd2;
      wr_pkt[2'( __const__num_wr_tiles_at_assemble_xbar_pkt )] = { 2'( __const__num_wr_tiles_at_assemble_xbar_pkt ), __tmpvar__assemble_xbar_pkt_bank_index_store_from_noc, __tmpvar__assemble_xbar_pkt_recv_waddr_from_noc, 4'd0, 3'd0 };
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/data/DataMemWithCrossbarRTL.py:230
  // @update
  // def update_all():
  // 
  //   # Initializes the signals.
  //   for i in range(num_rd_tiles):
  //       s.recv_raddr[i].rdy @= 0
  //   s.recv_from_noc_load_request.rdy @= 0
  // 
  //   for i in range(num_wr_tiles):
  //     s.recv_waddr[i].rdy @= 0
  //     s.recv_wdata_bypass_q[i].send.rdy @= 0
  //   s.recv_from_noc_store_request.rdy @= 0
  //   s.recv_wdata_bypass_q[num_wr_tiles].send.rdy @= 0
  // 
  //   for i in range(num_rd_tiles):
  //     s.send_rdata[i].val @= 0
  //     s.send_rdata[i].msg @= DataType()
  //   s.send_to_noc_load_response_pkt.val @= 0
  // 
  //   s.send_to_noc_load_response_pkt.msg @= \
  //       NocPktType(0, # src
  //                  0, # dst
  //                  0, # src_x
  //                  0, # src_y
  //                  0, # dst_x
  //                  0, # dst_y
  //                  0, # src_tile_id
  //                  0, # dst_tile_id
  //                  0, # opaque
  //                  0, # vc_id
  //                  CgraPayloadType(0, 0, 0, 0, 0))
  // 
  // 
  //   for i in range(num_wr_tiles):
  //     s.recv_wdata[i].rdy @= 0
  //     s.recv_wdata_bypass_q[i].recv.val @= 0
  //     s.recv_wdata_bypass_q[i].recv.msg @= DataType()
  //   s.recv_wdata_bypass_q[num_wr_tiles].recv.val @= 0
  //   s.recv_wdata_bypass_q[num_wr_tiles].recv.msg @= DataType()
  // 
  //   s.send_to_noc_store_pkt.msg @= \
  //       NocPktType(0, # src
  //                  0, # dst
  //                  0, # src_x
  //                  0, # src_y
  //                  0, # dst_x
  //                  0, # dst_y
  //                  0, # src_tile_id
  //                  0, # dst_tile_id
  //                  0, # opaque
  //                  0, # vc_id
  //                  CgraPayloadType(0, 0, 0, 0, 0))
  // 
  //   s.send_to_noc_store_pkt.val @= 0
  // 
  //   for i in range(num_xbar_in_rd_ports):
  //     s.read_crossbar.recv[i].val @= 0
  //     s.read_crossbar.recv[i].msg @= TileSramXbarRdPktType(0, 0, 0, 0, 0)
  // 
  //   s.recv_from_noc_load_response_pkt.rdy @= 0
  // 
  //   for i in range(num_xbar_in_wr_ports):
  //     s.write_crossbar.recv[i].val @= 0
  //     s.write_crossbar.recv[i].msg @= TileSramXbarRdPktType(0, 0, 0, 0, 0)
  // 
  //   for i in range(num_xbar_out_wr_ports):
  //     s.write_crossbar.send[i].rdy @= 0
  // 
  //   for i in range(num_xbar_out_rd_ports):
  //     s.read_crossbar.send[i].rdy @= 0
  // 
  //   for b in range(num_banks_per_cgra):
  //     s.reg_file[b].raddr[0] @= PerBankAddrType(0)
  // 
  //   s.send_to_noc_load_request_pkt.msg @= \
  //       NocPktType(0, # src
  //                  0, # dst
  //                  0, # src_x
  //                  0, # src_y
  //                  0, # dst_x
  //                  0, # dst_y
  //                  0, # src_tile_id
  //                  0, # dst_tile_id
  //                  0, # opaque
  //                  0, # vc_id
  //                  CgraPayloadType(0, 0, 0, 0, 0))
  // 
  //   s.send_to_noc_load_request_pkt.val @= 0
  // 
  //   if s.init_mem_done == 0:
  //     for b in range(num_banks_per_cgra):
  //       s.reg_file[b].waddr[0] @= trunc(s.init_mem_addr, PerBankAddrType)
  //       s.reg_file[b].wdata[0] @= s.preload_data_per_bank[b][trunc(s.init_mem_addr, PreloadDataPerBankSizeType)]
  //       s.reg_file[b].wen[0] @= b1(1)
  // 
  //   else:
  //     for i in range(num_wr_tiles):
  //       s.recv_wdata[i].rdy @= s.recv_wdata_bypass_q[i].recv.rdy
  //       s.recv_wdata_bypass_q[i].recv.val @= s.recv_wdata[i].val
  //       s.recv_wdata_bypass_q[i].recv.msg @= s.recv_wdata[i].msg
  //     s.recv_from_noc_store_request.rdy @= s.recv_wdata_bypass_q[num_wr_tiles].recv.rdy
  //     s.recv_wdata_bypass_q[num_wr_tiles].recv.val @= s.recv_from_noc_store_request.val
  //     s.recv_wdata_bypass_q[num_wr_tiles].recv.msg @= s.recv_from_noc_store_request.msg.payload.data
  // 
  //     for i in range(num_rd_tiles):
  //         s.read_crossbar.recv[i].val @= s.recv_raddr[i].val
  //         s.read_crossbar.recv[i].msg @= s.rd_pkt[i]
  //         s.recv_raddr[i].rdy @= s.read_crossbar.recv[i].rdy
  //     s.read_crossbar.recv[num_rd_tiles].val @= s.recv_from_noc_load_request.val
  //     s.read_crossbar.recv[num_rd_tiles].msg @= s.rd_pkt[num_rd_tiles]
  //     s.recv_from_noc_load_request.rdy @= s.read_crossbar.recv[num_rd_tiles].rdy
  // 
  //     for i in range(num_wr_tiles):
  //       s.write_crossbar.recv[i].val @= s.recv_waddr[i].val
  //       s.write_crossbar.recv[i].msg @= s.wr_pkt[i]
  //       s.recv_waddr[i].rdy @= s.write_crossbar.recv[i].rdy
  //     s.write_crossbar.recv[num_wr_tiles].val @= s.recv_from_noc_store_request.val
  //     s.write_crossbar.recv[num_wr_tiles].msg @= s.wr_pkt[num_wr_tiles]
  //     s.recv_from_noc_store_request.rdy @= s.write_crossbar.recv[num_wr_tiles].rdy
  // 
  //     # Connects the read ports towards SRAM and NoC from the xbar.
  //     for b in range(num_banks_per_cgra):
  //       s.read_crossbar.send[b].rdy @= 1
  //       s.reg_file[b].raddr[0] @= trunc(s.read_crossbar.send[b].msg.addr % data_mem_size_per_bank, PerBankAddrType)
  // 
  //     for i in range(num_xbar_in_rd_ports):
  //       if (s.read_crossbar.send[s.read_crossbar.packet_on_input_units[i].dst].msg.src == i) & \
  //          (s.read_crossbar.packet_on_input_units[i].dst < num_banks_per_cgra):
  //         if i < num_rd_tiles:
  //           s.send_rdata[RdTileIdType(i)].msg @= s.reg_file[trunc(s.read_crossbar.packet_on_input_units[i].dst, LocalBankIndexType)].rdata[0]
  //           s.send_rdata[RdTileIdType(i)].val @= s.read_crossbar.send[s.read_crossbar.packet_on_input_units[i].dst].val
  //         # TODO: Check the translated Verilog to make sure the loop is flattened correctly with special out (NocPktType) towards NoC.
  //         else:
  //           from_cgra_id = s.read_crossbar.send[s.read_crossbar.packet_on_input_units[i].dst].msg.src_cgra
  //           from_tile_id = s.read_crossbar.send[s.read_crossbar.packet_on_input_units[i].dst].msg.src_tile
  //           s.send_to_noc_load_response_pkt.msg @= \
  //               NocPktType(
  //                   s.cgra_id, # src_cgra_id
  //                   from_cgra_id, # dst_cgra_id
  //                   s.idTo2d_x_lut[s.cgra_id], # src_cgra_x
  //                   s.idTo2d_y_lut[s.cgra_id], # src_cgra_y
  //                   s.idTo2d_x_lut[from_cgra_id], # dst_cgra_x
  //                   s.idTo2d_y_lut[from_cgra_id], # dst_cgra_x
  //                   0, # src_tile_id
  //                   s.read_crossbar.send[s.read_crossbar.packet_on_input_units[i].dst].msg.src_tile, # dst_tile_id
  //                   0, # opaque
  //                   0, # vc_id
  //                   CgraPayloadType(
  //                       CMD_LOAD_RESPONSE,
  //                       DataType(s.reg_file[trunc(s.read_crossbar.packet_on_input_units[i].dst, LocalBankIndexType)].rdata[0].payload,
  //                                s.reg_file[trunc(s.read_crossbar.packet_on_input_units[i].dst, LocalBankIndexType)].rdata[0].predicate, 0, 0),
  //                       s.read_crossbar.send[s.read_crossbar.packet_on_input_units[i].dst].msg.addr, 0, 0))
  // 
  //           s.send_to_noc_load_response_pkt.val @= \
  //               s.read_crossbar.send[s.read_crossbar.packet_on_input_units[i].dst].val
  // 
  //       # Handles the case the load requests coming from a remote CGRA via the NoC.
  //       elif (s.read_crossbar.send[s.read_crossbar.packet_on_input_units[i].dst].msg.src == i) & \
  //            (s.read_crossbar.packet_on_input_units[i].dst >= num_banks_per_cgra):
  //         # Request from NoC would never target another remote access, i.e., as long
  //         # as the request can come from the NoC, it meant to access this local SRAM,
  //         # which should be guarded by the controller and NoC routers.
  //         # assert(i < num_banks_per_cgra)
  //         s.send_rdata[RdTileIdType(i)].msg @= s.recv_from_noc_load_response_pkt.msg.payload.data
  //         # TODO: https://github.com/tancheng/VectorCGRA/issues/26 -- Modify this part for non-blocking access.
  //         s.send_rdata[RdTileIdType(i)].val @= \
  //             s.read_crossbar.send[s.read_crossbar.packet_on_input_units[i].dst].val & \
  //             s.recv_from_noc_load_response_pkt.val
  //             # FIXME: The msg would come back one by one in order, so no
  //             # need to check the src_tile, which can be improved.
  //             # s.recv_from_noc_rdata.en & \
  //             # (s.recv_from_noc_rdata.msg.src_tile == i)
  // 
  //     # Handles the request (not response) towards the others via the NoC.
  //     s.send_to_noc_load_request_pkt.msg @= \
  //         NocPktType(s.cgra_id, # src
  //                    0, # dst
  //                    s.idTo2d_x_lut[s.cgra_id], # src_x
  //                    s.idTo2d_y_lut[s.cgra_id], # src_y
  //                    0, # dst_x
  //                    0, # dst_y
  //                    0, # src_tile_id
  //                    0, # dst_tile_id
  //                    0, # opaque
  //                    0, # vc_id
  //                    CgraPayloadType(
  //                        CMD_LOAD_REQUEST,
  //                        0,
  //                        s.read_crossbar.send[num_banks_per_cgra].msg.addr, 0, 0))
  // 
  //     # 'send_to_noc_load_pending' avoids sending pending request multiple times.
  //     s.send_to_noc_load_request_pkt.val @= s.read_crossbar.send[num_banks_per_cgra].val & \
  //                                           ~s.send_to_noc_load_pending
  //                                           # s.recv_from_noc_rdata.val
  //                                           # s.send_to_noc_load_request_pkt.rdy & \
  //     # Outstanding remote read access would block the inport (for read request) of the NoC. 
  //     # Therefore, we don't have to include `& s.send_rdata[x].rdy` as it must be ready/pending
  //     # for a long time waiting for the response.
  //     # TODO: https://github.com/tancheng/VectorCGRA/issues/26 -- Modify this part for non-blocking access.
  //     # 'val` indicates the data is arbitrated successfully.
  //     s.recv_from_noc_load_response_pkt.rdy @= s.read_crossbar.send[num_banks_per_cgra].val
  //     # Only allows releasing the pending request until the required load data is back,
  //     # i.e., though the request already sent out to NoC (the port is still blocked until
  //     # response is back).
  //     s.read_crossbar.send[num_banks_per_cgra].rdy @= s.recv_from_noc_load_response_pkt.val
  // 
  //     # Connects the write ports towards SRAM and NoC from the xbar.
  //     for b in range(num_banks_per_cgra):
  //       s.reg_file[b].wen[0] @= b1(0)
  //       s.reg_file[b].waddr[0] @= trunc(s.write_crossbar.send[b].msg.addr % data_mem_size_per_bank, PerBankAddrType)
  //       s.reg_file[b].wdata[0] @= s.recv_wdata_bypass_q[s.write_crossbar.send[b].msg.src].send.msg
  //       s.write_crossbar.send[b].rdy @= 1
  //       s.reg_file[b].wen[0] @= s.write_crossbar.send[b].val
  // 
  //     for i in range(num_xbar_in_wr_ports):
  //       s.recv_wdata_bypass_q[i].send.rdy @= \
  //               s.write_crossbar.send[s.write_crossbar.packet_on_input_units[i].dst].val
  // 
  //     # Handles the one connecting to the NoC.
  //     s.send_to_noc_store_pkt.msg @= \
  //         NocPktType(s.cgra_id, # src
  //                    0, # dst
  //                    s.idTo2d_x_lut[s.cgra_id], # src_x
  //                    s.idTo2d_y_lut[s.cgra_id], # src_y
  //                    0, # dst_x
  //                    0, # dst_y
  //                    0, # src_tile_id
  //                    0, # dst_tile_id
  //                    0, # opaque
  //                    0, # vc_id
  //                   CgraPayloadType(
  //                       CMD_STORE_REQUEST,
  //                       DataType(s.recv_wdata_bypass_q[s.write_crossbar.send[num_banks_per_cgra].msg.src].send.msg.payload,
  //                                s.recv_wdata_bypass_q[s.write_crossbar.send[num_banks_per_cgra].msg.src].send.msg.predicate, 0, 0),
  //                       s.write_crossbar.send[num_banks_per_cgra].msg.addr, 0, 0))
  // 
  //     s.send_to_noc_store_pkt.val @= s.write_crossbar.send[num_banks_per_cgra].val
  //     s.write_crossbar.send[num_banks_per_cgra].rdy @= s.send_to_noc_store_pkt.rdy
  
  always_comb begin : update_all
    for ( int unsigned i = 1'd0; i < 2'( __const__num_rd_tiles_at_update_all ); i += 1'd1 )
      recv_raddr__rdy[2'(i)] = 1'd0;
    recv_from_noc_load_request__rdy = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_wr_tiles_at_update_all ); i += 1'd1 ) begin
      recv_waddr__rdy[2'(i)] = 1'd0;
      recv_wdata_bypass_q__send__rdy[2'(i)] = 1'd0;
    end
    recv_from_noc_store_request__rdy = 1'd0;
    recv_wdata_bypass_q__send__rdy[2'( __const__num_wr_tiles_at_update_all )] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_rd_tiles_at_update_all ); i += 1'd1 ) begin
      send_rdata__val[2'(i)] = 1'd0;
      send_rdata__msg[2'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    send_to_noc_load_response_pkt__val = 1'd0;
    send_to_noc_load_response_pkt__msg = { 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 3'd0, 3'd0, 8'd0, 2'd0, { 4'd0, 35'd0, 9'd0, 111'd0, 4'd0 } };
    for ( int unsigned i = 1'd0; i < 2'( __const__num_wr_tiles_at_update_all ); i += 1'd1 ) begin
      recv_wdata__rdy[2'(i)] = 1'd0;
      recv_wdata_bypass_q__recv__val[2'(i)] = 1'd0;
      recv_wdata_bypass_q__recv__msg[2'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_wdata_bypass_q__recv__val[2'( __const__num_wr_tiles_at_update_all )] = 1'd0;
    recv_wdata_bypass_q__recv__msg[2'( __const__num_wr_tiles_at_update_all )] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    send_to_noc_store_pkt__msg = { 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 3'd0, 3'd0, 8'd0, 2'd0, { 4'd0, 35'd0, 9'd0, 111'd0, 4'd0 } };
    send_to_noc_store_pkt__val = 1'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_xbar_in_rd_ports_at_update_all ); i += 1'd1 ) begin
      read_crossbar__recv__val[2'(i)] = 1'd0;
      read_crossbar__recv__msg[2'(i)] = { 2'd0, 2'd0, 9'd0, 4'd0, 3'd0 };
    end
    recv_from_noc_load_response_pkt__rdy = 1'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_xbar_in_wr_ports_at_update_all ); i += 1'd1 ) begin
      write_crossbar__recv__val[2'(i)] = 1'd0;
      write_crossbar__recv__msg[2'(i)] = { 2'd0, 2'd0, 9'd0, 4'd0, 3'd0 };
    end
    for ( int unsigned i = 1'd0; i < 2'( __const__num_xbar_out_wr_ports_at_update_all ); i += 1'd1 )
      write_crossbar__send__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_xbar_out_rd_ports_at_update_all ); i += 1'd1 )
      read_crossbar__send__rdy[2'(i)] = 1'd0;
    for ( int unsigned b = 1'd0; b < 2'( __const__num_banks_per_cgra_at_update_all ); b += 1'd1 )
      reg_file__raddr[1'(b)][1'd0] = 4'd0;
    send_to_noc_load_request_pkt__msg = { 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 3'd0, 3'd0, 8'd0, 2'd0, { 4'd0, 35'd0, 9'd0, 111'd0, 4'd0 } };
    send_to_noc_load_request_pkt__val = 1'd0;
    if ( init_mem_done == 1'd0 ) begin
      for ( int unsigned b = 1'd0; b < 2'( __const__num_banks_per_cgra_at_update_all ); b += 1'd1 ) begin
        reg_file__waddr[1'(b)][1'd0] = init_mem_addr;
        reg_file__wdata[1'(b)][1'd0] = preload_data_per_bank[1'(b)][1'(init_mem_addr)];
        reg_file__wen[1'(b)][1'd0] = 1'd1;
      end
    end
    else begin
      for ( int unsigned i = 1'd0; i < 2'( __const__num_wr_tiles_at_update_all ); i += 1'd1 ) begin
        recv_wdata__rdy[2'(i)] = recv_wdata_bypass_q__recv__rdy[2'(i)];
        recv_wdata_bypass_q__recv__val[2'(i)] = recv_wdata__val[2'(i)];
        recv_wdata_bypass_q__recv__msg[2'(i)] = recv_wdata__msg[2'(i)];
      end
      recv_from_noc_store_request__rdy = recv_wdata_bypass_q__recv__rdy[2'( __const__num_wr_tiles_at_update_all )];
      recv_wdata_bypass_q__recv__val[2'( __const__num_wr_tiles_at_update_all )] = recv_from_noc_store_request__val;
      recv_wdata_bypass_q__recv__msg[2'( __const__num_wr_tiles_at_update_all )] = recv_from_noc_store_request__msg.payload.data;
      for ( int unsigned i = 1'd0; i < 2'( __const__num_rd_tiles_at_update_all ); i += 1'd1 ) begin
        read_crossbar__recv__val[2'(i)] = recv_raddr__val[2'(i)];
        read_crossbar__recv__msg[2'(i)] = rd_pkt[2'(i)];
        recv_raddr__rdy[2'(i)] = read_crossbar__recv__rdy[2'(i)];
      end
      read_crossbar__recv__val[2'( __const__num_rd_tiles_at_update_all )] = recv_from_noc_load_request__val;
      read_crossbar__recv__msg[2'( __const__num_rd_tiles_at_update_all )] = rd_pkt[2'( __const__num_rd_tiles_at_update_all )];
      recv_from_noc_load_request__rdy = read_crossbar__recv__rdy[2'( __const__num_rd_tiles_at_update_all )];
      for ( int unsigned i = 1'd0; i < 2'( __const__num_wr_tiles_at_update_all ); i += 1'd1 ) begin
        write_crossbar__recv__val[2'(i)] = recv_waddr__val[2'(i)];
        write_crossbar__recv__msg[2'(i)] = wr_pkt[2'(i)];
        recv_waddr__rdy[2'(i)] = write_crossbar__recv__rdy[2'(i)];
      end
      write_crossbar__recv__val[2'( __const__num_wr_tiles_at_update_all )] = recv_from_noc_store_request__val;
      write_crossbar__recv__msg[2'( __const__num_wr_tiles_at_update_all )] = wr_pkt[2'( __const__num_wr_tiles_at_update_all )];
      recv_from_noc_store_request__rdy = write_crossbar__recv__rdy[2'( __const__num_wr_tiles_at_update_all )];
      for ( int unsigned b = 1'd0; b < 2'( __const__num_banks_per_cgra_at_update_all ); b += 1'd1 ) begin
        read_crossbar__send__rdy[2'(b)] = 1'd1;
        reg_file__raddr[1'(b)][1'd0] = 4'(read_crossbar__send__msg[2'(b)].addr % 9'( __const__data_mem_size_per_bank_at_update_all ));
      end
      for ( int unsigned i = 1'd0; i < 3'( __const__num_xbar_in_rd_ports_at_update_all ); i += 1'd1 )
        if ( ( read_crossbar__send__msg[read_crossbar__packet_on_input_units[2'(i)].dst].src == 2'(i) ) & ( read_crossbar__packet_on_input_units[2'(i)].dst < 2'( __const__num_banks_per_cgra_at_update_all ) ) ) begin
          if ( 2'(i) < 2'( __const__num_rd_tiles_at_update_all ) ) begin
            send_rdata__msg[2'( 2'(i) )] = reg_file__rdata[1'(read_crossbar__packet_on_input_units[2'(i)].dst)][1'd0];
            send_rdata__val[2'( 2'(i) )] = read_crossbar__send__val[read_crossbar__packet_on_input_units[2'(i)].dst];
          end
          else begin
            __tmpvar__update_all_from_cgra_id = read_crossbar__send__msg[read_crossbar__packet_on_input_units[2'(i)].dst].src_cgra;
            __tmpvar__update_all_from_tile_id = read_crossbar__send__msg[read_crossbar__packet_on_input_units[2'(i)].dst].src_tile;
            send_to_noc_load_response_pkt__msg = { cgra_id, __tmpvar__update_all_from_cgra_id, idTo2d_x_lut[cgra_id], idTo2d_y_lut[cgra_id], idTo2d_x_lut[__tmpvar__update_all_from_cgra_id], idTo2d_y_lut[__tmpvar__update_all_from_cgra_id], 3'd0, read_crossbar__send__msg[read_crossbar__packet_on_input_units[2'(i)].dst].src_tile, 8'd0, 2'd0, { 4'( __const__CMD_LOAD_RESPONSE ), { reg_file__rdata[1'(read_crossbar__packet_on_input_units[2'(i)].dst)][1'd0].payload, reg_file__rdata[1'(read_crossbar__packet_on_input_units[2'(i)].dst)][1'd0].predicate, 1'd0, 1'd0 }, read_crossbar__send__msg[read_crossbar__packet_on_input_units[2'(i)].dst].addr, 111'd0, 4'd0 } };
            send_to_noc_load_response_pkt__val = read_crossbar__send__val[read_crossbar__packet_on_input_units[2'(i)].dst];
          end
        end
        else if ( ( read_crossbar__send__msg[read_crossbar__packet_on_input_units[2'(i)].dst].src == 2'(i) ) & ( read_crossbar__packet_on_input_units[2'(i)].dst >= 2'( __const__num_banks_per_cgra_at_update_all ) ) ) begin
          send_rdata__msg[2'( 2'(i) )] = recv_from_noc_load_response_pkt__msg.payload.data;
          send_rdata__val[2'( 2'(i) )] = read_crossbar__send__val[read_crossbar__packet_on_input_units[2'(i)].dst] & recv_from_noc_load_response_pkt__val;
        end
      send_to_noc_load_request_pkt__msg = { cgra_id, 4'd0, idTo2d_x_lut[cgra_id], idTo2d_y_lut[cgra_id], 2'd0, 2'd0, 3'd0, 3'd0, 8'd0, 2'd0, { 4'( __const__CMD_LOAD_REQUEST ), 35'd0, read_crossbar__send__msg[2'( __const__num_banks_per_cgra_at_update_all )].addr, 111'd0, 4'd0 } };
      send_to_noc_load_request_pkt__val = read_crossbar__send__val[2'( __const__num_banks_per_cgra_at_update_all )] & ( ~send_to_noc_load_pending );
      recv_from_noc_load_response_pkt__rdy = read_crossbar__send__val[2'( __const__num_banks_per_cgra_at_update_all )];
      read_crossbar__send__rdy[2'( __const__num_banks_per_cgra_at_update_all )] = recv_from_noc_load_response_pkt__val;
      for ( int unsigned b = 1'd0; b < 2'( __const__num_banks_per_cgra_at_update_all ); b += 1'd1 ) begin
        reg_file__wen[1'(b)][1'd0] = 1'd0;
        reg_file__waddr[1'(b)][1'd0] = 4'(write_crossbar__send__msg[2'(b)].addr % 9'( __const__data_mem_size_per_bank_at_update_all ));
        reg_file__wdata[1'(b)][1'd0] = recv_wdata_bypass_q__send__msg[write_crossbar__send__msg[2'(b)].src];
        write_crossbar__send__rdy[2'(b)] = 1'd1;
        reg_file__wen[1'(b)][1'd0] = write_crossbar__send__val[2'(b)];
      end
      for ( int unsigned i = 1'd0; i < 3'( __const__num_xbar_in_wr_ports_at_update_all ); i += 1'd1 )
        recv_wdata_bypass_q__send__rdy[2'(i)] = write_crossbar__send__val[write_crossbar__packet_on_input_units[2'(i)].dst];
      send_to_noc_store_pkt__msg = { cgra_id, 4'd0, idTo2d_x_lut[cgra_id], idTo2d_y_lut[cgra_id], 2'd0, 2'd0, 3'd0, 3'd0, 8'd0, 2'd0, { 4'( __const__CMD_STORE_REQUEST ), { recv_wdata_bypass_q__send__msg[write_crossbar__send__msg[2'( __const__num_banks_per_cgra_at_update_all )].src].payload, recv_wdata_bypass_q__send__msg[write_crossbar__send__msg[2'( __const__num_banks_per_cgra_at_update_all )].src].predicate, 1'd0, 1'd0 }, write_crossbar__send__msg[2'( __const__num_banks_per_cgra_at_update_all )].addr, 111'd0, 4'd0 } };
      send_to_noc_store_pkt__val = write_crossbar__send__val[2'( __const__num_banks_per_cgra_at_update_all )];
      write_crossbar__send__rdy[2'( __const__num_banks_per_cgra_at_update_all )] = send_to_noc_store_pkt__rdy;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/data/DataMemWithCrossbarRTL.py:484
  // @update_ff
  // def update_init_index_once():
  //     if s.reset:
  //       s.init_mem_done <<= 0
  //       s.init_mem_addr <<= PerBankAddrType(0)
  //     else:
  //       if s.init_mem_done == 0:
  //         s.init_mem_done <<= 1
  //         s.init_mem_addr <<= PerBankAddrType(0)
  
  always_ff @(posedge clk) begin : update_init_index_once
    if ( reset ) begin
      init_mem_done <= 1'd0;
      init_mem_addr <= 4'd0;
    end
    else if ( init_mem_done == 1'd0 ) begin
      init_mem_done <= 1'd1;
      init_mem_addr <= 4'd0;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/data/DataMemWithCrossbarRTL.py:495
  // @update_ff
  // def update_remote_load_pending():
  //   if s.reset:
  //     s.send_to_noc_load_pending <<= 0
  //   else:
  //     if s.recv_from_noc_load_response_pkt.val:
  //       s.send_to_noc_load_pending <<= 0
  //     elif s.send_to_noc_load_request_pkt.val & s.send_to_noc_load_request_pkt.rdy:
  //       s.send_to_noc_load_pending <<= 1
  
  always_ff @(posedge clk) begin : update_remote_load_pending
    if ( reset ) begin
      send_to_noc_load_pending <= 1'd0;
    end
    else if ( recv_from_noc_load_response_pkt__val ) begin
      send_to_noc_load_pending <= 1'd0;
    end
    else if ( send_to_noc_load_request_pkt__val & send_to_noc_load_request_pkt__rdy ) begin
      send_to_noc_load_pending <= 1'd1;
    end
  end

  assign reg_file__clk[0] = clk;
  assign reg_file__reset[0] = reset;
  assign reg_file__clk[1] = clk;
  assign reg_file__reset[1] = reset;
  assign read_crossbar__clk = clk;
  assign read_crossbar__reset = reset;
  assign write_crossbar__clk = clk;
  assign write_crossbar__reset = reset;
  assign recv_wdata_bypass_q__clk[0] = clk;
  assign recv_wdata_bypass_q__reset[0] = reset;
  assign recv_wdata_bypass_q__clk[1] = clk;
  assign recv_wdata_bypass_q__reset[1] = reset;
  assign recv_wdata_bypass_q__clk[2] = clk;
  assign recv_wdata_bypass_q__reset[2] = reset;
  assign recv_wdata_bypass_q__clk[3] = clk;
  assign recv_wdata_bypass_q__reset[3] = reset;
  assign idTo2d_x_lut[0] = 2'd0;
  assign idTo2d_y_lut[0] = 2'd0;
  assign idTo2d_x_lut[1] = 2'd1;
  assign idTo2d_y_lut[1] = 2'd0;
  assign idTo2d_x_lut[2] = 2'd2;
  assign idTo2d_y_lut[2] = 2'd0;
  assign idTo2d_x_lut[3] = 2'd0;
  assign idTo2d_y_lut[3] = 2'd1;
  assign idTo2d_x_lut[4] = 2'd1;
  assign idTo2d_y_lut[4] = 2'd1;
  assign idTo2d_x_lut[5] = 2'd2;
  assign idTo2d_y_lut[5] = 2'd1;
  assign idTo2d_x_lut[6] = 2'd0;
  assign idTo2d_y_lut[6] = 2'd2;
  assign idTo2d_x_lut[7] = 2'd1;
  assign idTo2d_y_lut[7] = 2'd2;
  assign idTo2d_x_lut[8] = 2'd2;
  assign idTo2d_y_lut[8] = 2'd2;
  assign preload_data_per_bank[0][0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign preload_data_per_bank[1][0] = { 32'd0, 1'd0, 1'd0, 1'd0 };

endmodule


// PyMTL Component ConstQueueDynamicRTL Definition
// Full name: ConstQueueDynamicRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__const_mem_size_16
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/const/ConstQueueDynamicRTL.py

module ConstQueueDynamicRTL__88a7029ff4fc07c5
(
  input  logic [0:0] clk ,
  input  logic [0:0] ctrl_proceed ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_const__msg  ,
  input logic [0:0] send_const__rdy  ,
  output logic [0:0] send_const__val  
);
  localparam logic [4:0] __const__const_mem_size_at_load_const  = 5'd16;
  localparam logic [4:0] __const__const_mem_size_at_update_wr_cur  = 5'd16;
  logic [3:0] rd_cur;
  logic [4:0] wr_cur;
  //-------------------------------------------------------------
  // Component reg_file
  //-------------------------------------------------------------

  logic [0:0] reg_file__clk;
  logic [3:0] reg_file__raddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__rdata [0:0];
  logic [0:0] reg_file__reset;
  logic [3:0] reg_file__waddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__wdata [0:0];
  logic [0:0] reg_file__wen [0:0];

  RegisterFile__84f0703fd9bfd535 reg_file
  (
    .clk( reg_file__clk ),
    .raddr( reg_file__raddr ),
    .rdata( reg_file__rdata ),
    .reset( reg_file__reset ),
    .waddr( reg_file__waddr ),
    .wdata( reg_file__wdata ),
    .wen( reg_file__wen )
  );

  //-------------------------------------------------------------
  // End of component reg_file
  //-------------------------------------------------------------
  logic [0:0] __tmpvar__load_const_not_full;
  logic [0:0] __tmpvar__update_wr_cur_not_full;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/const/ConstQueueDynamicRTL.py:55
  // @update
  // def load_const():
  //   # Initializes signals.
  //   s.reg_file.waddr[0] @= AddrType()
  //   s.reg_file.wdata[0] @= DataType()
  //   s.reg_file.wen[0] @= 0
  // 
  //   not_full = s.wr_cur < const_mem_size
  //   s.recv_const.rdy @= not_full
  // 
  //   if s.recv_const.val & not_full:
  //     s.reg_file.waddr[0] @= trunc(s.wr_cur, AddrType)
  //     s.reg_file.wdata[0] @= s.recv_const.msg
  //     s.reg_file.wen[0] @= 1
  
  always_comb begin : load_const
    reg_file__waddr[1'd0] = 4'd0;
    reg_file__wdata[1'd0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    reg_file__wen[1'd0] = 1'd0;
    __tmpvar__load_const_not_full = wr_cur < 5'( __const__const_mem_size_at_load_const );
    recv_const__rdy = __tmpvar__load_const_not_full;
    if ( recv_const__val & __tmpvar__load_const_not_full ) begin
      reg_file__waddr[1'd0] = 4'(wr_cur);
      reg_file__wdata[1'd0] = recv_const__msg;
      reg_file__wen[1'd0] = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/const/ConstQueueDynamicRTL.py:82
  // @update
  // def update_send_val():
  //   # Checks if read cursor is in front of write cursor.
  //   if (zext(s.rd_cur, WrCurType) < s.wr_cur):
  //     s.send_const.val @= 1
  //   else:
  //     s.send_const.val @= 0
  
  always_comb begin : update_send_val
    if ( { { 1 { 1'b0 } }, rd_cur } < wr_cur ) begin
      send_const__val = 1'd1;
    end
    else
      send_const__val = 1'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/const/ConstQueueDynamicRTL.py:91
  // @update_ff
  // def update_rd_cur():
  //   if s.reset:
  //     s.rd_cur <<= 0
  //   else:
  //     # Checks whether the "reader" successfully read the data at rd_cur,
  //     # and proceed rd_cur accordingly.
  //     if s.send_const.rdy & s.ctrl_proceed:
  //       if zext((s.rd_cur), WrCurType) < (s.wr_cur - 1):
  //         s.rd_cur <<= s.rd_cur + 1
  //       else:
  //         s.rd_cur <<= 0
  
  always_ff @(posedge clk) begin : update_rd_cur
    if ( reset ) begin
      rd_cur <= 4'd0;
    end
    else if ( send_const__rdy & ctrl_proceed ) begin
      if ( { { 1 { 1'b0 } }, rd_cur } < ( wr_cur - 5'd1 ) ) begin
        rd_cur <= rd_cur + 4'd1;
      end
      else
        rd_cur <= 4'd0;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/const/ConstQueueDynamicRTL.py:71
  // @update_ff
  // def update_wr_cur():
  //   not_full = (s.wr_cur < const_mem_size)
  //   if s.reset:
  //     s.wr_cur <<= 0
  //   # Checks if there's a valid const (from producer) to be written.
  //   else:
  //     if s.recv_const.val & not_full:
  //       s.wr_cur <<= s.wr_cur + 1
  
  always_ff @(posedge clk) begin : update_wr_cur
    __tmpvar__update_wr_cur_not_full = wr_cur < 5'( __const__const_mem_size_at_update_wr_cur );
    if ( reset ) begin
      wr_cur <= 5'd0;
    end
    else if ( recv_const__val & __tmpvar__update_wr_cur_not_full ) begin
      wr_cur <= wr_cur + 5'd1;
    end
  end

  assign reg_file__clk = clk;
  assign reg_file__reset = reset;
  assign send_const__msg = reg_file__rdata[0];
  assign reg_file__raddr[0] = rd_cur;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__nregs_16__rd_ports_1__wr_ports_1__const_zero_False
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py

module RegisterFile__fe9876efc6d7a4b7
(
  input  logic [0:0] clk ,
  input  logic [3:0] raddr [0:0],
  output CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [3:0] waddr [0:0],
  input  CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf regs [0:15];

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component CtrlMemDynamicRTL Definition
// Full name: CtrlMemDynamicRTL__IntraCgraPktType_IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74__CgraPayloadType_MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__cc89ed621b71ae36__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__ctrl_mem_size_16__num_fu_inports_4__num_fu_outports_2__num_tile_inports_4__num_tile_outports_4__num_cgras_9__num_tiles_4__ctrl_count_per_iter_2__total_ctrl_steps_2
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py

module CtrlMemDynamicRTL__49719e7312efa92b
(
  input  logic [3:0] cgra_id ,
  input  logic [0:0] clk ,
  output logic [2:0] prologue_count_outport_fu ,
  output logic [2:0] prologue_count_outport_fu_crossbar [0:1],
  output logic [2:0] prologue_count_outport_routing_crossbar [0:3],
  input  logic [0:0] reset ,
  input  logic [2:0] tile_id ,
  input IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv_pkt_from_controller__msg  ,
  output logic [0:0] recv_pkt_from_controller__rdy  ,
  input logic [0:0] recv_pkt_from_controller__val  ,
  output CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf send_ctrl__msg  ,
  input logic [0:0] send_ctrl__rdy  ,
  output logic [0:0] send_ctrl__val  ,
  output IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send_pkt_to_controller__msg  ,
  input logic [0:0] send_pkt_to_controller__rdy  ,
  output logic [0:0] send_pkt_to_controller__val  
);
  localparam logic [2:0] __const__num_fu_inports_at_update_msg  = 3'd4;
  localparam logic [3:0] __const__num_routing_outports_at_update_msg  = 4'd8;
  localparam logic [2:0] __const__num_tile_inports_at_update_msg  = 3'd4;
  localparam logic [1:0] __const__CMD_CONFIG  = 2'd3;
  localparam logic [2:0] __const__CMD_CONFIG_PROLOGUE_FU  = 3'd4;
  localparam logic [2:0] __const__CMD_CONFIG_PROLOGUE_FU_CROSSBAR  = 3'd5;
  localparam logic [2:0] __const__CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR  = 3'd6;
  localparam logic [0:0] __const__CMD_LAUNCH  = 1'd0;
  localparam logic [1:0] __const__CMD_TERMINATE  = 2'd2;
  localparam logic [0:0] __const__CMD_PAUSE  = 1'd1;
  localparam logic [2:0] __const__CMD_CONFIG_TOTAL_CTRL_COUNT  = 3'd7;
  localparam logic [3:0] __const__CMD_CONFIG_COUNT_PER_ITER  = 4'd8;
  localparam logic [2:0] __const__num_tiles_at_update_send_out_signal  = 3'd4;
  localparam logic [3:0] __const__CMD_COMPLETE  = 4'd13;
  localparam logic [5:0] __const__OPT_START  = 6'd0;
  localparam logic [4:0] __const__ctrl_mem_size_at_update_raddr_and_fu_prologue  = 5'd16;
  localparam logic [2:0] __const__num_tile_inports_at_update_prologue_outport  = 3'd4;
  localparam logic [1:0] __const__num_fu_outports_at_update_prologue_outport  = 2'd2;
  localparam logic [2:0] __const__num_tile_inports_at_update_prologue_reg  = 3'd4;
  localparam logic [1:0] __const__num_fu_outports_at_update_prologue_reg  = 2'd2;
  localparam logic [1:0] __const__ctrl_count_per_iter_at_update_ctrl_count_per_iter  = 2'd2;
  localparam logic [1:0] __const__total_ctrl_steps_at_update_total_ctrl_steps  = 2'd2;
  logic [4:0] ctrl_count_per_iter_val;
  logic [2:0] prologue_count_reg_fu [0:15];
  logic [2:0] prologue_count_reg_fu_crossbar [0:1];
  logic [2:0] prologue_count_reg_routing_crossbar [0:3];
  logic [0:0] sent_complete;
  logic [0:0] start_iterate_ctrl;
  logic [10:0] times;
  logic [10:0] total_ctrl_steps_val;
  //-------------------------------------------------------------
  // Component recv_pkt_queue
  //-------------------------------------------------------------

  logic [0:0] recv_pkt_queue__clk;
  logic [1:0] recv_pkt_queue__count;
  logic [0:0] recv_pkt_queue__reset;
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv_pkt_queue__recv__msg;
  logic [0:0] recv_pkt_queue__recv__rdy;
  logic [0:0] recv_pkt_queue__recv__val;
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv_pkt_queue__send__msg;
  logic [0:0] recv_pkt_queue__send__rdy;
  logic [0:0] recv_pkt_queue__send__val;

  NormalQueueRTL__9578d8c7b27375fb recv_pkt_queue
  (
    .clk( recv_pkt_queue__clk ),
    .count( recv_pkt_queue__count ),
    .reset( recv_pkt_queue__reset ),
    .recv__msg( recv_pkt_queue__recv__msg ),
    .recv__rdy( recv_pkt_queue__recv__rdy ),
    .recv__val( recv_pkt_queue__recv__val ),
    .send__msg( recv_pkt_queue__send__msg ),
    .send__rdy( recv_pkt_queue__send__rdy ),
    .send__val( recv_pkt_queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component recv_pkt_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component reg_file
  //-------------------------------------------------------------

  logic [0:0] reg_file__clk;
  logic [3:0] reg_file__raddr [0:0];
  CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf reg_file__rdata [0:0];
  logic [0:0] reg_file__reset;
  logic [3:0] reg_file__waddr [0:0];
  CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf reg_file__wdata [0:0];
  logic [0:0] reg_file__wen [0:0];

  RegisterFile__fe9876efc6d7a4b7 reg_file
  (
    .clk( reg_file__clk ),
    .raddr( reg_file__raddr ),
    .rdata( reg_file__rdata ),
    .reset( reg_file__reset ),
    .waddr( reg_file__waddr ),
    .wdata( reg_file__wdata ),
    .wen( reg_file__wen )
  );

  //-------------------------------------------------------------
  // End of component reg_file
  //-------------------------------------------------------------
  logic [2:0] __tmpvar__update_prologue_reg_temp_routing_crossbar_in;
  logic [1:0] __tmpvar__update_prologue_reg_temp_fu_crossbar_in;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:81
  // @update
  // def update_msg():
  // 
  //   s.recv_pkt_queue.send.rdy @= 0
  //   s.reg_file.wen[0] @= 0
  //   s.reg_file.waddr[0] @= s.recv_pkt_queue.send.msg.payload.ctrl_addr
  //   # Initializes the fields of the control signal.
  //   # s.reg_file.wdata[0] @= CtrlType()
  //   s.reg_file.wdata[0].operation @= 0
  //   s.reg_file.wdata[0].predicate @= 0
  //   for i in range(num_fu_inports):
  //     s.reg_file.wdata[0].fu_in[i] @= 0
  //     s.reg_file.wdata[0].write_reg_from[i] @= s.recv_pkt_queue.send.msg.payload.ctrl.write_reg_from[i]
  //     s.reg_file.wdata[0].write_reg_idx[i] @= s.recv_pkt_queue.send.msg.payload.ctrl.write_reg_idx[i]
  //     s.reg_file.wdata[0].read_reg_from[i] @= s.recv_pkt_queue.send.msg.payload.ctrl.read_reg_from[i]
  //     s.reg_file.wdata[0].read_reg_idx[i] @= s.recv_pkt_queue.send.msg.payload.ctrl.read_reg_idx[i]
  //   for i in range(num_routing_outports):
  //     s.reg_file.wdata[0].routing_xbar_outport[i] @= 0
  //     s.reg_file.wdata[0].fu_xbar_outport[i] @= 0
  //   for i in range(num_tile_inports):
  //     s.reg_file.wdata[0].routing_predicate_in[i] @= 0
  //   s.reg_file.wdata[0].vector_factor_power @= s.recv_pkt_queue.send.msg.payload.ctrl.vector_factor_power
  //   s.reg_file.wdata[0].is_last_ctrl @= 0
  // 
  //   if s.recv_pkt_queue.send.val & (s.recv_pkt_queue.send.msg.payload.cmd == CMD_CONFIG):
  //     s.reg_file.wen[0] @= 1
  //     s.reg_file.waddr[0] @= s.recv_pkt_queue.send.msg.payload.ctrl_addr
  //     # Fills the fields of the control signal.
  //     s.reg_file.wdata[0].operation @= s.recv_pkt_queue.send.msg.payload.ctrl.operation
  //     s.reg_file.wdata[0].predicate @= s.recv_pkt_queue.send.msg.payload.ctrl.predicate
  //     for i in range(num_fu_inports):
  //       s.reg_file.wdata[0].fu_in[i] @= s.recv_pkt_queue.send.msg.payload.ctrl.fu_in[i]
  //       s.reg_file.wdata[0].write_reg_from[i] @= s.recv_pkt_queue.send.msg.payload.ctrl.write_reg_from[i]
  //       s.reg_file.wdata[0].write_reg_idx[i] @= s.recv_pkt_queue.send.msg.payload.ctrl.write_reg_idx[i]
  //       s.reg_file.wdata[0].read_reg_from[i] @= s.recv_pkt_queue.send.msg.payload.ctrl.read_reg_from[i]
  //       s.reg_file.wdata[0].read_reg_idx[i] @= s.recv_pkt_queue.send.msg.payload.ctrl.read_reg_idx[i]
  //     for i in range(num_routing_outports):
  //       s.reg_file.wdata[0].routing_xbar_outport[i] @= s.recv_pkt_queue.send.msg.payload.ctrl.routing_xbar_outport[i]
  //       s.reg_file.wdata[0].fu_xbar_outport[i] @= s.recv_pkt_queue.send.msg.payload.ctrl.fu_xbar_outport[i]
  //     for i in range(num_tile_inports):
  //       s.reg_file.wdata[0].routing_predicate_in[i] @= s.recv_pkt_queue.send.msg.payload.ctrl.routing_predicate_in[i]
  //     s.reg_file.wdata[0].vector_factor_power @= s.recv_pkt_queue.send.msg.payload.ctrl.vector_factor_power
  //     s.reg_file.wdata[0].is_last_ctrl @= s.recv_pkt_queue.send.msg.payload.ctrl.is_last_ctrl
  // 
  //   if (s.recv_pkt_queue.send.msg.payload.cmd == CMD_CONFIG) | \
  //      (s.recv_pkt_queue.send.msg.payload.cmd == CMD_CONFIG_PROLOGUE_FU) | \
  //      (s.recv_pkt_queue.send.msg.payload.cmd == CMD_CONFIG_PROLOGUE_FU_CROSSBAR) | \
  //      (s.recv_pkt_queue.send.msg.payload.cmd == CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR) | \
  //      (s.recv_pkt_queue.send.msg.payload.cmd == CMD_LAUNCH) | \
  //      (s.recv_pkt_queue.send.msg.payload.cmd == CMD_TERMINATE) | \
  //      (s.recv_pkt_queue.send.msg.payload.cmd == CMD_PAUSE) | \
  //      (s.recv_pkt_queue.send.msg.payload.cmd == CMD_CONFIG_TOTAL_CTRL_COUNT) | \
  //      (s.recv_pkt_queue.send.msg.payload.cmd == CMD_CONFIG_COUNT_PER_ITER):
  //     s.recv_pkt_queue.send.rdy @= 1
  //   # TODO: Extend for the other commands. Maybe another queue to
  //   # handle complicated actions.
  //   # else:
  
  always_comb begin : update_msg
    recv_pkt_queue__send__rdy = 1'd0;
    reg_file__wen[1'd0] = 1'd0;
    reg_file__waddr[1'd0] = recv_pkt_queue__send__msg.payload.ctrl_addr;
    reg_file__wdata[1'd0].operation = 6'd0;
    reg_file__wdata[1'd0].predicate = 1'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_fu_inports_at_update_msg ); i += 1'd1 ) begin
      reg_file__wdata[1'd0].fu_in[2'(i)] = 3'd0;
      reg_file__wdata[1'd0].write_reg_from[2'(i)] = recv_pkt_queue__send__msg.payload.ctrl.write_reg_from[2'(i)];
      reg_file__wdata[1'd0].write_reg_idx[2'(i)] = recv_pkt_queue__send__msg.payload.ctrl.write_reg_idx[2'(i)];
      reg_file__wdata[1'd0].read_reg_from[2'(i)] = recv_pkt_queue__send__msg.payload.ctrl.read_reg_from[2'(i)];
      reg_file__wdata[1'd0].read_reg_idx[2'(i)] = recv_pkt_queue__send__msg.payload.ctrl.read_reg_idx[2'(i)];
    end
    for ( int unsigned i = 1'd0; i < 4'( __const__num_routing_outports_at_update_msg ); i += 1'd1 ) begin
      reg_file__wdata[1'd0].routing_xbar_outport[3'(i)] = 3'd0;
      reg_file__wdata[1'd0].fu_xbar_outport[3'(i)] = 2'd0;
    end
    for ( int unsigned i = 1'd0; i < 3'( __const__num_tile_inports_at_update_msg ); i += 1'd1 )
      reg_file__wdata[1'd0].routing_predicate_in[2'(i)] = 1'd0;
    reg_file__wdata[1'd0].vector_factor_power = recv_pkt_queue__send__msg.payload.ctrl.vector_factor_power;
    reg_file__wdata[1'd0].is_last_ctrl = 1'd0;
    if ( recv_pkt_queue__send__val & ( recv_pkt_queue__send__msg.payload.cmd == 4'( __const__CMD_CONFIG ) ) ) begin
      reg_file__wen[1'd0] = 1'd1;
      reg_file__waddr[1'd0] = recv_pkt_queue__send__msg.payload.ctrl_addr;
      reg_file__wdata[1'd0].operation = recv_pkt_queue__send__msg.payload.ctrl.operation;
      reg_file__wdata[1'd0].predicate = recv_pkt_queue__send__msg.payload.ctrl.predicate;
      for ( int unsigned i = 1'd0; i < 3'( __const__num_fu_inports_at_update_msg ); i += 1'd1 ) begin
        reg_file__wdata[1'd0].fu_in[2'(i)] = recv_pkt_queue__send__msg.payload.ctrl.fu_in[2'(i)];
        reg_file__wdata[1'd0].write_reg_from[2'(i)] = recv_pkt_queue__send__msg.payload.ctrl.write_reg_from[2'(i)];
        reg_file__wdata[1'd0].write_reg_idx[2'(i)] = recv_pkt_queue__send__msg.payload.ctrl.write_reg_idx[2'(i)];
        reg_file__wdata[1'd0].read_reg_from[2'(i)] = recv_pkt_queue__send__msg.payload.ctrl.read_reg_from[2'(i)];
        reg_file__wdata[1'd0].read_reg_idx[2'(i)] = recv_pkt_queue__send__msg.payload.ctrl.read_reg_idx[2'(i)];
      end
      for ( int unsigned i = 1'd0; i < 4'( __const__num_routing_outports_at_update_msg ); i += 1'd1 ) begin
        reg_file__wdata[1'd0].routing_xbar_outport[3'(i)] = recv_pkt_queue__send__msg.payload.ctrl.routing_xbar_outport[3'(i)];
        reg_file__wdata[1'd0].fu_xbar_outport[3'(i)] = recv_pkt_queue__send__msg.payload.ctrl.fu_xbar_outport[3'(i)];
      end
      for ( int unsigned i = 1'd0; i < 3'( __const__num_tile_inports_at_update_msg ); i += 1'd1 )
        reg_file__wdata[1'd0].routing_predicate_in[2'(i)] = recv_pkt_queue__send__msg.payload.ctrl.routing_predicate_in[2'(i)];
      reg_file__wdata[1'd0].vector_factor_power = recv_pkt_queue__send__msg.payload.ctrl.vector_factor_power;
      reg_file__wdata[1'd0].is_last_ctrl = recv_pkt_queue__send__msg.payload.ctrl.is_last_ctrl;
    end
    if ( ( ( ( ( ( ( ( ( recv_pkt_queue__send__msg.payload.cmd == 4'( __const__CMD_CONFIG ) ) | ( recv_pkt_queue__send__msg.payload.cmd == 4'( __const__CMD_CONFIG_PROLOGUE_FU ) ) ) | ( recv_pkt_queue__send__msg.payload.cmd == 4'( __const__CMD_CONFIG_PROLOGUE_FU_CROSSBAR ) ) ) | ( recv_pkt_queue__send__msg.payload.cmd == 4'( __const__CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR ) ) ) | ( recv_pkt_queue__send__msg.payload.cmd == 4'( __const__CMD_LAUNCH ) ) ) | ( recv_pkt_queue__send__msg.payload.cmd == 4'( __const__CMD_TERMINATE ) ) ) | ( recv_pkt_queue__send__msg.payload.cmd == 4'( __const__CMD_PAUSE ) ) ) | ( recv_pkt_queue__send__msg.payload.cmd == 4'( __const__CMD_CONFIG_TOTAL_CTRL_COUNT ) ) ) | ( recv_pkt_queue__send__msg.payload.cmd == 4'( __const__CMD_CONFIG_COUNT_PER_ITER ) ) ) begin
      recv_pkt_queue__send__rdy = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:216
  // @update
  // def update_prologue_outport():
  //   s.prologue_count_outport_fu @= s.prologue_count_reg_fu[s.reg_file.raddr[0]]
  //   for i in range(num_tile_inports):
  //     s.prologue_count_outport_routing_crossbar[i] @= \
  //         s.prologue_count_reg_routing_crossbar[i]
  //   for i in range(num_fu_outports):
  //     s.prologue_count_outport_fu_crossbar[i] @= \
  //         s.prologue_count_reg_fu_crossbar[i]
  
  always_comb begin : update_prologue_outport
    prologue_count_outport_fu = prologue_count_reg_fu[reg_file__raddr[1'd0]];
    for ( int unsigned i = 1'd0; i < 3'( __const__num_tile_inports_at_update_prologue_outport ); i += 1'd1 )
      prologue_count_outport_routing_crossbar[2'(i)] = prologue_count_reg_routing_crossbar[2'(i)];
    for ( int unsigned i = 1'd0; i < 2'( __const__num_fu_outports_at_update_prologue_outport ); i += 1'd1 )
      prologue_count_outport_fu_crossbar[1'(i)] = prologue_count_reg_fu_crossbar[1'(i)];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:140
  // @update
  // def update_send_out_signal():
  //   s.send_ctrl.val @= 0
  //   s.send_pkt_to_controller.val @= 0
  //   s.send_pkt_to_controller.msg @= IntraCgraPktType(0, num_tiles, 0, 0, 0, 0, 0, 0, 0, 0, CgraPayloadType(CMD_COMPLETE, 0, 0, 0, 0))
  //   if s.start_iterate_ctrl == b1(1):
  //     if ((s.total_ctrl_steps_val > 0) & (s.times == s.total_ctrl_steps_val)) | \
  //        (s.reg_file.rdata[0].operation == OPT_START):
  //       s.send_ctrl.val @= b1(0)
  //       # Sends COMPLETE signal to Controller when the last ctrl signal is done.
  //       if ~s.sent_complete & (s.total_ctrl_steps_val > 0) & (s.times == s.total_ctrl_steps_val) & s.start_iterate_ctrl:
  //         s.send_pkt_to_controller.msg @= \
  //             IntraCgraPktType(s.tile_id, num_tiles, 0, 0, 0, 0, 0, 0, 0, 0, CgraPayloadType(CMD_COMPLETE, 0, 0, 0, 0))
  //         s.send_pkt_to_controller.val @= 1
  //     else:
  //       s.send_ctrl.val @= 1
  //   if s.recv_pkt_queue.send.val & \
  //      ((s.recv_pkt_queue.send.msg.payload.cmd == CMD_PAUSE) | \
  //       (s.recv_pkt_queue.send.msg.payload.cmd == CMD_TERMINATE)):
  //     s.send_ctrl.val @= b1(0)
  
  always_comb begin : update_send_out_signal
    send_ctrl__val = 1'd0;
    send_pkt_to_controller__val = 1'd0;
    send_pkt_to_controller__msg = { 3'd0, 3'( __const__num_tiles_at_update_send_out_signal ), 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 8'd0, 1'd0, { 4'( __const__CMD_COMPLETE ), 35'd0, 9'd0, 111'd0, 4'd0 } };
    if ( start_iterate_ctrl == 1'd1 ) begin
      if ( ( ( total_ctrl_steps_val > 11'd0 ) & ( times == total_ctrl_steps_val ) ) | ( reg_file__rdata[1'd0].operation == 6'( __const__OPT_START ) ) ) begin
        send_ctrl__val = 1'd0;
        if ( ( ( ( ~sent_complete ) & ( total_ctrl_steps_val > 11'd0 ) ) & ( times == total_ctrl_steps_val ) ) & start_iterate_ctrl ) begin
          send_pkt_to_controller__msg = { tile_id, 3'( __const__num_tiles_at_update_send_out_signal ), 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 8'd0, 1'd0, { 4'( __const__CMD_COMPLETE ), 35'd0, 9'd0, 111'd0, 4'd0 } };
          send_pkt_to_controller__val = 1'd1;
        end
      end
      else
        send_ctrl__val = 1'd1;
    end
    if ( recv_pkt_queue__send__val & ( ( recv_pkt_queue__send__msg.payload.cmd == 4'( __const__CMD_PAUSE ) ) | ( recv_pkt_queue__send__msg.payload.cmd == 4'( __const__CMD_TERMINATE ) ) ) ) begin
      send_ctrl__val = 1'd0;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:174
  // @update_ff
  // def issue_complete():
  //   if s.reset:
  //     s.sent_complete <<= 0
  //   else:
  //     # Once COMPLETE signal is sent, we shouldn't send another
  //     # COMPLETE signal until the next ctrl signal is launched.
  //     # TODO: Need to extend the logic here if other signals can be
  //     # sent to the controller.
  //     if s.send_pkt_to_controller.val & s.send_pkt_to_controller.rdy:
  //       s.sent_complete <<= 1
  //     if s.recv_pkt_queue.send.val & (s.recv_pkt_queue.send.msg.payload.cmd == CMD_LAUNCH):
  //       s.sent_complete <<= 0
  
  always_ff @(posedge clk) begin : issue_complete
    if ( reset ) begin
      sent_complete <= 1'd0;
    end
    else begin
      if ( send_pkt_to_controller__val & send_pkt_to_controller__rdy ) begin
        sent_complete <= 1'd1;
      end
      if ( recv_pkt_queue__send__val & ( recv_pkt_queue__send__msg.payload.cmd == 4'( __const__CMD_LAUNCH ) ) ) begin
        sent_complete <= 1'd0;
      end
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:243
  // @update_ff
  // def update_ctrl_count_per_iter():
  //   if s.reset:
  //     s.ctrl_count_per_iter_val <<= PCType(ctrl_count_per_iter)
  //   elif s.recv_pkt_queue.send.val & (s.recv_pkt_queue.send.msg.payload.cmd == CMD_CONFIG_COUNT_PER_ITER):
  //     s.ctrl_count_per_iter_val <<= trunc(s.recv_pkt_queue.send.msg.payload.data.payload, PCType)
  
  always_ff @(posedge clk) begin : update_ctrl_count_per_iter
    if ( reset ) begin
      ctrl_count_per_iter_val <= 5'd2;
    end
    else if ( recv_pkt_queue__send__val & ( recv_pkt_queue__send__msg.payload.cmd == 4'( __const__CMD_CONFIG_COUNT_PER_ITER ) ) ) begin
      ctrl_count_per_iter_val <= 5'(recv_pkt_queue__send__msg.payload.data.payload);
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:226
  // @update_ff
  // def update_prologue_reg():
  //   if s.reset:
  //     for i in range(num_tile_inports):
  //       s.prologue_count_reg_routing_crossbar[i] <<= 0
  //     for i in range(num_fu_outports):
  //       s.prologue_count_reg_fu_crossbar[i] <<= 0
  //   else:
  //     if s.recv_pkt_queue.send.val & \
  //        (s.recv_pkt_queue.send.msg.payload.cmd == CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR):
  //       temp_routing_crossbar_in = s.recv_pkt_queue.send.msg.payload.ctrl.routing_xbar_outport[0]
  //       s.prologue_count_reg_routing_crossbar[trunc(temp_routing_crossbar_in, TileInPortType)] <<= trunc(s.recv_pkt_queue.send.msg.payload.data.payload, PrologueCountType)
  //     elif s.recv_pkt_queue.send.val & \
  //        (s.recv_pkt_queue.send.msg.payload.cmd == CMD_CONFIG_PROLOGUE_FU_CROSSBAR):
  //       temp_fu_crossbar_in = s.recv_pkt_queue.send.msg.payload.ctrl.fu_xbar_outport[0]
  //       s.prologue_count_reg_fu_crossbar[trunc(temp_fu_crossbar_in, FuOutPortType)] <<= trunc(s.recv_pkt_queue.send.msg.payload.data.payload, PrologueCountType)
  
  always_ff @(posedge clk) begin : update_prologue_reg
    if ( reset ) begin
      for ( int unsigned i = 1'd0; i < 3'( __const__num_tile_inports_at_update_prologue_reg ); i += 1'd1 )
        prologue_count_reg_routing_crossbar[2'(i)] <= 3'd0;
      for ( int unsigned i = 1'd0; i < 2'( __const__num_fu_outports_at_update_prologue_reg ); i += 1'd1 )
        prologue_count_reg_fu_crossbar[1'(i)] <= 3'd0;
    end
    else if ( recv_pkt_queue__send__val & ( recv_pkt_queue__send__msg.payload.cmd == 4'( __const__CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR ) ) ) begin
      __tmpvar__update_prologue_reg_temp_routing_crossbar_in = recv_pkt_queue__send__msg.payload.ctrl.routing_xbar_outport[3'd0];
      prologue_count_reg_routing_crossbar[2'(__tmpvar__update_prologue_reg_temp_routing_crossbar_in)] <= 3'(recv_pkt_queue__send__msg.payload.data.payload);
    end
    else if ( recv_pkt_queue__send__val & ( recv_pkt_queue__send__msg.payload.cmd == 4'( __const__CMD_CONFIG_PROLOGUE_FU_CROSSBAR ) ) ) begin
      __tmpvar__update_prologue_reg_temp_fu_crossbar_in = recv_pkt_queue__send__msg.payload.ctrl.fu_xbar_outport[3'd0];
      prologue_count_reg_fu_crossbar[1'(__tmpvar__update_prologue_reg_temp_fu_crossbar_in)] <= 3'(recv_pkt_queue__send__msg.payload.data.payload);
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:188
  // @update_ff
  // def update_raddr_and_fu_prologue():
  //   if s.reset:
  //     s.times <<= 0
  //     s.reg_file.raddr[0] <<= 0
  //     for i in range(ctrl_mem_size):
  //       s.prologue_count_reg_fu[i] <<= 0
  //   else:
  //     if s.recv_pkt_queue.send.val & \
  //        (s.recv_pkt_queue.send.msg.payload.cmd == CMD_CONFIG_PROLOGUE_FU):
  //       s.prologue_count_reg_fu[s.recv_pkt_queue.send.msg.payload.ctrl_addr] <<= \
  //           trunc(s.recv_pkt_queue.send.msg.payload.data.payload, PrologueCountType)
  // 
  //     if s.start_iterate_ctrl == b1(1):
  //       if ((s.total_ctrl_steps_val == 0) | \
  //           (s.times < s.total_ctrl_steps_val)) & \
  //          s.send_ctrl.rdy & s.send_ctrl.val:
  //         s.times <<= s.times + TimeType(1)
  // 
  //       # Reads the next ctrl signal only when the current one is done.
  //       if s.send_ctrl.rdy & s.send_ctrl.val:
  //         if s.reg_file.raddr[0] == trunc(s.ctrl_count_per_iter_val - 1, CtrlAddrType):
  //           s.reg_file.raddr[0] <<= 0
  //         else:
  //           s.reg_file.raddr[0] <<= s.reg_file.raddr[0] + CtrlAddrType(1)
  //         if s.prologue_count_reg_fu[s.reg_file.raddr[0]] > 0:
  //           s.prologue_count_reg_fu[s.reg_file.raddr[0]] <<= s.prologue_count_reg_fu[s.reg_file.raddr[0]] - 1
  
  always_ff @(posedge clk) begin : update_raddr_and_fu_prologue
    if ( reset ) begin
      times <= 11'd0;
      reg_file__raddr[1'd0] <= 4'd0;
      for ( int unsigned i = 1'd0; i < 5'( __const__ctrl_mem_size_at_update_raddr_and_fu_prologue ); i += 1'd1 )
        prologue_count_reg_fu[4'(i)] <= 3'd0;
    end
    else begin
      if ( recv_pkt_queue__send__val & ( recv_pkt_queue__send__msg.payload.cmd == 4'( __const__CMD_CONFIG_PROLOGUE_FU ) ) ) begin
        prologue_count_reg_fu[recv_pkt_queue__send__msg.payload.ctrl_addr] <= 3'(recv_pkt_queue__send__msg.payload.data.payload);
      end
      if ( start_iterate_ctrl == 1'd1 ) begin
        if ( ( ( ( total_ctrl_steps_val == 11'd0 ) | ( times < total_ctrl_steps_val ) ) & send_ctrl__rdy ) & send_ctrl__val ) begin
          times <= times + 11'd1;
        end
        if ( send_ctrl__rdy & send_ctrl__val ) begin
          if ( reg_file__raddr[1'd0] == 4'(ctrl_count_per_iter_val - 5'd1) ) begin
            reg_file__raddr[1'd0] <= 4'd0;
          end
          else
            reg_file__raddr[1'd0] <= reg_file__raddr[1'd0] + 4'd1;
          if ( prologue_count_reg_fu[reg_file__raddr[1'd0]] > 3'd0 ) begin
            prologue_count_reg_fu[reg_file__raddr[1'd0]] <= prologue_count_reg_fu[reg_file__raddr[1'd0]] - 3'd1;
          end
        end
      end
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:250
  // @update_ff
  // def update_total_ctrl_steps():
  //   if s.reset:
  //     s.total_ctrl_steps_val <<= TimeType(total_ctrl_steps)
  //   elif s.recv_pkt_queue.send.val & (s.recv_pkt_queue.send.msg.payload.cmd == CMD_CONFIG_TOTAL_CTRL_COUNT):
  //     s.total_ctrl_steps_val <<= trunc(s.recv_pkt_queue.send.msg.payload.data.payload, TimeType)
  
  always_ff @(posedge clk) begin : update_total_ctrl_steps
    if ( reset ) begin
      total_ctrl_steps_val <= 11'd2;
    end
    else if ( recv_pkt_queue__send__val & ( recv_pkt_queue__send__msg.payload.cmd == 4'( __const__CMD_CONFIG_TOTAL_CTRL_COUNT ) ) ) begin
      total_ctrl_steps_val <= 11'(recv_pkt_queue__send__msg.payload.data.payload);
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/ctrl/CtrlMemDynamicRTL.py:161
  // @update_ff
  // def update_whether_we_can_iterate_ctrl():
  //   if s.reset:
  //     s.start_iterate_ctrl <<= 0
  //   else:
  //     if s.recv_pkt_queue.send.val:
  //       if s.recv_pkt_queue.send.msg.payload.cmd == CMD_LAUNCH:
  //         s.start_iterate_ctrl <<= 1
  //       elif s.recv_pkt_queue.send.msg.payload.cmd == CMD_TERMINATE:
  //         s.start_iterate_ctrl <<= 0
  //       elif s.recv_pkt_queue.send.msg.payload.cmd == CMD_PAUSE:
  //         s.start_iterate_ctrl <<= 0
  
  always_ff @(posedge clk) begin : update_whether_we_can_iterate_ctrl
    if ( reset ) begin
      start_iterate_ctrl <= 1'd0;
    end
    else if ( recv_pkt_queue__send__val ) begin
      if ( recv_pkt_queue__send__msg.payload.cmd == 4'( __const__CMD_LAUNCH ) ) begin
        start_iterate_ctrl <= 1'd1;
      end
      else if ( recv_pkt_queue__send__msg.payload.cmd == 4'( __const__CMD_TERMINATE ) ) begin
        start_iterate_ctrl <= 1'd0;
      end
      else if ( recv_pkt_queue__send__msg.payload.cmd == 4'( __const__CMD_PAUSE ) ) begin
        start_iterate_ctrl <= 1'd0;
      end
    end
  end

  assign reg_file__clk = clk;
  assign reg_file__reset = reset;
  assign recv_pkt_queue__clk = clk;
  assign recv_pkt_queue__reset = reset;
  assign send_ctrl__msg = reg_file__rdata[0];
  assign recv_pkt_queue__recv__msg = recv_pkt_from_controller__msg;
  assign recv_pkt_from_controller__rdy = recv_pkt_queue__recv__rdy;
  assign recv_pkt_queue__recv__val = recv_pkt_from_controller__val;

endmodule


// PyMTL Component AdderRTL Definition
// Full name: AdderRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__PredicateType_CGRAData_1_1__payload_1__predicate_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__num_inports_4__num_outports_2__data_mem_size_288__vector_factor_power_0
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/AdderRTL.py

module AdderRTL__b48d5d572c75e2e4
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  input CGRAData_1_1__payload_1__predicate_1 recv_predicate__msg  ,
  output logic [0:0] recv_predicate__rdy  ,
  input logic [0:0] recv_predicate__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [5:0] __const__OPT_START  = 6'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [5:0] __const__OPT_ADD  = 6'd2;
  localparam logic [5:0] __const__OPT_ADD_CONST  = 6'd25;
  localparam logic [5:0] __const__OPT_INC  = 6'd3;
  localparam logic [5:0] __const__OPT_SUB  = 6'd4;
  localparam logic [5:0] __const__OPT_PAS  = 6'd31;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/AdderRTL.py:42
  // @update
  // def comb_logic():
  // 
  //   s.recv_all_val @= 0
  //   s.in0 @= 0
  //   s.in1 @= 0
  //   # For pick input register
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  //   for i in range(num_outports):
  //     s.send_out[i].val @= 0
  //     s.send_out[i].msg @= DataType()
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_predicate.rdy @= b1(0)
  //   s.recv_opt.rdy @= 0
  // 
  //   # Though different operations might not need to consume
  //   # all the operands, as long as the opcode indicating it
  //   # is an operand, the data would disappear from the register.
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != 0:
  //       s.in0 @= zext(s.recv_opt.msg.fu_in[0] - 1, FuInType)
  //     if s.recv_opt.msg.fu_in[1] != 0:
  //       s.in1 @= zext(s.recv_opt.msg.fu_in[1] - 1, FuInType)
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.operation == OPT_ADD:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload + s.recv_in[s.in1_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      (~s.recv_opt.msg.predicate | \
  //                                       s.recv_predicate.msg.predicate) & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_ADD_CONST:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload + s.recv_const.msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      (~s.recv_opt.msg.predicate | \
  //                                       s.recv_predicate.msg.predicate) & \
  //                                      s.reached_vector_factor
  //       s.recv_const.rdy @= s.send_out[0].rdy
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_const.val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_const.rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_INC:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload + s.const_one.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      (~s.recv_opt.msg.predicate | \
  //                                       s.recv_predicate.msg.predicate) & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_SUB:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload - s.recv_in[s.in1_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      (~s.recv_opt.msg.predicate | \
  //                                       s.recv_predicate.msg.predicate) & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_PAS:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      (~s.recv_opt.msg.predicate | \
  //                                       s.recv_predicate.msg.predicate) & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     else:
  //       for j in range(num_outports):
  //         s.send_out[j].val @= b1(0)
  //       s.recv_opt.rdy @= 0
  //       s.recv_in[s.in0_idx].rdy @= 0
  //       s.recv_in[s.in1_idx].rdy @= 0
  // 
  //     if s.recv_opt.msg.predicate == b1(1):
  //       s.recv_predicate.rdy @= s.recv_all_val & s.send_out[0].rdy
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_predicate__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 6'( __const__OPT_ADD ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload + recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = ( ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) ) & reached_vector_factor;
        recv_all_val = ( recv_in__val[in0_idx] & recv_in__val[in1_idx] ) & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_ADD_CONST ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload + recv_const__msg.payload;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) ) & reached_vector_factor;
        recv_const__rdy = send_out__rdy[1'd0];
        recv_all_val = ( recv_in__val[in0_idx] & recv_const__val ) & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_const__rdy = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_INC ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload + 32'd1;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) ) & reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx] & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_SUB ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload - recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = ( ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) ) & reached_vector_factor;
        recv_all_val = ( recv_in__val[in0_idx] & recv_in__val[in1_idx] ) & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_PAS ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) ) & reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx] & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
      end
      if ( recv_opt__msg.predicate == 1'd1 ) begin
        recv_predicate__rdy = recv_all_val & send_out__rdy[1'd0];
      end
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:66
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= DataAddrType(0)
  //   s.to_mem_raddr.msg @= DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:85
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:76
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 6'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:93
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //          (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;
  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];

endmodule


// PyMTL VerilogPlaceholder MulRecFN Definition
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/MulRecFNRTL.py

//***********************************************************
// Pickled source file of placeholder MulRecFN__expWidth_9__sigWidth_23
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder MulRecFN
//-----------------------------------------------------------

`ifndef MULRECFN
`define MULRECFN

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component MulRecFN__expWidth_9__sigWidth_23.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!

`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_primitives.v" 0
`ifndef __HARDFLOAT_PRIMITIVES_VI__
`define __HARDFLOAT_PRIMITIVES_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    reverse#(parameter width = 1) (
        input [(width - 1):0] in, output [(width - 1):0] out
    );

    genvar ix;
    generate
        for (ix = 0; ix < width; ix = ix + 1) begin :Bit
            assign out[ix] = in[width - 1 - ix];
        end
    endgenerate

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    lowMaskHiLo#(
        parameter inWidth = 1,
        parameter topBound = 1,
        parameter bottomBound = 0
    ) (
        input [(inWidth - 1):0] in,
        output [(topBound - bottomBound - 1):0] out
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam numInVals = 1<<inWidth;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [numInVals:0] c;
    assign c[numInVals] = 1;
    assign c[(numInVals - 1):0] = 0;
    wire [(topBound - bottomBound - 1):0] reverseOut =
        (c>>>in)>>(numInVals - topBound);
    reverse#(topBound - bottomBound) reverse(reverseOut, out);

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    lowMaskLoHi#(
        parameter inWidth = 1,
        parameter topBound = 0,
        parameter bottomBound = 1
    ) (
        input [(inWidth - 1):0] in,
        output [(bottomBound - topBound - 1):0] out
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam numInVals = 1<<inWidth;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [numInVals:0] c;
    assign c[numInVals] = 1;
    assign c[(numInVals - 1):0] = 0;
    wire [(bottomBound - topBound - 1):0] reverseOut =
        (c>>>~in)>>(topBound + 1);
    reverse#(bottomBound - topBound) reverse(reverseOut, out);

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    countLeadingZeros#(parameter inWidth = 1, parameter countWidth = 1) (
        input [(inWidth - 1):0] in, output [(countWidth - 1):0] count
    );

    wire [(inWidth - 1):0] reverseIn;
    reverse#(inWidth) reverse_in(in, reverseIn);
    wire [inWidth:0] oneLeastReverseIn =
        {1'b1, reverseIn} & ({1'b0, ~reverseIn} + 1);
    genvar ix;
    generate
        for (ix = 0; ix <= inWidth; ix = ix + 1) begin :Bit
            wire [(countWidth - 1):0] countSoFar;
            if (ix == 0) begin
                assign countSoFar = 0;
            end else begin
                assign countSoFar =
                    Bit[ix - 1].countSoFar | (oneLeastReverseIn[ix] ? ix : 0);
                if (ix == inWidth) assign count = countSoFar;
            end
        end
    endgenerate

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    compressBy2#(parameter inWidth = 1) (
        input [(inWidth - 1):0] in, output [((inWidth - 1)/2):0] out
    );

    localparam maxBitNumReduced = (inWidth - 1)/2;
    genvar ix;
    generate
        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit
            assign out[ix] = |in[(ix*2 + 1):ix*2];
        end
    endgenerate
    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*2];

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    compressBy4#(parameter inWidth = 1) (
        input [(inWidth - 1):0] in, output [(inWidth - 1)/4:0] out
    );

    localparam maxBitNumReduced = (inWidth - 1)/4;
    genvar ix;
    generate
        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit
            assign out[ix] = |in[(ix*4 + 3):ix*4];
        end
    endgenerate
    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*4];

endmodule

`endif /* __HARDFLOAT_PRIMITIVES_VI__ */
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/isSigNaNRecFN.v" 0
`ifndef __HARDFLOAT_ISSIGNANRECFN_V__
`define __HARDFLOAT_ISSIGNANRECFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    isSigNaNRecFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in, output isSigNaN
    );

    wire isNaN =
        (in[(expWidth + sigWidth - 1):(expWidth + sigWidth - 3)] == 'b111);
    assign isSigNaN = isNaN && !in[sigWidth - 2];

endmodule

`endif /* __HARDFLOAT_ISSIGNANRECFN_V__ */
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
`ifndef __HARDFLOAT_RAWFN_VI__
`define __HARDFLOAT_RAWFN_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_consts.vi" 0
`ifndef __HARDFLOAT_CONSTS_VI__
`define __HARDFLOAT_CONSTS_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define round_near_even   3'b000
`define round_minMag      3'b001
`define round_min         3'b010
`define round_max         3'b011
`define round_near_maxMag 3'b100
`define round_odd         3'b110

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define floatControlWidth 1
`define flControl_tininessBeforeRounding 1'b0
`define flControl_tininessAfterRounding  1'b1

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flRoundOpt_sigMSBitAlwaysZero  1
`define flRoundOpt_subnormsAlwaysExact 2
`define flRoundOpt_neverUnderflows     4
`define flRoundOpt_neverOverflows      8

`endif /* __HARDFLOAT_CONSTS_VI__ */

`line 40 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_specialize.vi" 0
`ifndef __HARDFLOAT_SPECIALIZE_VI__
`define __HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    iNFromException#(parameter width = 1) (
        input signedOut,
        input isNaN,
        input sign,
        output [(width - 1):0] out
    );

    wire maxInt = isNaN || !sign;
    assign out = {signedOut ^ maxInt, {(width - 1){maxInt}}};

endmodule

`endif /* __HARDFLOAT_SPECIALIZE_VI__ */

`line 41 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0

/* ===================== Adding some extra include files ================ */
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/RISCV/HardFloat_specialize.vi" 0
`ifndef __RISCV_HARDFLOAT_SPECIALIZE_VI__
`define __RISCV_HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flControl_default `flControl_tininessAfterRounding

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
//`define HardFloat_propagateNaNPayloads

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define HardFloat_signDefaultNaN 0
`define HardFloat_fractDefaultNaN(sigWidth) {1'b1, {((sigWidth) - 2){1'b0}}}

`endif /* __RISCV_HARDFLOAT_SPECIALIZE_VI__ */

`line 44 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
/* ====================================================================== */

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    recFNToRawFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in,
        output isNaN,
        output isInf,
        output isZero,
        output sign,
        output signed [(expWidth + 1):0] sExp,
        output [sigWidth:0] sig
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [expWidth:0] exp;
    wire [(sigWidth - 2):0] fract;
    assign {sign, exp, fract} = in;
    wire isSpecial = (exp>>(expWidth - 1) == 'b11);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    assign isNaN = isSpecial &&  exp[expWidth - 2];
    assign isInf = isSpecial && !exp[expWidth - 2];
    assign isZero = (exp>>(expWidth - 2) == 'b000);
    assign sExp = exp;
    assign sig = {1'b0, !isZero, fract};

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    roundAnyRawFNToRecFN#(
        parameter inExpWidth = 3,
        parameter inSigWidth = 3,
        parameter outExpWidth = 3,
        parameter outSigWidth = 3,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,     // overrides 'infiniteExc' and 'in_*' inputs
        input infiniteExc,    // overrides 'in_*' inputs except 'in_sign'
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(inExpWidth + 1):0] in_sExp,   // limited range allowed
        input [inSigWidth:0] in_sig,
        input [2:0] roundingMode,
        output [(outExpWidth + outSigWidth):0] out,
        output [4:0] exceptionFlags
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam sigMSBitAlwaysZero =
        ((options & `flRoundOpt_sigMSBitAlwaysZero) != 0);
    localparam effectiveInSigWidth =
        sigMSBitAlwaysZero ? inSigWidth : inSigWidth + 1;
    localparam neverUnderflows =
        ((options
              & (`flRoundOpt_neverUnderflows
                     | `flRoundOpt_subnormsAlwaysExact))
             != 0)
            || (inExpWidth < outExpWidth);
    localparam neverOverflows =
        ((options & `flRoundOpt_neverOverflows) != 0)
            || (inExpWidth < outExpWidth);
    localparam adjustedExpWidth =
          (inExpWidth < outExpWidth) ? outExpWidth + 1
        : (inExpWidth == outExpWidth) ? inExpWidth + 2
        : inExpWidth + 3;
    localparam outNaNExp = 7<<(outExpWidth - 2);
    localparam outInfExp = 6<<(outExpWidth - 2);
    localparam outMaxFiniteExp = outInfExp - 1;
    localparam outMinNormExp = (1<<(outExpWidth - 1)) + 2;
    localparam outMinNonzeroExp = outMinNormExp - outSigWidth + 1;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire roundingMode_near_even   = (roundingMode == `round_near_even);
    wire roundingMode_minMag      = (roundingMode == `round_minMag);
    wire roundingMode_min         = (roundingMode == `round_min);
    wire roundingMode_max         = (roundingMode == `round_max);
    wire roundingMode_near_maxMag = (roundingMode == `round_near_maxMag);
    wire roundingMode_odd         = (roundingMode == `round_odd);
    wire roundMagUp =
        (roundingMode_min && in_sign) || (roundingMode_max && !in_sign);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaNOut = invalidExc || (!infiniteExc && in_isNaN);
`ifdef HardFloat_propagateNaNPayloads
    wire propagateNaNPayload = isNaNOut;
`else
    wire propagateNaNPayload = 0;
`endif
    wire signed [(adjustedExpWidth - 1):0] sAdjustedExp =
        in_sExp + ((1<<outExpWidth) - (1<<inExpWidth));
    wire [(outSigWidth + 2):0] adjustedSig;
    generate
        if (inSigWidth <= outSigWidth + 2) begin
            assign adjustedSig = in_sig<<(outSigWidth - inSigWidth + 2);
        end else begin
            assign adjustedSig =
                {in_sig[inSigWidth:(inSigWidth - outSigWidth - 1)],
                 |in_sig[(inSigWidth - outSigWidth - 2):0]};
        end
    endgenerate
    wire doShiftSigDown1 =
        sigMSBitAlwaysZero ? 0 : adjustedSig[outSigWidth + 2];
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [outExpWidth:0] common_expOut;
    wire [(outSigWidth - 2):0] common_fractOut;
    wire common_overflow, common_totalUnderflow, common_underflow;
    wire common_inexact;
    generate
        if (
            neverOverflows && neverUnderflows
                && (effectiveInSigWidth <= outSigWidth)
        ) begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_expOut = sAdjustedExp + doShiftSigDown1;
            assign common_fractOut =
                doShiftSigDown1 ? adjustedSig>>3 : adjustedSig>>2;
            assign common_overflow       = 0;
            assign common_totalUnderflow = 0;
            assign common_underflow      = 0;
            assign common_inexact        = 0;
        end else begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire [(outSigWidth + 2):0] roundMask;
            if (neverUnderflows) begin
                assign roundMask = {doShiftSigDown1, 2'b11};
            end else begin
                wire [outSigWidth:0] roundMask_main;
                lowMaskLoHi#(
                    outExpWidth + 1,
                    outMinNormExp - outSigWidth - 1,
                    outMinNormExp
                ) lowMask_roundMask(
                        sAdjustedExp[outExpWidth:0]
                            | (propagateNaNPayload ? 1'b1<<outExpWidth : 1'b0),
                        roundMask_main
                    );
                assign roundMask = {roundMask_main | doShiftSigDown1, 2'b11};
            end
            wire [(outSigWidth + 2):0] shiftedRoundMask = roundMask>>1;
            wire [(outSigWidth + 2):0] roundPosMask =
                ~shiftedRoundMask & roundMask;
            wire roundPosBit =
                (|(adjustedSig[(outSigWidth + 2):3]
                       & roundPosMask[(outSigWidth + 2):3]))
                    || ((|(adjustedSig[2:0] & roundPosMask[2:0]))
                            && !propagateNaNPayload);
            wire anyRoundExtra =
                (|(adjustedSig[(outSigWidth + 2):3]
                       & shiftedRoundMask[(outSigWidth + 2):3]))
                    || ((|(adjustedSig[2:0] & shiftedRoundMask[2:0]))
                            && !propagateNaNPayload);
            wire anyRound = roundPosBit || anyRoundExtra;
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire roundIncr =
                ((roundingMode_near_even || roundingMode_near_maxMag)
                     && roundPosBit)
                    || (roundMagUp && anyRound);
            wire [(outSigWidth + 1):0] roundedSig =
                roundIncr
                    ? (((adjustedSig | roundMask)>>2) + 1)
                          & ~(roundingMode_near_even && roundPosBit
                                  && !anyRoundExtra
                                  ? roundMask>>1 : 0)
                    : (adjustedSig & ~roundMask)>>2
                          | (roundingMode_odd && anyRound
                                 ? roundPosMask>>1 : 0);
            wire signed [adjustedExpWidth:0] sExtAdjustedExp = sAdjustedExp;
            wire signed [adjustedExpWidth:0] sRoundedExp =
                sExtAdjustedExp + (roundedSig>>outSigWidth);
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_expOut = sRoundedExp;
            assign common_fractOut =
                doShiftSigDown1 ? roundedSig>>1 : roundedSig;
            assign common_overflow =
                neverOverflows ? 0 : (sRoundedExp>>>(outExpWidth - 1) >= 3);
            assign common_totalUnderflow =
                neverUnderflows ? 0 : (sRoundedExp < outMinNonzeroExp);
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire unboundedRange_roundPosBit =
                doShiftSigDown1 ? adjustedSig[2] : adjustedSig[1];
            wire unboundedRange_anyRound =
                (doShiftSigDown1 && adjustedSig[2]) || (|adjustedSig[1:0]);
            wire unboundedRange_roundIncr =
                ((roundingMode_near_even || roundingMode_near_maxMag)
                     && unboundedRange_roundPosBit)
                    || (roundMagUp && unboundedRange_anyRound);
            wire roundCarry =
                doShiftSigDown1
                    ? roundedSig[outSigWidth + 1] : roundedSig[outSigWidth];
            assign common_underflow =
                neverUnderflows ? 0
                    : common_totalUnderflow
                          || (anyRound && (sAdjustedExp>>>outExpWidth <= 0)
                                  && (doShiftSigDown1
                                          ? roundMask[3] : roundMask[2])
                                  && !(((control
                                           & `flControl_tininessAfterRounding)
                                            != 0)
                                           && !(doShiftSigDown1 ? roundMask[4]
                                                    : roundMask[3])
                                           && roundCarry && roundPosBit
                                           && unboundedRange_roundIncr));
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_inexact = common_totalUnderflow || anyRound;
        end
    endgenerate
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire notNaN_isSpecialInfOut = infiniteExc || in_isInf;
    wire commonCase = !isNaNOut && !notNaN_isSpecialInfOut && !in_isZero;
    wire overflow  = commonCase && common_overflow;
    wire underflow = commonCase && common_underflow;
    wire inexact = overflow || (commonCase && common_inexact);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire overflow_roundMagUp =
        roundingMode_near_even || roundingMode_near_maxMag || roundMagUp;
    wire pegMinNonzeroMagOut =
        commonCase && common_totalUnderflow
            && (roundMagUp || roundingMode_odd);
    wire pegMaxFiniteMagOut = overflow && !overflow_roundMagUp;
    wire notNaN_isInfOut =
        notNaN_isSpecialInfOut || (overflow && overflow_roundMagUp);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
`ifdef HardFloat_propagateNaNPayloads
    wire signOut = in_sign;
`else
    wire signOut = isNaNOut ? `HardFloat_signDefaultNaN : in_sign;
`endif
    wire [outExpWidth:0] expOut =
        (common_expOut
             & ~(in_isZero || common_totalUnderflow ? 7<<(outExpWidth - 2) : 0)
             & ~(pegMinNonzeroMagOut               ? ~outMinNonzeroExp    : 0)
             & ~(pegMaxFiniteMagOut                ? 1<<(outExpWidth - 1) : 0)
             & ~(notNaN_isInfOut                   ? 1<<(outExpWidth - 2) : 0))
            | (pegMinNonzeroMagOut ? outMinNonzeroExp : 0)
            | (pegMaxFiniteMagOut  ? outMaxFiniteExp  : 0)
            | (notNaN_isInfOut     ? outInfExp        : 0)
            | (isNaNOut            ? outNaNExp        : 0);
`ifdef HardFloat_propagateNaNPayloads
    wire [(outSigWidth - 2):0] fractOut =
        {isNaNOut
             || (!in_isZero && !common_totalUnderflow
                     && common_fractOut[outSigWidth - 2]),
         isNaNOut || (!in_isZero && !common_totalUnderflow)
             ? common_fractOut[(outSigWidth - 3):0] : 1'b0}
            | {(outSigWidth - 1){pegMaxFiniteMagOut}};
`else
    wire [(outSigWidth - 2):0] fractOut =
          (isNaNOut ? `HardFloat_fractDefaultNaN(outSigWidth) : 0)
        | (!in_isZero && !common_totalUnderflow
               ? common_fractOut & `HardFloat_fractDefaultNaN(outSigWidth) : 0)
        | (!isNaNOut && !in_isZero && !common_totalUnderflow
               ? common_fractOut & ~`HardFloat_fractDefaultNaN(outSigWidth)
               : 0)
        | {(outSigWidth - 1){pegMaxFiniteMagOut}};
`endif
    assign out = {signOut, expOut, fractOut};
    assign exceptionFlags =
        {invalidExc, infiniteExc, overflow, underflow, inexact};

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    roundRawFNToRecFN#(
        parameter expWidth = 3,
        parameter sigWidth = 3,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,     // overrides 'infiniteExc' and 'in_*' inputs
        input infiniteExc,    // overrides 'in_*' inputs except 'in_sign'
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(expWidth + 1):0] in_sExp,   // limited range allowed
        input [(sigWidth + 2):0] in_sig,
        input [2:0] roundingMode,
        output [(expWidth + sigWidth):0] out,
        output [4:0] exceptionFlags
    );

    roundAnyRawFNToRecFN#(expWidth, sigWidth + 2, expWidth, sigWidth, options)
        roundAnyRawFNToRecFN(
            control,
            invalidExc,
            infiniteExc,
            in_isNaN,
            in_isInf,
            in_isZero,
            in_sign,
            in_sExp,
            in_sig,
            roundingMode,
            out,
            exceptionFlags
        );

endmodule

`endif /* __HARDFLOAT_RAWFN_VI__ */

// End of all v_libs files for component MulRecFN__expWidth_9__sigWidth_23

`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/mulRecFN.v" 0
`ifndef __HARDFLOAT_MULRECFN_V__
`define __HARDFLOAT_MULRECFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_consts.vi" 0
`ifndef __HARDFLOAT_CONSTS_VI__
`define __HARDFLOAT_CONSTS_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define round_near_even   3'b000
`define round_minMag      3'b001
`define round_min         3'b010
`define round_max         3'b011
`define round_near_maxMag 3'b100
`define round_odd         3'b110

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define floatControlWidth 1
`define flControl_tininessBeforeRounding 1'b0
`define flControl_tininessAfterRounding  1'b1

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flRoundOpt_sigMSBitAlwaysZero  1
`define flRoundOpt_subnormsAlwaysExact 2
`define flRoundOpt_neverUnderflows     4
`define flRoundOpt_neverOverflows      8

`endif /* __HARDFLOAT_CONSTS_VI__ */

`line 40 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/mulRecFN.v" 0
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_specialize.vi" 0
`ifndef __HARDFLOAT_SPECIALIZE_VI__
`define __HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    iNFromException#(parameter width = 1) (
        input signedOut,
        input isNaN,
        input sign,
        output [(width - 1):0] out
    );

    wire maxInt = isNaN || !sign;
    assign out = {signedOut ^ maxInt, {(width - 1){maxInt}}};

endmodule

`endif /* __HARDFLOAT_SPECIALIZE_VI__ */

`line 41 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/mulRecFN.v" 0

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    mulRecFNToFullRaw#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(`floatControlWidth - 1):0] control,
        input [(expWidth + sigWidth):0] a,
        input [(expWidth + sigWidth):0] b,
        output invalidExc,
        output out_isNaN,
        output out_isInf,
        output out_isZero,
        output out_sign,
        output signed [(expWidth + 1):0] out_sExp,
        output [(sigWidth*2 - 1):0] out_sig
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaNA, isInfA, isZeroA, signA;
    wire signed [(expWidth + 1):0] sExpA;
    wire [sigWidth:0] sigA;
    recFNToRawFN#(expWidth, sigWidth)
        recFNToRawFN_a(a, isNaNA, isInfA, isZeroA, signA, sExpA, sigA);
    wire isSigNaNA;
    isSigNaNRecFN#(expWidth, sigWidth) isSigNaN_a(a, isSigNaNA);
    wire isNaNB, isInfB, isZeroB, signB;
    wire signed [(expWidth + 1):0] sExpB;
    wire [sigWidth:0] sigB;
    recFNToRawFN#(expWidth, sigWidth)
        recFNToRawFN_b(b, isNaNB, isInfB, isZeroB, signB, sExpB, sigB);
    wire isSigNaNB;
    isSigNaNRecFN#(expWidth, sigWidth) isSigNaN_b(b, isSigNaNB);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire notSigNaN_invalidExc = (isInfA && isZeroB) || (isZeroA && isInfB);
    wire notNaN_isInfOut = isInfA || isInfB;
    wire notNaN_isZeroOut = isZeroA || isZeroB;
    wire notNaN_signOut = signA ^ signB;
    wire signed [(expWidth + 1):0] common_sExpOut =
        sExpA + sExpB - (1<<expWidth);
    wire [(sigWidth*2 - 1):0] common_sigOut = sigA * sigB;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    assign invalidExc = isSigNaNA || isSigNaNB || notSigNaN_invalidExc;
    assign out_isInf = notNaN_isInfOut;
    assign out_isZero = notNaN_isZeroOut;
    assign out_sExp = common_sExpOut;
`ifdef HardFloat_propagateNaNPayloads
    assign out_isNaN = isNaNA || isNaNB || notSigNaN_invalidExc;
    wire signNaN;
    wire [(sigWidth - 2):0] fractNaN;
    propagateFloatNaN_mul#(sigWidth)
        propagateNaN(
            control,
            isNaNA,
            signA,
            sigA[(sigWidth - 2):0],
            isNaNB,
            signB,
            sigB[(sigWidth - 2):0],
            signNaN,
            fractNaN
        );
    assign out_sign = out_isNaN ? signNaN : notNaN_signOut;
    assign out_sig =
        out_isNaN ? {1'b1, fractNaN}<<(sigWidth - 1) : common_sigOut;
`else
    assign out_isNaN = isNaNA || isNaNB;
    assign out_sign = notNaN_signOut;
    assign out_sig = common_sigOut;
`endif

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    mulRecFNToRaw#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(`floatControlWidth - 1):0] control,
        input [(expWidth + sigWidth):0] a,
        input [(expWidth + sigWidth):0] b,
        output invalidExc,
        output out_isNaN,
        output out_isInf,
        output out_isZero,
        output out_sign,
        output signed [(expWidth + 1):0] out_sExp,
        output [(sigWidth + 2):0] out_sig
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaNA, isInfA, isZeroA, signA;
    wire signed [(expWidth + 1):0] sExpA;
    wire [sigWidth:0] sigA;
    recFNToRawFN#(expWidth, sigWidth)
        recFNToRawFN_a(a, isNaNA, isInfA, isZeroA, signA, sExpA, sigA);
    wire isSigNaNA;
    isSigNaNRecFN#(expWidth, sigWidth) isSigNaN_a(a, isSigNaNA);
    wire isNaNB, isInfB, isZeroB, signB;
    wire signed [(expWidth + 1):0] sExpB;
    wire [sigWidth:0] sigB;
    recFNToRawFN#(expWidth, sigWidth)
        recFNToRawFN_b(b, isNaNB, isInfB, isZeroB, signB, sExpB, sigB);
    wire isSigNaNB;
    isSigNaNRecFN#(expWidth, sigWidth) isSigNaN_b(b, isSigNaNB);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire notSigNaN_invalidExc = (isInfA && isZeroB) || (isZeroA && isInfB);
    wire notNaN_isInfOut = isInfA || isInfB;
    wire notNaN_isZeroOut = isZeroA || isZeroB;
    wire notNaN_signOut = signA ^ signB;
    wire signed [(expWidth + 1):0] common_sExpOut =
        sExpA + sExpB - (1<<expWidth);
    wire [(sigWidth*2 - 1):0] sigProd = sigA * sigB;
    wire [(sigWidth + 2):0] common_sigOut =
        {sigProd[(sigWidth*2 - 1):(sigWidth - 2)], |sigProd[(sigWidth - 3):0]};
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    assign invalidExc = isSigNaNA || isSigNaNB || notSigNaN_invalidExc;
    assign out_isInf = notNaN_isInfOut;
    assign out_isZero = notNaN_isZeroOut;
    assign out_sExp = common_sExpOut;
`ifdef HardFloat_propagateNaNPayloads
    assign out_isNaN = isNaNA || isNaNB || notSigNaN_invalidExc;
    wire signNaN;
    wire [(sigWidth - 2):0] fractNaN;
    propagateFloatNaN_mul#(sigWidth)
        propagateNaN(
            control,
            isNaNA,
            signA,
            sigA[(sigWidth - 2):0],
            isNaNB,
            signB,
            sigB[(sigWidth - 2):0],
            signNaN,
            fractNaN
        );
    assign out_sign = out_isNaN ? signNaN : notNaN_signOut;
    assign out_sig = out_isNaN ? {1'b1, fractNaN, 2'b00} : common_sigOut;
`else
    assign out_isNaN = isNaNA || isNaNB;
    assign out_sign = notNaN_signOut;
    assign out_sig = common_sigOut;
`endif

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    mulRecFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(`floatControlWidth - 1):0] control,
        input [(expWidth + sigWidth):0] a,
        input [(expWidth + sigWidth):0] b,
        input [2:0] roundingMode,
        output [(expWidth + sigWidth):0] out,
        output [4:0] exceptionFlags
    );

    wire invalidExc, out_isNaN, out_isInf, out_isZero, out_sign;
    wire signed [(expWidth + 1):0] out_sExp;
    wire [(sigWidth + 2):0] out_sig;
    mulRecFNToRaw#(expWidth, sigWidth)
        mulRecFNToRaw(
            control,
            a,
            b,
            invalidExc,
            out_isNaN,
            out_isInf,
            out_isZero,
            out_sign,
            out_sExp,
            out_sig
        );
    roundRawFNToRecFN#(expWidth, sigWidth, 0)
        roundRawOut(
            control,
            invalidExc,
            1'b0,
            out_isNaN,
            out_isInf,
            out_isZero,
            out_sign,
            out_sExp,
            out_sig,
            roundingMode,
            out,
            exceptionFlags
        );

endmodule

`endif /* __HARDFLOAT_MULRECFN_V__ */

`endif /* MULRECFN */

//-----------------------------------------------------------
// Wrapper of placeholder MulRecFN__expWidth_9__sigWidth_23
//-----------------------------------------------------------

`ifndef MULRECFN__EXPWIDTH_9__SIGWIDTH_23
`define MULRECFN__EXPWIDTH_9__SIGWIDTH_23

module MulRecFN__expWidth_9__sigWidth_23
(
  input logic reset,
  input logic clk,
  input logic [33-1:0] a ,
  input logic [33-1:0] b ,
  input logic [1-1:0] control ,
  output logic [5-1:0] exceptionFlags ,
  output logic [33-1:0] out ,
  input logic [3-1:0] roundingMode 
);
  mulRecFN
  #(
    .expWidth( 9 ),
    .sigWidth( 23 )
  ) v
  (
    .a( a ),
    .b( b ),
    .control( control ),
    .exceptionFlags( exceptionFlags ),
    .out( out ),
    .roundingMode( roundingMode )
  );
endmodule

`endif /* MULRECFN__EXPWIDTH_9__SIGWIDTH_23 */



// PyMTL VerilogPlaceholder RecFNToFN Definition
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/RecFNToFNRTL.py

//***********************************************************
// Pickled source file of placeholder RecFNToFN__expWidth_9__sigWidth_23
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder RecFNToFN
//-----------------------------------------------------------

`ifndef RECFNTOFN
`define RECFNTOFN

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component RecFNToFN__expWidth_9__sigWidth_23.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!

`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_primitives.v" 0
`ifndef __HARDFLOAT_PRIMITIVES_VI__
`define __HARDFLOAT_PRIMITIVES_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    reverse#(parameter width = 1) (
        input [(width - 1):0] in, output [(width - 1):0] out
    );

    genvar ix;
    generate
        for (ix = 0; ix < width; ix = ix + 1) begin :Bit
            assign out[ix] = in[width - 1 - ix];
        end
    endgenerate

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    lowMaskHiLo#(
        parameter inWidth = 1,
        parameter topBound = 1,
        parameter bottomBound = 0
    ) (
        input [(inWidth - 1):0] in,
        output [(topBound - bottomBound - 1):0] out
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam numInVals = 1<<inWidth;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [numInVals:0] c;
    assign c[numInVals] = 1;
    assign c[(numInVals - 1):0] = 0;
    wire [(topBound - bottomBound - 1):0] reverseOut =
        (c>>>in)>>(numInVals - topBound);
    reverse#(topBound - bottomBound) reverse(reverseOut, out);

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    lowMaskLoHi#(
        parameter inWidth = 1,
        parameter topBound = 0,
        parameter bottomBound = 1
    ) (
        input [(inWidth - 1):0] in,
        output [(bottomBound - topBound - 1):0] out
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam numInVals = 1<<inWidth;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [numInVals:0] c;
    assign c[numInVals] = 1;
    assign c[(numInVals - 1):0] = 0;
    wire [(bottomBound - topBound - 1):0] reverseOut =
        (c>>>~in)>>(topBound + 1);
    reverse#(bottomBound - topBound) reverse(reverseOut, out);

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    countLeadingZeros#(parameter inWidth = 1, parameter countWidth = 1) (
        input [(inWidth - 1):0] in, output [(countWidth - 1):0] count
    );

    wire [(inWidth - 1):0] reverseIn;
    reverse#(inWidth) reverse_in(in, reverseIn);
    wire [inWidth:0] oneLeastReverseIn =
        {1'b1, reverseIn} & ({1'b0, ~reverseIn} + 1);
    genvar ix;
    generate
        for (ix = 0; ix <= inWidth; ix = ix + 1) begin :Bit
            wire [(countWidth - 1):0] countSoFar;
            if (ix == 0) begin
                assign countSoFar = 0;
            end else begin
                assign countSoFar =
                    Bit[ix - 1].countSoFar | (oneLeastReverseIn[ix] ? ix : 0);
                if (ix == inWidth) assign count = countSoFar;
            end
        end
    endgenerate

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    compressBy2#(parameter inWidth = 1) (
        input [(inWidth - 1):0] in, output [((inWidth - 1)/2):0] out
    );

    localparam maxBitNumReduced = (inWidth - 1)/2;
    genvar ix;
    generate
        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit
            assign out[ix] = |in[(ix*2 + 1):ix*2];
        end
    endgenerate
    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*2];

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    compressBy4#(parameter inWidth = 1) (
        input [(inWidth - 1):0] in, output [(inWidth - 1)/4:0] out
    );

    localparam maxBitNumReduced = (inWidth - 1)/4;
    genvar ix;
    generate
        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit
            assign out[ix] = |in[(ix*4 + 3):ix*4];
        end
    endgenerate
    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*4];

endmodule

`endif /* __HARDFLOAT_PRIMITIVES_VI__ */
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/isSigNaNRecFN.v" 0
`ifndef __HARDFLOAT_ISSIGNANRECFN_V__
`define __HARDFLOAT_ISSIGNANRECFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    isSigNaNRecFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in, output isSigNaN
    );

    wire isNaN =
        (in[(expWidth + sigWidth - 1):(expWidth + sigWidth - 3)] == 'b111);
    assign isSigNaN = isNaN && !in[sigWidth - 2];

endmodule

`endif /* __HARDFLOAT_ISSIGNANRECFN_V__ */
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
`ifndef __HARDFLOAT_RAWFN_VI__
`define __HARDFLOAT_RAWFN_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_consts.vi" 0
`ifndef __HARDFLOAT_CONSTS_VI__
`define __HARDFLOAT_CONSTS_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define round_near_even   3'b000
`define round_minMag      3'b001
`define round_min         3'b010
`define round_max         3'b011
`define round_near_maxMag 3'b100
`define round_odd         3'b110

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define floatControlWidth 1
`define flControl_tininessBeforeRounding 1'b0
`define flControl_tininessAfterRounding  1'b1

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flRoundOpt_sigMSBitAlwaysZero  1
`define flRoundOpt_subnormsAlwaysExact 2
`define flRoundOpt_neverUnderflows     4
`define flRoundOpt_neverOverflows      8

`endif /* __HARDFLOAT_CONSTS_VI__ */

`line 40 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_specialize.vi" 0
`ifndef __HARDFLOAT_SPECIALIZE_VI__
`define __HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    iNFromException#(parameter width = 1) (
        input signedOut,
        input isNaN,
        input sign,
        output [(width - 1):0] out
    );

    wire maxInt = isNaN || !sign;
    assign out = {signedOut ^ maxInt, {(width - 1){maxInt}}};

endmodule

`endif /* __HARDFLOAT_SPECIALIZE_VI__ */

`line 41 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0

/* ===================== Adding some extra include files ================ */
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/RISCV/HardFloat_specialize.vi" 0
`ifndef __RISCV_HARDFLOAT_SPECIALIZE_VI__
`define __RISCV_HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flControl_default `flControl_tininessAfterRounding

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
//`define HardFloat_propagateNaNPayloads

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define HardFloat_signDefaultNaN 0
`define HardFloat_fractDefaultNaN(sigWidth) {1'b1, {((sigWidth) - 2){1'b0}}}

`endif /* __RISCV_HARDFLOAT_SPECIALIZE_VI__ */

`line 44 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
/* ====================================================================== */

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    recFNToRawFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in,
        output isNaN,
        output isInf,
        output isZero,
        output sign,
        output signed [(expWidth + 1):0] sExp,
        output [sigWidth:0] sig
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [expWidth:0] exp;
    wire [(sigWidth - 2):0] fract;
    assign {sign, exp, fract} = in;
    wire isSpecial = (exp>>(expWidth - 1) == 'b11);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    assign isNaN = isSpecial &&  exp[expWidth - 2];
    assign isInf = isSpecial && !exp[expWidth - 2];
    assign isZero = (exp>>(expWidth - 2) == 'b000);
    assign sExp = exp;
    assign sig = {1'b0, !isZero, fract};

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    roundAnyRawFNToRecFN#(
        parameter inExpWidth = 3,
        parameter inSigWidth = 3,
        parameter outExpWidth = 3,
        parameter outSigWidth = 3,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,     // overrides 'infiniteExc' and 'in_*' inputs
        input infiniteExc,    // overrides 'in_*' inputs except 'in_sign'
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(inExpWidth + 1):0] in_sExp,   // limited range allowed
        input [inSigWidth:0] in_sig,
        input [2:0] roundingMode,
        output [(outExpWidth + outSigWidth):0] out,
        output [4:0] exceptionFlags
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam sigMSBitAlwaysZero =
        ((options & `flRoundOpt_sigMSBitAlwaysZero) != 0);
    localparam effectiveInSigWidth =
        sigMSBitAlwaysZero ? inSigWidth : inSigWidth + 1;
    localparam neverUnderflows =
        ((options
              & (`flRoundOpt_neverUnderflows
                     | `flRoundOpt_subnormsAlwaysExact))
             != 0)
            || (inExpWidth < outExpWidth);
    localparam neverOverflows =
        ((options & `flRoundOpt_neverOverflows) != 0)
            || (inExpWidth < outExpWidth);
    localparam adjustedExpWidth =
          (inExpWidth < outExpWidth) ? outExpWidth + 1
        : (inExpWidth == outExpWidth) ? inExpWidth + 2
        : inExpWidth + 3;
    localparam outNaNExp = 7<<(outExpWidth - 2);
    localparam outInfExp = 6<<(outExpWidth - 2);
    localparam outMaxFiniteExp = outInfExp - 1;
    localparam outMinNormExp = (1<<(outExpWidth - 1)) + 2;
    localparam outMinNonzeroExp = outMinNormExp - outSigWidth + 1;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire roundingMode_near_even   = (roundingMode == `round_near_even);
    wire roundingMode_minMag      = (roundingMode == `round_minMag);
    wire roundingMode_min         = (roundingMode == `round_min);
    wire roundingMode_max         = (roundingMode == `round_max);
    wire roundingMode_near_maxMag = (roundingMode == `round_near_maxMag);
    wire roundingMode_odd         = (roundingMode == `round_odd);
    wire roundMagUp =
        (roundingMode_min && in_sign) || (roundingMode_max && !in_sign);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaNOut = invalidExc || (!infiniteExc && in_isNaN);
`ifdef HardFloat_propagateNaNPayloads
    wire propagateNaNPayload = isNaNOut;
`else
    wire propagateNaNPayload = 0;
`endif
    wire signed [(adjustedExpWidth - 1):0] sAdjustedExp =
        in_sExp + ((1<<outExpWidth) - (1<<inExpWidth));
    wire [(outSigWidth + 2):0] adjustedSig;
    generate
        if (inSigWidth <= outSigWidth + 2) begin
            assign adjustedSig = in_sig<<(outSigWidth - inSigWidth + 2);
        end else begin
            assign adjustedSig =
                {in_sig[inSigWidth:(inSigWidth - outSigWidth - 1)],
                 |in_sig[(inSigWidth - outSigWidth - 2):0]};
        end
    endgenerate
    wire doShiftSigDown1 =
        sigMSBitAlwaysZero ? 0 : adjustedSig[outSigWidth + 2];
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [outExpWidth:0] common_expOut;
    wire [(outSigWidth - 2):0] common_fractOut;
    wire common_overflow, common_totalUnderflow, common_underflow;
    wire common_inexact;
    generate
        if (
            neverOverflows && neverUnderflows
                && (effectiveInSigWidth <= outSigWidth)
        ) begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_expOut = sAdjustedExp + doShiftSigDown1;
            assign common_fractOut =
                doShiftSigDown1 ? adjustedSig>>3 : adjustedSig>>2;
            assign common_overflow       = 0;
            assign common_totalUnderflow = 0;
            assign common_underflow      = 0;
            assign common_inexact        = 0;
        end else begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire [(outSigWidth + 2):0] roundMask;
            if (neverUnderflows) begin
                assign roundMask = {doShiftSigDown1, 2'b11};
            end else begin
                wire [outSigWidth:0] roundMask_main;
                lowMaskLoHi#(
                    outExpWidth + 1,
                    outMinNormExp - outSigWidth - 1,
                    outMinNormExp
                ) lowMask_roundMask(
                        sAdjustedExp[outExpWidth:0]
                            | (propagateNaNPayload ? 1'b1<<outExpWidth : 1'b0),
                        roundMask_main
                    );
                assign roundMask = {roundMask_main | doShiftSigDown1, 2'b11};
            end
            wire [(outSigWidth + 2):0] shiftedRoundMask = roundMask>>1;
            wire [(outSigWidth + 2):0] roundPosMask =
                ~shiftedRoundMask & roundMask;
            wire roundPosBit =
                (|(adjustedSig[(outSigWidth + 2):3]
                       & roundPosMask[(outSigWidth + 2):3]))
                    || ((|(adjustedSig[2:0] & roundPosMask[2:0]))
                            && !propagateNaNPayload);
            wire anyRoundExtra =
                (|(adjustedSig[(outSigWidth + 2):3]
                       & shiftedRoundMask[(outSigWidth + 2):3]))
                    || ((|(adjustedSig[2:0] & shiftedRoundMask[2:0]))
                            && !propagateNaNPayload);
            wire anyRound = roundPosBit || anyRoundExtra;
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire roundIncr =
                ((roundingMode_near_even || roundingMode_near_maxMag)
                     && roundPosBit)
                    || (roundMagUp && anyRound);
            wire [(outSigWidth + 1):0] roundedSig =
                roundIncr
                    ? (((adjustedSig | roundMask)>>2) + 1)
                          & ~(roundingMode_near_even && roundPosBit
                                  && !anyRoundExtra
                                  ? roundMask>>1 : 0)
                    : (adjustedSig & ~roundMask)>>2
                          | (roundingMode_odd && anyRound
                                 ? roundPosMask>>1 : 0);
            wire signed [adjustedExpWidth:0] sExtAdjustedExp = sAdjustedExp;
            wire signed [adjustedExpWidth:0] sRoundedExp =
                sExtAdjustedExp + (roundedSig>>outSigWidth);
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_expOut = sRoundedExp;
            assign common_fractOut =
                doShiftSigDown1 ? roundedSig>>1 : roundedSig;
            assign common_overflow =
                neverOverflows ? 0 : (sRoundedExp>>>(outExpWidth - 1) >= 3);
            assign common_totalUnderflow =
                neverUnderflows ? 0 : (sRoundedExp < outMinNonzeroExp);
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire unboundedRange_roundPosBit =
                doShiftSigDown1 ? adjustedSig[2] : adjustedSig[1];
            wire unboundedRange_anyRound =
                (doShiftSigDown1 && adjustedSig[2]) || (|adjustedSig[1:0]);
            wire unboundedRange_roundIncr =
                ((roundingMode_near_even || roundingMode_near_maxMag)
                     && unboundedRange_roundPosBit)
                    || (roundMagUp && unboundedRange_anyRound);
            wire roundCarry =
                doShiftSigDown1
                    ? roundedSig[outSigWidth + 1] : roundedSig[outSigWidth];
            assign common_underflow =
                neverUnderflows ? 0
                    : common_totalUnderflow
                          || (anyRound && (sAdjustedExp>>>outExpWidth <= 0)
                                  && (doShiftSigDown1
                                          ? roundMask[3] : roundMask[2])
                                  && !(((control
                                           & `flControl_tininessAfterRounding)
                                            != 0)
                                           && !(doShiftSigDown1 ? roundMask[4]
                                                    : roundMask[3])
                                           && roundCarry && roundPosBit
                                           && unboundedRange_roundIncr));
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_inexact = common_totalUnderflow || anyRound;
        end
    endgenerate
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire notNaN_isSpecialInfOut = infiniteExc || in_isInf;
    wire commonCase = !isNaNOut && !notNaN_isSpecialInfOut && !in_isZero;
    wire overflow  = commonCase && common_overflow;
    wire underflow = commonCase && common_underflow;
    wire inexact = overflow || (commonCase && common_inexact);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire overflow_roundMagUp =
        roundingMode_near_even || roundingMode_near_maxMag || roundMagUp;
    wire pegMinNonzeroMagOut =
        commonCase && common_totalUnderflow
            && (roundMagUp || roundingMode_odd);
    wire pegMaxFiniteMagOut = overflow && !overflow_roundMagUp;
    wire notNaN_isInfOut =
        notNaN_isSpecialInfOut || (overflow && overflow_roundMagUp);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
`ifdef HardFloat_propagateNaNPayloads
    wire signOut = in_sign;
`else
    wire signOut = isNaNOut ? `HardFloat_signDefaultNaN : in_sign;
`endif
    wire [outExpWidth:0] expOut =
        (common_expOut
             & ~(in_isZero || common_totalUnderflow ? 7<<(outExpWidth - 2) : 0)
             & ~(pegMinNonzeroMagOut               ? ~outMinNonzeroExp    : 0)
             & ~(pegMaxFiniteMagOut                ? 1<<(outExpWidth - 1) : 0)
             & ~(notNaN_isInfOut                   ? 1<<(outExpWidth - 2) : 0))
            | (pegMinNonzeroMagOut ? outMinNonzeroExp : 0)
            | (pegMaxFiniteMagOut  ? outMaxFiniteExp  : 0)
            | (notNaN_isInfOut     ? outInfExp        : 0)
            | (isNaNOut            ? outNaNExp        : 0);
`ifdef HardFloat_propagateNaNPayloads
    wire [(outSigWidth - 2):0] fractOut =
        {isNaNOut
             || (!in_isZero && !common_totalUnderflow
                     && common_fractOut[outSigWidth - 2]),
         isNaNOut || (!in_isZero && !common_totalUnderflow)
             ? common_fractOut[(outSigWidth - 3):0] : 1'b0}
            | {(outSigWidth - 1){pegMaxFiniteMagOut}};
`else
    wire [(outSigWidth - 2):0] fractOut =
          (isNaNOut ? `HardFloat_fractDefaultNaN(outSigWidth) : 0)
        | (!in_isZero && !common_totalUnderflow
               ? common_fractOut & `HardFloat_fractDefaultNaN(outSigWidth) : 0)
        | (!isNaNOut && !in_isZero && !common_totalUnderflow
               ? common_fractOut & ~`HardFloat_fractDefaultNaN(outSigWidth)
               : 0)
        | {(outSigWidth - 1){pegMaxFiniteMagOut}};
`endif
    assign out = {signOut, expOut, fractOut};
    assign exceptionFlags =
        {invalidExc, infiniteExc, overflow, underflow, inexact};

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    roundRawFNToRecFN#(
        parameter expWidth = 3,
        parameter sigWidth = 3,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,     // overrides 'infiniteExc' and 'in_*' inputs
        input infiniteExc,    // overrides 'in_*' inputs except 'in_sign'
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(expWidth + 1):0] in_sExp,   // limited range allowed
        input [(sigWidth + 2):0] in_sig,
        input [2:0] roundingMode,
        output [(expWidth + sigWidth):0] out,
        output [4:0] exceptionFlags
    );

    roundAnyRawFNToRecFN#(expWidth, sigWidth + 2, expWidth, sigWidth, options)
        roundAnyRawFNToRecFN(
            control,
            invalidExc,
            infiniteExc,
            in_isNaN,
            in_isInf,
            in_isZero,
            in_sign,
            in_sExp,
            in_sig,
            roundingMode,
            out,
            exceptionFlags
        );

endmodule

`endif /* __HARDFLOAT_RAWFN_VI__ */
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/recFNToRecFN.v" 0
`ifndef __HARDFLOAT_RECFNTORECFN_V__
`define __HARDFLOAT_RECFNTORECFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_consts.vi" 0
`ifndef __HARDFLOAT_CONSTS_VI__
`define __HARDFLOAT_CONSTS_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define round_near_even   3'b000
`define round_minMag      3'b001
`define round_min         3'b010
`define round_max         3'b011
`define round_near_maxMag 3'b100
`define round_odd         3'b110

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define floatControlWidth 1
`define flControl_tininessBeforeRounding 1'b0
`define flControl_tininessAfterRounding  1'b1

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flRoundOpt_sigMSBitAlwaysZero  1
`define flRoundOpt_subnormsAlwaysExact 2
`define flRoundOpt_neverUnderflows     4
`define flRoundOpt_neverOverflows      8

`endif /* __HARDFLOAT_CONSTS_VI__ */

`line 40 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/recFNToRecFN.v" 0
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_specialize.vi" 0
`ifndef __HARDFLOAT_SPECIALIZE_VI__
`define __HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    iNFromException#(parameter width = 1) (
        input signedOut,
        input isNaN,
        input sign,
        output [(width - 1):0] out
    );

    wire maxInt = isNaN || !sign;
    assign out = {signedOut ^ maxInt, {(width - 1){maxInt}}};

endmodule

`endif /* __HARDFLOAT_SPECIALIZE_VI__ */

`line 41 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/recFNToRecFN.v" 0

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    recFNToRecFN#(
        parameter inExpWidth = 3,
        parameter inSigWidth = 3,
        parameter outExpWidth = 3,
        parameter outSigWidth = 3
    ) (
        input [(`floatControlWidth - 1):0] control,
        input [(inExpWidth + inSigWidth):0] in,
        input [2:0] roundingMode,
        output [(outExpWidth + outSigWidth):0] out,
        output [4:0] exceptionFlags
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaN, isInf, isZero, sign;
    wire signed [(inExpWidth + 1):0] sExpIn;
    wire [inSigWidth:0] sigIn;
    recFNToRawFN#(inExpWidth, inSigWidth)
        inToRawIn(in, isNaN, isInf, isZero, sign, sExpIn, sigIn);
    wire isSigNaN;
    isSigNaNRecFN#(inExpWidth, inSigWidth) isSigNaNIn(in, isSigNaN);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    generate
        if ((inExpWidth == outExpWidth) && (inSigWidth <= outSigWidth)) begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire [(outExpWidth + outSigWidth):0] tentativeOut =
                in<<(outSigWidth - inSigWidth);
`ifdef HardFloat_propagateNaNPayloads
            assign out = tentativeOut | isNaN<<(outSigWidth - 2);
`else
            assign out =
                isNaN
                    ? {`HardFloat_signDefaultNaN, 3'b111}
                          <<(outExpWidth + outSigWidth - 3)
                          | `HardFloat_fractDefaultNaN(outSigWidth)
                    : tentativeOut;
`endif
            assign exceptionFlags = {isSigNaN, 4'b0000};
        end else begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            roundAnyRawFNToRecFN#(
                inExpWidth,
                inSigWidth,
                outExpWidth,
                outSigWidth,
                `flRoundOpt_sigMSBitAlwaysZero
            ) roundRawInToOut(
                    control,
                    isSigNaN,
                    1'b0,
                    isNaN,
                    isInf,
                    isZero,
                    sign,
                    sExpIn,
                    sigIn,
                    roundingMode,
                    out,
                    exceptionFlags
                );
        end
    endgenerate

endmodule

`endif /* __HARDFLOAT_RECFNTORECFN_V__ */
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_specialize.vi" 0
`ifndef __HARDFLOAT_SPECIALIZE_VI__
`define __HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    iNFromException#(parameter width = 1) (
        input signedOut,
        input isNaN,
        input sign,
        output [(width - 1):0] out
    );

    wire maxInt = isNaN || !sign;
    assign out = {signedOut ^ maxInt, {(width - 1){maxInt}}};

endmodule

`endif /* __HARDFLOAT_SPECIALIZE_VI__ */

// End of all v_libs files for component RecFNToFN__expWidth_9__sigWidth_23

`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/recFNToFN.v" 0
`ifndef __HARDFLOAT_RECFNTOFN_V__
`define __HARDFLOAT_RECFNTOFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/* ============= Added section to include some files ================== */
// verilator lint_off MODDUP
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/includeFile.v" 0
/* ============= Added section to include some files ================== */
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
`ifndef __HARDFLOAT_RAWFN_VI__
`define __HARDFLOAT_RAWFN_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_consts.vi" 0
`ifndef __HARDFLOAT_CONSTS_VI__
`define __HARDFLOAT_CONSTS_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define round_near_even   3'b000
`define round_minMag      3'b001
`define round_min         3'b010
`define round_max         3'b011
`define round_near_maxMag 3'b100
`define round_odd         3'b110

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define floatControlWidth 1
`define flControl_tininessBeforeRounding 1'b0
`define flControl_tininessAfterRounding  1'b1

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flRoundOpt_sigMSBitAlwaysZero  1
`define flRoundOpt_subnormsAlwaysExact 2
`define flRoundOpt_neverUnderflows     4
`define flRoundOpt_neverOverflows      8

`endif /* __HARDFLOAT_CONSTS_VI__ */

`line 40 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_specialize.vi" 0
`ifndef __HARDFLOAT_SPECIALIZE_VI__
`define __HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    iNFromException#(parameter width = 1) (
        input signedOut,
        input isNaN,
        input sign,
        output [(width - 1):0] out
    );

    wire maxInt = isNaN || !sign;
    assign out = {signedOut ^ maxInt, {(width - 1){maxInt}}};

endmodule

`endif /* __HARDFLOAT_SPECIALIZE_VI__ */

`line 41 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0

/* ===================== Adding some extra include files ================ */
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/RISCV/HardFloat_specialize.vi" 0
`ifndef __RISCV_HARDFLOAT_SPECIALIZE_VI__
`define __RISCV_HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flControl_default `flControl_tininessAfterRounding

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
//`define HardFloat_propagateNaNPayloads

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define HardFloat_signDefaultNaN 0
`define HardFloat_fractDefaultNaN(sigWidth) {1'b1, {((sigWidth) - 2){1'b0}}}

`endif /* __RISCV_HARDFLOAT_SPECIALIZE_VI__ */

`line 44 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
/* ====================================================================== */

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    recFNToRawFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in,
        output isNaN,
        output isInf,
        output isZero,
        output sign,
        output signed [(expWidth + 1):0] sExp,
        output [sigWidth:0] sig
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [expWidth:0] exp;
    wire [(sigWidth - 2):0] fract;
    assign {sign, exp, fract} = in;
    wire isSpecial = (exp>>(expWidth - 1) == 'b11);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    assign isNaN = isSpecial &&  exp[expWidth - 2];
    assign isInf = isSpecial && !exp[expWidth - 2];
    assign isZero = (exp>>(expWidth - 2) == 'b000);
    assign sExp = exp;
    assign sig = {1'b0, !isZero, fract};

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    roundAnyRawFNToRecFN#(
        parameter inExpWidth = 3,
        parameter inSigWidth = 3,
        parameter outExpWidth = 3,
        parameter outSigWidth = 3,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,     // overrides 'infiniteExc' and 'in_*' inputs
        input infiniteExc,    // overrides 'in_*' inputs except 'in_sign'
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(inExpWidth + 1):0] in_sExp,   // limited range allowed
        input [inSigWidth:0] in_sig,
        input [2:0] roundingMode,
        output [(outExpWidth + outSigWidth):0] out,
        output [4:0] exceptionFlags
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam sigMSBitAlwaysZero =
        ((options & `flRoundOpt_sigMSBitAlwaysZero) != 0);
    localparam effectiveInSigWidth =
        sigMSBitAlwaysZero ? inSigWidth : inSigWidth + 1;
    localparam neverUnderflows =
        ((options
              & (`flRoundOpt_neverUnderflows
                     | `flRoundOpt_subnormsAlwaysExact))
             != 0)
            || (inExpWidth < outExpWidth);
    localparam neverOverflows =
        ((options & `flRoundOpt_neverOverflows) != 0)
            || (inExpWidth < outExpWidth);
    localparam adjustedExpWidth =
          (inExpWidth < outExpWidth) ? outExpWidth + 1
        : (inExpWidth == outExpWidth) ? inExpWidth + 2
        : inExpWidth + 3;
    localparam outNaNExp = 7<<(outExpWidth - 2);
    localparam outInfExp = 6<<(outExpWidth - 2);
    localparam outMaxFiniteExp = outInfExp - 1;
    localparam outMinNormExp = (1<<(outExpWidth - 1)) + 2;
    localparam outMinNonzeroExp = outMinNormExp - outSigWidth + 1;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire roundingMode_near_even   = (roundingMode == `round_near_even);
    wire roundingMode_minMag      = (roundingMode == `round_minMag);
    wire roundingMode_min         = (roundingMode == `round_min);
    wire roundingMode_max         = (roundingMode == `round_max);
    wire roundingMode_near_maxMag = (roundingMode == `round_near_maxMag);
    wire roundingMode_odd         = (roundingMode == `round_odd);
    wire roundMagUp =
        (roundingMode_min && in_sign) || (roundingMode_max && !in_sign);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaNOut = invalidExc || (!infiniteExc && in_isNaN);
`ifdef HardFloat_propagateNaNPayloads
    wire propagateNaNPayload = isNaNOut;
`else
    wire propagateNaNPayload = 0;
`endif
    wire signed [(adjustedExpWidth - 1):0] sAdjustedExp =
        in_sExp + ((1<<outExpWidth) - (1<<inExpWidth));
    wire [(outSigWidth + 2):0] adjustedSig;
    generate
        if (inSigWidth <= outSigWidth + 2) begin
            assign adjustedSig = in_sig<<(outSigWidth - inSigWidth + 2);
        end else begin
            assign adjustedSig =
                {in_sig[inSigWidth:(inSigWidth - outSigWidth - 1)],
                 |in_sig[(inSigWidth - outSigWidth - 2):0]};
        end
    endgenerate
    wire doShiftSigDown1 =
        sigMSBitAlwaysZero ? 0 : adjustedSig[outSigWidth + 2];
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [outExpWidth:0] common_expOut;
    wire [(outSigWidth - 2):0] common_fractOut;
    wire common_overflow, common_totalUnderflow, common_underflow;
    wire common_inexact;
    generate
        if (
            neverOverflows && neverUnderflows
                && (effectiveInSigWidth <= outSigWidth)
        ) begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_expOut = sAdjustedExp + doShiftSigDown1;
            assign common_fractOut =
                doShiftSigDown1 ? adjustedSig>>3 : adjustedSig>>2;
            assign common_overflow       = 0;
            assign common_totalUnderflow = 0;
            assign common_underflow      = 0;
            assign common_inexact        = 0;
        end else begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire [(outSigWidth + 2):0] roundMask;
            if (neverUnderflows) begin
                assign roundMask = {doShiftSigDown1, 2'b11};
            end else begin
                wire [outSigWidth:0] roundMask_main;
                lowMaskLoHi#(
                    outExpWidth + 1,
                    outMinNormExp - outSigWidth - 1,
                    outMinNormExp
                ) lowMask_roundMask(
                        sAdjustedExp[outExpWidth:0]
                            | (propagateNaNPayload ? 1'b1<<outExpWidth : 1'b0),
                        roundMask_main
                    );
                assign roundMask = {roundMask_main | doShiftSigDown1, 2'b11};
            end
            wire [(outSigWidth + 2):0] shiftedRoundMask = roundMask>>1;
            wire [(outSigWidth + 2):0] roundPosMask =
                ~shiftedRoundMask & roundMask;
            wire roundPosBit =
                (|(adjustedSig[(outSigWidth + 2):3]
                       & roundPosMask[(outSigWidth + 2):3]))
                    || ((|(adjustedSig[2:0] & roundPosMask[2:0]))
                            && !propagateNaNPayload);
            wire anyRoundExtra =
                (|(adjustedSig[(outSigWidth + 2):3]
                       & shiftedRoundMask[(outSigWidth + 2):3]))
                    || ((|(adjustedSig[2:0] & shiftedRoundMask[2:0]))
                            && !propagateNaNPayload);
            wire anyRound = roundPosBit || anyRoundExtra;
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire roundIncr =
                ((roundingMode_near_even || roundingMode_near_maxMag)
                     && roundPosBit)
                    || (roundMagUp && anyRound);
            wire [(outSigWidth + 1):0] roundedSig =
                roundIncr
                    ? (((adjustedSig | roundMask)>>2) + 1)
                          & ~(roundingMode_near_even && roundPosBit
                                  && !anyRoundExtra
                                  ? roundMask>>1 : 0)
                    : (adjustedSig & ~roundMask)>>2
                          | (roundingMode_odd && anyRound
                                 ? roundPosMask>>1 : 0);
            wire signed [adjustedExpWidth:0] sExtAdjustedExp = sAdjustedExp;
            wire signed [adjustedExpWidth:0] sRoundedExp =
                sExtAdjustedExp + (roundedSig>>outSigWidth);
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_expOut = sRoundedExp;
            assign common_fractOut =
                doShiftSigDown1 ? roundedSig>>1 : roundedSig;
            assign common_overflow =
                neverOverflows ? 0 : (sRoundedExp>>>(outExpWidth - 1) >= 3);
            assign common_totalUnderflow =
                neverUnderflows ? 0 : (sRoundedExp < outMinNonzeroExp);
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire unboundedRange_roundPosBit =
                doShiftSigDown1 ? adjustedSig[2] : adjustedSig[1];
            wire unboundedRange_anyRound =
                (doShiftSigDown1 && adjustedSig[2]) || (|adjustedSig[1:0]);
            wire unboundedRange_roundIncr =
                ((roundingMode_near_even || roundingMode_near_maxMag)
                     && unboundedRange_roundPosBit)
                    || (roundMagUp && unboundedRange_anyRound);
            wire roundCarry =
                doShiftSigDown1
                    ? roundedSig[outSigWidth + 1] : roundedSig[outSigWidth];
            assign common_underflow =
                neverUnderflows ? 0
                    : common_totalUnderflow
                          || (anyRound && (sAdjustedExp>>>outExpWidth <= 0)
                                  && (doShiftSigDown1
                                          ? roundMask[3] : roundMask[2])
                                  && !(((control
                                           & `flControl_tininessAfterRounding)
                                            != 0)
                                           && !(doShiftSigDown1 ? roundMask[4]
                                                    : roundMask[3])
                                           && roundCarry && roundPosBit
                                           && unboundedRange_roundIncr));
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_inexact = common_totalUnderflow || anyRound;
        end
    endgenerate
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire notNaN_isSpecialInfOut = infiniteExc || in_isInf;
    wire commonCase = !isNaNOut && !notNaN_isSpecialInfOut && !in_isZero;
    wire overflow  = commonCase && common_overflow;
    wire underflow = commonCase && common_underflow;
    wire inexact = overflow || (commonCase && common_inexact);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire overflow_roundMagUp =
        roundingMode_near_even || roundingMode_near_maxMag || roundMagUp;
    wire pegMinNonzeroMagOut =
        commonCase && common_totalUnderflow
            && (roundMagUp || roundingMode_odd);
    wire pegMaxFiniteMagOut = overflow && !overflow_roundMagUp;
    wire notNaN_isInfOut =
        notNaN_isSpecialInfOut || (overflow && overflow_roundMagUp);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
`ifdef HardFloat_propagateNaNPayloads
    wire signOut = in_sign;
`else
    wire signOut = isNaNOut ? `HardFloat_signDefaultNaN : in_sign;
`endif
    wire [outExpWidth:0] expOut =
        (common_expOut
             & ~(in_isZero || common_totalUnderflow ? 7<<(outExpWidth - 2) : 0)
             & ~(pegMinNonzeroMagOut               ? ~outMinNonzeroExp    : 0)
             & ~(pegMaxFiniteMagOut                ? 1<<(outExpWidth - 1) : 0)
             & ~(notNaN_isInfOut                   ? 1<<(outExpWidth - 2) : 0))
            | (pegMinNonzeroMagOut ? outMinNonzeroExp : 0)
            | (pegMaxFiniteMagOut  ? outMaxFiniteExp  : 0)
            | (notNaN_isInfOut     ? outInfExp        : 0)
            | (isNaNOut            ? outNaNExp        : 0);
`ifdef HardFloat_propagateNaNPayloads
    wire [(outSigWidth - 2):0] fractOut =
        {isNaNOut
             || (!in_isZero && !common_totalUnderflow
                     && common_fractOut[outSigWidth - 2]),
         isNaNOut || (!in_isZero && !common_totalUnderflow)
             ? common_fractOut[(outSigWidth - 3):0] : 1'b0}
            | {(outSigWidth - 1){pegMaxFiniteMagOut}};
`else
    wire [(outSigWidth - 2):0] fractOut =
          (isNaNOut ? `HardFloat_fractDefaultNaN(outSigWidth) : 0)
        | (!in_isZero && !common_totalUnderflow
               ? common_fractOut & `HardFloat_fractDefaultNaN(outSigWidth) : 0)
        | (!isNaNOut && !in_isZero && !common_totalUnderflow
               ? common_fractOut & ~`HardFloat_fractDefaultNaN(outSigWidth)
               : 0)
        | {(outSigWidth - 1){pegMaxFiniteMagOut}};
`endif
    assign out = {signOut, expOut, fractOut};
    assign exceptionFlags =
        {invalidExc, infiniteExc, overflow, underflow, inexact};

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    roundRawFNToRecFN#(
        parameter expWidth = 3,
        parameter sigWidth = 3,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,     // overrides 'infiniteExc' and 'in_*' inputs
        input infiniteExc,    // overrides 'in_*' inputs except 'in_sign'
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(expWidth + 1):0] in_sExp,   // limited range allowed
        input [(sigWidth + 2):0] in_sig,
        input [2:0] roundingMode,
        output [(expWidth + sigWidth):0] out,
        output [4:0] exceptionFlags
    );

    roundAnyRawFNToRecFN#(expWidth, sigWidth + 2, expWidth, sigWidth, options)
        roundAnyRawFNToRecFN(
            control,
            invalidExc,
            infiniteExc,
            in_isNaN,
            in_isInf,
            in_isZero,
            in_sign,
            in_sExp,
            in_sig,
            roundingMode,
            out,
            exceptionFlags
        );

endmodule

`endif /* __HARDFLOAT_RAWFN_VI__ */

`line 3 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/includeFile.v" 0
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/recFNToRecFN.v" 0
`ifndef __HARDFLOAT_RECFNTORECFN_V__
`define __HARDFLOAT_RECFNTORECFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_consts.vi" 0
`ifndef __HARDFLOAT_CONSTS_VI__
`define __HARDFLOAT_CONSTS_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define round_near_even   3'b000
`define round_minMag      3'b001
`define round_min         3'b010
`define round_max         3'b011
`define round_near_maxMag 3'b100
`define round_odd         3'b110

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define floatControlWidth 1
`define flControl_tininessBeforeRounding 1'b0
`define flControl_tininessAfterRounding  1'b1

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flRoundOpt_sigMSBitAlwaysZero  1
`define flRoundOpt_subnormsAlwaysExact 2
`define flRoundOpt_neverUnderflows     4
`define flRoundOpt_neverOverflows      8

`endif /* __HARDFLOAT_CONSTS_VI__ */

`line 40 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/recFNToRecFN.v" 0
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_specialize.vi" 0
`ifndef __HARDFLOAT_SPECIALIZE_VI__
`define __HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    iNFromException#(parameter width = 1) (
        input signedOut,
        input isNaN,
        input sign,
        output [(width - 1):0] out
    );

    wire maxInt = isNaN || !sign;
    assign out = {signedOut ^ maxInt, {(width - 1){maxInt}}};

endmodule

`endif /* __HARDFLOAT_SPECIALIZE_VI__ */

`line 41 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/recFNToRecFN.v" 0

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    recFNToRecFN#(
        parameter inExpWidth = 3,
        parameter inSigWidth = 3,
        parameter outExpWidth = 3,
        parameter outSigWidth = 3
    ) (
        input [(`floatControlWidth - 1):0] control,
        input [(inExpWidth + inSigWidth):0] in,
        input [2:0] roundingMode,
        output [(outExpWidth + outSigWidth):0] out,
        output [4:0] exceptionFlags
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaN, isInf, isZero, sign;
    wire signed [(inExpWidth + 1):0] sExpIn;
    wire [inSigWidth:0] sigIn;
    recFNToRawFN#(inExpWidth, inSigWidth)
        inToRawIn(in, isNaN, isInf, isZero, sign, sExpIn, sigIn);
    wire isSigNaN;
    isSigNaNRecFN#(inExpWidth, inSigWidth) isSigNaNIn(in, isSigNaN);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    generate
        if ((inExpWidth == outExpWidth) && (inSigWidth <= outSigWidth)) begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire [(outExpWidth + outSigWidth):0] tentativeOut =
                in<<(outSigWidth - inSigWidth);
`ifdef HardFloat_propagateNaNPayloads
            assign out = tentativeOut | isNaN<<(outSigWidth - 2);
`else
            assign out =
                isNaN
                    ? {`HardFloat_signDefaultNaN, 3'b111}
                          <<(outExpWidth + outSigWidth - 3)
                          | `HardFloat_fractDefaultNaN(outSigWidth)
                    : tentativeOut;
`endif
            assign exceptionFlags = {isSigNaN, 4'b0000};
        end else begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            roundAnyRawFNToRecFN#(
                inExpWidth,
                inSigWidth,
                outExpWidth,
                outSigWidth,
                `flRoundOpt_sigMSBitAlwaysZero
            ) roundRawInToOut(
                    control,
                    isSigNaN,
                    1'b0,
                    isNaN,
                    isInf,
                    isZero,
                    sign,
                    sExpIn,
                    sigIn,
                    roundingMode,
                    out,
                    exceptionFlags
                );
        end
    endgenerate

endmodule

`endif /* __HARDFLOAT_RECFNTORECFN_V__ */

`line 4 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/includeFile.v" 0
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/isSigNaNRecFN.v" 0
`ifndef __HARDFLOAT_ISSIGNANRECFN_V__
`define __HARDFLOAT_ISSIGNANRECFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    isSigNaNRecFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in, output isSigNaN
    );

    wire isNaN =
        (in[(expWidth + sigWidth - 1):(expWidth + sigWidth - 3)] == 'b111);
    assign isSigNaN = isNaN && !in[sigWidth - 2];

endmodule

`endif /* __HARDFLOAT_ISSIGNANRECFN_V__ */

`line 5 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/includeFile.v" 0
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_primitives.v" 0
`ifndef __HARDFLOAT_PRIMITIVES_VI__
`define __HARDFLOAT_PRIMITIVES_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    reverse#(parameter width = 1) (
        input [(width - 1):0] in, output [(width - 1):0] out
    );

    genvar ix;
    generate
        for (ix = 0; ix < width; ix = ix + 1) begin :Bit
            assign out[ix] = in[width - 1 - ix];
        end
    endgenerate

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    lowMaskHiLo#(
        parameter inWidth = 1,
        parameter topBound = 1,
        parameter bottomBound = 0
    ) (
        input [(inWidth - 1):0] in,
        output [(topBound - bottomBound - 1):0] out
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam numInVals = 1<<inWidth;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [numInVals:0] c;
    assign c[numInVals] = 1;
    assign c[(numInVals - 1):0] = 0;
    wire [(topBound - bottomBound - 1):0] reverseOut =
        (c>>>in)>>(numInVals - topBound);
    reverse#(topBound - bottomBound) reverse(reverseOut, out);

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    lowMaskLoHi#(
        parameter inWidth = 1,
        parameter topBound = 0,
        parameter bottomBound = 1
    ) (
        input [(inWidth - 1):0] in,
        output [(bottomBound - topBound - 1):0] out
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam numInVals = 1<<inWidth;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [numInVals:0] c;
    assign c[numInVals] = 1;
    assign c[(numInVals - 1):0] = 0;
    wire [(bottomBound - topBound - 1):0] reverseOut =
        (c>>>~in)>>(topBound + 1);
    reverse#(bottomBound - topBound) reverse(reverseOut, out);

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    countLeadingZeros#(parameter inWidth = 1, parameter countWidth = 1) (
        input [(inWidth - 1):0] in, output [(countWidth - 1):0] count
    );

    wire [(inWidth - 1):0] reverseIn;
    reverse#(inWidth) reverse_in(in, reverseIn);
    wire [inWidth:0] oneLeastReverseIn =
        {1'b1, reverseIn} & ({1'b0, ~reverseIn} + 1);
    genvar ix;
    generate
        for (ix = 0; ix <= inWidth; ix = ix + 1) begin :Bit
            wire [(countWidth - 1):0] countSoFar;
            if (ix == 0) begin
                assign countSoFar = 0;
            end else begin
                assign countSoFar =
                    Bit[ix - 1].countSoFar | (oneLeastReverseIn[ix] ? ix : 0);
                if (ix == inWidth) assign count = countSoFar;
            end
        end
    endgenerate

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    compressBy2#(parameter inWidth = 1) (
        input [(inWidth - 1):0] in, output [((inWidth - 1)/2):0] out
    );

    localparam maxBitNumReduced = (inWidth - 1)/2;
    genvar ix;
    generate
        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit
            assign out[ix] = |in[(ix*2 + 1):ix*2];
        end
    endgenerate
    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*2];

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    compressBy4#(parameter inWidth = 1) (
        input [(inWidth - 1):0] in, output [(inWidth - 1)/4:0] out
    );

    localparam maxBitNumReduced = (inWidth - 1)/4;
    genvar ix;
    generate
        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit
            assign out[ix] = |in[(ix*4 + 3):ix*4];
        end
    endgenerate
    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*4];

endmodule

`endif /* __HARDFLOAT_PRIMITIVES_VI__ */

`line 6 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/includeFile.v" 0
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/RISCV/HardFloat_specialize.vi" 0
`ifndef __RISCV_HARDFLOAT_SPECIALIZE_VI__
`define __RISCV_HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flControl_default `flControl_tininessAfterRounding

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
//`define HardFloat_propagateNaNPayloads

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define HardFloat_signDefaultNaN 0
`define HardFloat_fractDefaultNaN(sigWidth) {1'b1, {((sigWidth) - 2){1'b0}}}

`endif /* __RISCV_HARDFLOAT_SPECIALIZE_VI__ */

`line 7 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/includeFile.v" 0
/* ============================================================== */

`line 42 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/recFNToFN.v" 0
// verilator lint_on MODDUP
/* ============================================================== */

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    recFNToFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in_,
        output [(expWidth + sigWidth - 1):0] out
    );
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_localFuncs.vi" 0

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

function integer clog2;
    input integer a;

    begin
        a = a - 1;
        for (clog2 = 0; a > 0; clog2 = clog2 + 1) a = a>>1;
    end

endfunction


`line 54 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/recFNToFN.v" 0

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam [expWidth:0] minNormExp = (1<<(expWidth - 1)) + 2;
    localparam normDistWidth = clog2(sigWidth);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaN, isInf, isZero, sign;
    wire signed [(expWidth + 1):0] sExp;
    wire [sigWidth:0] sig;
    recFNToRawFN#(expWidth, sigWidth)
        recFNToRawFN(in_, isNaN, isInf, isZero, sign, sExp, sig);
    wire isSubnormal = (sExp < minNormExp);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [(normDistWidth - 1):0] denormShiftDist = minNormExp - 1 - sExp;
    wire [(expWidth - 1):0] expOut =
        (isSubnormal ? 0 : sExp - minNormExp + 1)
            | (isNaN || isInf ? {expWidth{1'b1}} : 0);
    wire [(sigWidth - 2):0] fractOut =
        isSubnormal ? (sig>>1)>>denormShiftDist : isInf ? 0 : sig;
    assign out = {sign, expOut, fractOut};

endmodule

`endif /* __HARDFLOAT_RECFNTOFN_V__ */

`endif /* RECFNTOFN */

//-----------------------------------------------------------
// Wrapper of placeholder RecFNToFN__expWidth_9__sigWidth_23
//-----------------------------------------------------------

`ifndef RECFNTOFN__EXPWIDTH_9__SIGWIDTH_23
`define RECFNTOFN__EXPWIDTH_9__SIGWIDTH_23

module RecFNToFN__expWidth_9__sigWidth_23
(
  input logic reset,
  input logic clk,
  input logic [33-1:0] in_ ,
  output logic [32-1:0] out 
);
  recFNToFN
  #(
    .expWidth( 9 ),
    .sigWidth( 23 )
  ) v
  (
    .in_( in_ ),
    .out( out )
  );
endmodule

`endif /* RECFNTOFN__EXPWIDTH_9__SIGWIDTH_23 */



// PyMTL VerilogPlaceholder FNToRecFN Definition
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/FNToRecFNRTL.py

//***********************************************************
// Pickled source file of placeholder FNToRecFN__expWidth_9__sigWidth_23
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder FNToRecFN
//-----------------------------------------------------------

`ifndef FNTORECFN
`define FNTORECFN

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component FNToRecFN__expWidth_9__sigWidth_23.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!

`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_primitives.v" 0
`ifndef __HARDFLOAT_PRIMITIVES_VI__
`define __HARDFLOAT_PRIMITIVES_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    reverse#(parameter width = 1) (
        input [(width - 1):0] in, output [(width - 1):0] out
    );

    genvar ix;
    generate
        for (ix = 0; ix < width; ix = ix + 1) begin :Bit
            assign out[ix] = in[width - 1 - ix];
        end
    endgenerate

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    lowMaskHiLo#(
        parameter inWidth = 1,
        parameter topBound = 1,
        parameter bottomBound = 0
    ) (
        input [(inWidth - 1):0] in,
        output [(topBound - bottomBound - 1):0] out
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam numInVals = 1<<inWidth;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [numInVals:0] c;
    assign c[numInVals] = 1;
    assign c[(numInVals - 1):0] = 0;
    wire [(topBound - bottomBound - 1):0] reverseOut =
        (c>>>in)>>(numInVals - topBound);
    reverse#(topBound - bottomBound) reverse(reverseOut, out);

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    lowMaskLoHi#(
        parameter inWidth = 1,
        parameter topBound = 0,
        parameter bottomBound = 1
    ) (
        input [(inWidth - 1):0] in,
        output [(bottomBound - topBound - 1):0] out
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam numInVals = 1<<inWidth;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [numInVals:0] c;
    assign c[numInVals] = 1;
    assign c[(numInVals - 1):0] = 0;
    wire [(bottomBound - topBound - 1):0] reverseOut =
        (c>>>~in)>>(topBound + 1);
    reverse#(bottomBound - topBound) reverse(reverseOut, out);

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    countLeadingZeros#(parameter inWidth = 1, parameter countWidth = 1) (
        input [(inWidth - 1):0] in, output [(countWidth - 1):0] count
    );

    wire [(inWidth - 1):0] reverseIn;
    reverse#(inWidth) reverse_in(in, reverseIn);
    wire [inWidth:0] oneLeastReverseIn =
        {1'b1, reverseIn} & ({1'b0, ~reverseIn} + 1);
    genvar ix;
    generate
        for (ix = 0; ix <= inWidth; ix = ix + 1) begin :Bit
            wire [(countWidth - 1):0] countSoFar;
            if (ix == 0) begin
                assign countSoFar = 0;
            end else begin
                assign countSoFar =
                    Bit[ix - 1].countSoFar | (oneLeastReverseIn[ix] ? ix : 0);
                if (ix == inWidth) assign count = countSoFar;
            end
        end
    endgenerate

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    compressBy2#(parameter inWidth = 1) (
        input [(inWidth - 1):0] in, output [((inWidth - 1)/2):0] out
    );

    localparam maxBitNumReduced = (inWidth - 1)/2;
    genvar ix;
    generate
        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit
            assign out[ix] = |in[(ix*2 + 1):ix*2];
        end
    endgenerate
    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*2];

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    compressBy4#(parameter inWidth = 1) (
        input [(inWidth - 1):0] in, output [(inWidth - 1)/4:0] out
    );

    localparam maxBitNumReduced = (inWidth - 1)/4;
    genvar ix;
    generate
        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit
            assign out[ix] = |in[(ix*4 + 3):ix*4];
        end
    endgenerate
    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*4];

endmodule

`endif /* __HARDFLOAT_PRIMITIVES_VI__ */
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/isSigNaNRecFN.v" 0
`ifndef __HARDFLOAT_ISSIGNANRECFN_V__
`define __HARDFLOAT_ISSIGNANRECFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    isSigNaNRecFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in, output isSigNaN
    );

    wire isNaN =
        (in[(expWidth + sigWidth - 1):(expWidth + sigWidth - 3)] == 'b111);
    assign isSigNaN = isNaN && !in[sigWidth - 2];

endmodule

`endif /* __HARDFLOAT_ISSIGNANRECFN_V__ */
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
`ifndef __HARDFLOAT_RAWFN_VI__
`define __HARDFLOAT_RAWFN_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_consts.vi" 0
`ifndef __HARDFLOAT_CONSTS_VI__
`define __HARDFLOAT_CONSTS_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define round_near_even   3'b000
`define round_minMag      3'b001
`define round_min         3'b010
`define round_max         3'b011
`define round_near_maxMag 3'b100
`define round_odd         3'b110

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define floatControlWidth 1
`define flControl_tininessBeforeRounding 1'b0
`define flControl_tininessAfterRounding  1'b1

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flRoundOpt_sigMSBitAlwaysZero  1
`define flRoundOpt_subnormsAlwaysExact 2
`define flRoundOpt_neverUnderflows     4
`define flRoundOpt_neverOverflows      8

`endif /* __HARDFLOAT_CONSTS_VI__ */

`line 40 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_specialize.vi" 0
`ifndef __HARDFLOAT_SPECIALIZE_VI__
`define __HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    iNFromException#(parameter width = 1) (
        input signedOut,
        input isNaN,
        input sign,
        output [(width - 1):0] out
    );

    wire maxInt = isNaN || !sign;
    assign out = {signedOut ^ maxInt, {(width - 1){maxInt}}};

endmodule

`endif /* __HARDFLOAT_SPECIALIZE_VI__ */

`line 41 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0

/* ===================== Adding some extra include files ================ */
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/RISCV/HardFloat_specialize.vi" 0
`ifndef __RISCV_HARDFLOAT_SPECIALIZE_VI__
`define __RISCV_HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flControl_default `flControl_tininessAfterRounding

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
//`define HardFloat_propagateNaNPayloads

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define HardFloat_signDefaultNaN 0
`define HardFloat_fractDefaultNaN(sigWidth) {1'b1, {((sigWidth) - 2){1'b0}}}

`endif /* __RISCV_HARDFLOAT_SPECIALIZE_VI__ */

`line 44 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
/* ====================================================================== */

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    recFNToRawFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in,
        output isNaN,
        output isInf,
        output isZero,
        output sign,
        output signed [(expWidth + 1):0] sExp,
        output [sigWidth:0] sig
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [expWidth:0] exp;
    wire [(sigWidth - 2):0] fract;
    assign {sign, exp, fract} = in;
    wire isSpecial = (exp>>(expWidth - 1) == 'b11);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    assign isNaN = isSpecial &&  exp[expWidth - 2];
    assign isInf = isSpecial && !exp[expWidth - 2];
    assign isZero = (exp>>(expWidth - 2) == 'b000);
    assign sExp = exp;
    assign sig = {1'b0, !isZero, fract};

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    roundAnyRawFNToRecFN#(
        parameter inExpWidth = 3,
        parameter inSigWidth = 3,
        parameter outExpWidth = 3,
        parameter outSigWidth = 3,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,     // overrides 'infiniteExc' and 'in_*' inputs
        input infiniteExc,    // overrides 'in_*' inputs except 'in_sign'
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(inExpWidth + 1):0] in_sExp,   // limited range allowed
        input [inSigWidth:0] in_sig,
        input [2:0] roundingMode,
        output [(outExpWidth + outSigWidth):0] out,
        output [4:0] exceptionFlags
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam sigMSBitAlwaysZero =
        ((options & `flRoundOpt_sigMSBitAlwaysZero) != 0);
    localparam effectiveInSigWidth =
        sigMSBitAlwaysZero ? inSigWidth : inSigWidth + 1;
    localparam neverUnderflows =
        ((options
              & (`flRoundOpt_neverUnderflows
                     | `flRoundOpt_subnormsAlwaysExact))
             != 0)
            || (inExpWidth < outExpWidth);
    localparam neverOverflows =
        ((options & `flRoundOpt_neverOverflows) != 0)
            || (inExpWidth < outExpWidth);
    localparam adjustedExpWidth =
          (inExpWidth < outExpWidth) ? outExpWidth + 1
        : (inExpWidth == outExpWidth) ? inExpWidth + 2
        : inExpWidth + 3;
    localparam outNaNExp = 7<<(outExpWidth - 2);
    localparam outInfExp = 6<<(outExpWidth - 2);
    localparam outMaxFiniteExp = outInfExp - 1;
    localparam outMinNormExp = (1<<(outExpWidth - 1)) + 2;
    localparam outMinNonzeroExp = outMinNormExp - outSigWidth + 1;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire roundingMode_near_even   = (roundingMode == `round_near_even);
    wire roundingMode_minMag      = (roundingMode == `round_minMag);
    wire roundingMode_min         = (roundingMode == `round_min);
    wire roundingMode_max         = (roundingMode == `round_max);
    wire roundingMode_near_maxMag = (roundingMode == `round_near_maxMag);
    wire roundingMode_odd         = (roundingMode == `round_odd);
    wire roundMagUp =
        (roundingMode_min && in_sign) || (roundingMode_max && !in_sign);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaNOut = invalidExc || (!infiniteExc && in_isNaN);
`ifdef HardFloat_propagateNaNPayloads
    wire propagateNaNPayload = isNaNOut;
`else
    wire propagateNaNPayload = 0;
`endif
    wire signed [(adjustedExpWidth - 1):0] sAdjustedExp =
        in_sExp + ((1<<outExpWidth) - (1<<inExpWidth));
    wire [(outSigWidth + 2):0] adjustedSig;
    generate
        if (inSigWidth <= outSigWidth + 2) begin
            assign adjustedSig = in_sig<<(outSigWidth - inSigWidth + 2);
        end else begin
            assign adjustedSig =
                {in_sig[inSigWidth:(inSigWidth - outSigWidth - 1)],
                 |in_sig[(inSigWidth - outSigWidth - 2):0]};
        end
    endgenerate
    wire doShiftSigDown1 =
        sigMSBitAlwaysZero ? 0 : adjustedSig[outSigWidth + 2];
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [outExpWidth:0] common_expOut;
    wire [(outSigWidth - 2):0] common_fractOut;
    wire common_overflow, common_totalUnderflow, common_underflow;
    wire common_inexact;
    generate
        if (
            neverOverflows && neverUnderflows
                && (effectiveInSigWidth <= outSigWidth)
        ) begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_expOut = sAdjustedExp + doShiftSigDown1;
            assign common_fractOut =
                doShiftSigDown1 ? adjustedSig>>3 : adjustedSig>>2;
            assign common_overflow       = 0;
            assign common_totalUnderflow = 0;
            assign common_underflow      = 0;
            assign common_inexact        = 0;
        end else begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire [(outSigWidth + 2):0] roundMask;
            if (neverUnderflows) begin
                assign roundMask = {doShiftSigDown1, 2'b11};
            end else begin
                wire [outSigWidth:0] roundMask_main;
                lowMaskLoHi#(
                    outExpWidth + 1,
                    outMinNormExp - outSigWidth - 1,
                    outMinNormExp
                ) lowMask_roundMask(
                        sAdjustedExp[outExpWidth:0]
                            | (propagateNaNPayload ? 1'b1<<outExpWidth : 1'b0),
                        roundMask_main
                    );
                assign roundMask = {roundMask_main | doShiftSigDown1, 2'b11};
            end
            wire [(outSigWidth + 2):0] shiftedRoundMask = roundMask>>1;
            wire [(outSigWidth + 2):0] roundPosMask =
                ~shiftedRoundMask & roundMask;
            wire roundPosBit =
                (|(adjustedSig[(outSigWidth + 2):3]
                       & roundPosMask[(outSigWidth + 2):3]))
                    || ((|(adjustedSig[2:0] & roundPosMask[2:0]))
                            && !propagateNaNPayload);
            wire anyRoundExtra =
                (|(adjustedSig[(outSigWidth + 2):3]
                       & shiftedRoundMask[(outSigWidth + 2):3]))
                    || ((|(adjustedSig[2:0] & shiftedRoundMask[2:0]))
                            && !propagateNaNPayload);
            wire anyRound = roundPosBit || anyRoundExtra;
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire roundIncr =
                ((roundingMode_near_even || roundingMode_near_maxMag)
                     && roundPosBit)
                    || (roundMagUp && anyRound);
            wire [(outSigWidth + 1):0] roundedSig =
                roundIncr
                    ? (((adjustedSig | roundMask)>>2) + 1)
                          & ~(roundingMode_near_even && roundPosBit
                                  && !anyRoundExtra
                                  ? roundMask>>1 : 0)
                    : (adjustedSig & ~roundMask)>>2
                          | (roundingMode_odd && anyRound
                                 ? roundPosMask>>1 : 0);
            wire signed [adjustedExpWidth:0] sExtAdjustedExp = sAdjustedExp;
            wire signed [adjustedExpWidth:0] sRoundedExp =
                sExtAdjustedExp + (roundedSig>>outSigWidth);
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_expOut = sRoundedExp;
            assign common_fractOut =
                doShiftSigDown1 ? roundedSig>>1 : roundedSig;
            assign common_overflow =
                neverOverflows ? 0 : (sRoundedExp>>>(outExpWidth - 1) >= 3);
            assign common_totalUnderflow =
                neverUnderflows ? 0 : (sRoundedExp < outMinNonzeroExp);
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire unboundedRange_roundPosBit =
                doShiftSigDown1 ? adjustedSig[2] : adjustedSig[1];
            wire unboundedRange_anyRound =
                (doShiftSigDown1 && adjustedSig[2]) || (|adjustedSig[1:0]);
            wire unboundedRange_roundIncr =
                ((roundingMode_near_even || roundingMode_near_maxMag)
                     && unboundedRange_roundPosBit)
                    || (roundMagUp && unboundedRange_anyRound);
            wire roundCarry =
                doShiftSigDown1
                    ? roundedSig[outSigWidth + 1] : roundedSig[outSigWidth];
            assign common_underflow =
                neverUnderflows ? 0
                    : common_totalUnderflow
                          || (anyRound && (sAdjustedExp>>>outExpWidth <= 0)
                                  && (doShiftSigDown1
                                          ? roundMask[3] : roundMask[2])
                                  && !(((control
                                           & `flControl_tininessAfterRounding)
                                            != 0)
                                           && !(doShiftSigDown1 ? roundMask[4]
                                                    : roundMask[3])
                                           && roundCarry && roundPosBit
                                           && unboundedRange_roundIncr));
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_inexact = common_totalUnderflow || anyRound;
        end
    endgenerate
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire notNaN_isSpecialInfOut = infiniteExc || in_isInf;
    wire commonCase = !isNaNOut && !notNaN_isSpecialInfOut && !in_isZero;
    wire overflow  = commonCase && common_overflow;
    wire underflow = commonCase && common_underflow;
    wire inexact = overflow || (commonCase && common_inexact);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire overflow_roundMagUp =
        roundingMode_near_even || roundingMode_near_maxMag || roundMagUp;
    wire pegMinNonzeroMagOut =
        commonCase && common_totalUnderflow
            && (roundMagUp || roundingMode_odd);
    wire pegMaxFiniteMagOut = overflow && !overflow_roundMagUp;
    wire notNaN_isInfOut =
        notNaN_isSpecialInfOut || (overflow && overflow_roundMagUp);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
`ifdef HardFloat_propagateNaNPayloads
    wire signOut = in_sign;
`else
    wire signOut = isNaNOut ? `HardFloat_signDefaultNaN : in_sign;
`endif
    wire [outExpWidth:0] expOut =
        (common_expOut
             & ~(in_isZero || common_totalUnderflow ? 7<<(outExpWidth - 2) : 0)
             & ~(pegMinNonzeroMagOut               ? ~outMinNonzeroExp    : 0)
             & ~(pegMaxFiniteMagOut                ? 1<<(outExpWidth - 1) : 0)
             & ~(notNaN_isInfOut                   ? 1<<(outExpWidth - 2) : 0))
            | (pegMinNonzeroMagOut ? outMinNonzeroExp : 0)
            | (pegMaxFiniteMagOut  ? outMaxFiniteExp  : 0)
            | (notNaN_isInfOut     ? outInfExp        : 0)
            | (isNaNOut            ? outNaNExp        : 0);
`ifdef HardFloat_propagateNaNPayloads
    wire [(outSigWidth - 2):0] fractOut =
        {isNaNOut
             || (!in_isZero && !common_totalUnderflow
                     && common_fractOut[outSigWidth - 2]),
         isNaNOut || (!in_isZero && !common_totalUnderflow)
             ? common_fractOut[(outSigWidth - 3):0] : 1'b0}
            | {(outSigWidth - 1){pegMaxFiniteMagOut}};
`else
    wire [(outSigWidth - 2):0] fractOut =
          (isNaNOut ? `HardFloat_fractDefaultNaN(outSigWidth) : 0)
        | (!in_isZero && !common_totalUnderflow
               ? common_fractOut & `HardFloat_fractDefaultNaN(outSigWidth) : 0)
        | (!isNaNOut && !in_isZero && !common_totalUnderflow
               ? common_fractOut & ~`HardFloat_fractDefaultNaN(outSigWidth)
               : 0)
        | {(outSigWidth - 1){pegMaxFiniteMagOut}};
`endif
    assign out = {signOut, expOut, fractOut};
    assign exceptionFlags =
        {invalidExc, infiniteExc, overflow, underflow, inexact};

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    roundRawFNToRecFN#(
        parameter expWidth = 3,
        parameter sigWidth = 3,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,     // overrides 'infiniteExc' and 'in_*' inputs
        input infiniteExc,    // overrides 'in_*' inputs except 'in_sign'
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(expWidth + 1):0] in_sExp,   // limited range allowed
        input [(sigWidth + 2):0] in_sig,
        input [2:0] roundingMode,
        output [(expWidth + sigWidth):0] out,
        output [4:0] exceptionFlags
    );

    roundAnyRawFNToRecFN#(expWidth, sigWidth + 2, expWidth, sigWidth, options)
        roundAnyRawFNToRecFN(
            control,
            invalidExc,
            infiniteExc,
            in_isNaN,
            in_isInf,
            in_isZero,
            in_sign,
            in_sExp,
            in_sig,
            roundingMode,
            out,
            exceptionFlags
        );

endmodule

`endif /* __HARDFLOAT_RAWFN_VI__ */

// End of all v_libs files for component FNToRecFN__expWidth_9__sigWidth_23

`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/fNToRecFN.v" 0
`ifndef __HARDFLOAT_DIVSQRTRECFN_V__
`define __HARDFLOAT_DIVSQRTRECFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    fNToRecFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth - 1):0] in_,
        output [(expWidth + sigWidth):0] out
    );
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_localFuncs.vi" 0

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

function integer clog2;
    input integer a;

    begin
        a = a - 1;
        for (clog2 = 0; a > 0; clog2 = clog2 + 1) a = a>>1;
    end

endfunction


`line 48 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/fNToRecFN.v" 0

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam normDistWidth = clog2(sigWidth);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire sign;
    wire [(expWidth - 1):0] expIn;
    wire [(sigWidth - 2):0] fractIn;
    assign {sign, expIn, fractIn} = in_;
    wire isZeroExpIn = (expIn == 0);
    wire isZeroFractIn = (fractIn == 0);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [(normDistWidth - 1):0] normDist;
    countLeadingZeros#(sigWidth - 1, normDistWidth)
        countLeadingZeros(fractIn, normDist);
    wire [(sigWidth - 2):0] subnormFract = (fractIn<<normDist)<<1;
    wire [expWidth:0] adjustedExp =
        (isZeroExpIn ? normDist ^ ((1<<(expWidth + 1)) - 1) : expIn)
            + ((1<<(expWidth - 1)) | (isZeroExpIn ? 2 : 1));
    wire isZero = isZeroExpIn && isZeroFractIn;
    wire isSpecial = (adjustedExp[expWidth:(expWidth - 1)] == 'b11);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [expWidth:0] exp;
    assign exp[expWidth:(expWidth - 2)] =
        isSpecial ? {2'b11, !isZeroFractIn}
            : isZero ? 3'b000 : adjustedExp[expWidth:(expWidth - 2)];
    assign exp[(expWidth - 3):0] = adjustedExp;
    assign out = {sign, exp, isZeroExpIn ? subnormFract : fractIn};

endmodule

`endif /* __HARDFLOAT_DIVSQRTRECFN_V__ */

`endif /* FNTORECFN */

//-----------------------------------------------------------
// Wrapper of placeholder FNToRecFN__expWidth_9__sigWidth_23
//-----------------------------------------------------------

`ifndef FNTORECFN__EXPWIDTH_9__SIGWIDTH_23
`define FNTORECFN__EXPWIDTH_9__SIGWIDTH_23

module FNToRecFN__expWidth_9__sigWidth_23
(
  input logic reset,
  input logic clk,
  input logic [32-1:0] in_ ,
  output logic [33-1:0] out 
);
  fNToRecFN
  #(
    .expWidth( 9 ),
    .sigWidth( 23 )
  ) v
  (
    .in_( in_ ),
    .out( out )
  );
endmodule

`endif /* FNTORECFN__EXPWIDTH_9__SIGWIDTH_23 */



// PyMTL Component MulFN Definition
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/MulFNRTL.py

module MulFN__expWidth_9__sigWidth_23
(
  input  logic [31:0] a ,
  input  logic [31:0] b ,
  input  logic [0:0] clk ,
  output logic [31:0] out ,
  input  logic [0:0] reset ,
  input  logic [2:0] roundingMode 
);
  logic [32:0] conv_a;
  logic [32:0] conv_b;
  logic [4:0] exception_flags;
  //-------------------------------------------------------------
  // Component multiplier
  //-------------------------------------------------------------

  logic [32:0] multiplier_a;
  logic [32:0] multiplier_b;
  logic [0:0] multiplier_clk;
  logic [0:0] multiplier_control;
  logic [4:0] multiplier_exceptionFlags;
  logic [32:0] multiplier_out;
  logic [0:0] multiplier_reset;
  logic [2:0] multiplier_roundingMode;

  MulRecFN__expWidth_9__sigWidth_23 multiplier
  (
    .a( multiplier_a ),
    .b( multiplier_b ),
    .clk( multiplier_clk ),
    .control( multiplier_control ),
    .exceptionFlags( multiplier_exceptionFlags ),
    .out( multiplier_out ),
    .reset( multiplier_reset ),
    .roundingMode( multiplier_roundingMode )
  );

  //-------------------------------------------------------------
  // End of component multiplier
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component rec_to_std_conv
  //-------------------------------------------------------------

  logic [0:0] rec_to_std_conv_clk;
  logic [32:0] rec_to_std_conv_in_;
  logic [31:0] rec_to_std_conv_out;
  logic [0:0] rec_to_std_conv_reset;

  RecFNToFN__expWidth_9__sigWidth_23 rec_to_std_conv
  (
    .clk( rec_to_std_conv_clk ),
    .in_( rec_to_std_conv_in_ ),
    .out( rec_to_std_conv_out ),
    .reset( rec_to_std_conv_reset )
  );

  //-------------------------------------------------------------
  // End of component rec_to_std_conv
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component std_to_rec_conv_a
  //-------------------------------------------------------------

  logic [0:0] std_to_rec_conv_a_clk;
  logic [31:0] std_to_rec_conv_a_in_;
  logic [32:0] std_to_rec_conv_a_out;
  logic [0:0] std_to_rec_conv_a_reset;

  FNToRecFN__expWidth_9__sigWidth_23 std_to_rec_conv_a
  (
    .clk( std_to_rec_conv_a_clk ),
    .in_( std_to_rec_conv_a_in_ ),
    .out( std_to_rec_conv_a_out ),
    .reset( std_to_rec_conv_a_reset )
  );

  //-------------------------------------------------------------
  // End of component std_to_rec_conv_a
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component std_to_rec_conv_b
  //-------------------------------------------------------------

  logic [0:0] std_to_rec_conv_b_clk;
  logic [31:0] std_to_rec_conv_b_in_;
  logic [32:0] std_to_rec_conv_b_out;
  logic [0:0] std_to_rec_conv_b_reset;

  FNToRecFN__expWidth_9__sigWidth_23 std_to_rec_conv_b
  (
    .clk( std_to_rec_conv_b_clk ),
    .in_( std_to_rec_conv_b_in_ ),
    .out( std_to_rec_conv_b_out ),
    .reset( std_to_rec_conv_b_reset )
  );

  //-------------------------------------------------------------
  // End of component std_to_rec_conv_b
  //-------------------------------------------------------------

  assign std_to_rec_conv_a_clk = clk;
  assign std_to_rec_conv_a_reset = reset;
  assign std_to_rec_conv_b_clk = clk;
  assign std_to_rec_conv_b_reset = reset;
  assign rec_to_std_conv_clk = clk;
  assign rec_to_std_conv_reset = reset;
  assign multiplier_clk = clk;
  assign multiplier_reset = reset;
  assign std_to_rec_conv_a_in_ = a;
  assign conv_a = std_to_rec_conv_a_out;
  assign std_to_rec_conv_b_in_ = b;
  assign conv_b = std_to_rec_conv_b_out;
  assign multiplier_control = 1'd1;
  assign multiplier_a = conv_a;
  assign multiplier_b = conv_b;
  assign multiplier_roundingMode = roundingMode;
  assign exception_flags = multiplier_exceptionFlags;
  assign rec_to_std_conv_in_ = multiplier_out;
  assign out = rec_to_std_conv_out;

endmodule


// PyMTL Component FpMulRTL Definition
// Full name: FpMulRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__PredicateType_CGRAData_1_1__payload_1__predicate_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__num_inports_4__num_outports_2__data_mem_size_288__exp_nbits_8__sig_nbits_23
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/float/FpMulRTL.py

module FpMulRTL__ea91a20faab79471
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  input CGRAData_1_1__payload_1__predicate_1 recv_predicate__msg  ,
  output logic [0:0] recv_predicate__rdy  ,
  input logic [0:0] recv_predicate__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [5:0] __const__OPT_START  = 6'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [5:0] __const__OPT_FMUL  = 6'd41;
  localparam logic [5:0] __const__OPT_FMUL_CONST  = 6'd42;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;
  //-------------------------------------------------------------
  // Component fmul
  //-------------------------------------------------------------

  logic [31:0] fmul__a;
  logic [31:0] fmul__b;
  logic [0:0] fmul__clk;
  logic [31:0] fmul__out;
  logic [0:0] fmul__reset;
  logic [2:0] fmul__roundingMode;

  MulFN__expWidth_9__sigWidth_23 fmul
  (
    .a( fmul__a ),
    .b( fmul__b ),
    .clk( fmul__clk ),
    .out( fmul__out ),
    .reset( fmul__reset ),
    .roundingMode( fmul__roundingMode )
  );

  //-------------------------------------------------------------
  // End of component fmul
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/float/FpMulRTL.py:61
  // @update
  // def comb_logic():
  // 
  //   s.recv_all_val @= 0
  //   # For pick input register
  //   s.in0 @= 0
  //   s.in1 @= 0
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  // 
  //   for i in range(num_outports):
  //     s.send_out[i].val @= 0
  //     s.send_out[i].msg @= DataType()
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_predicate.rdy @= b1(0)
  //   s.recv_opt.rdy @= 0
  // 
  //   s.fmul.a @= 0
  //   s.fmul.b @= 0
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != 0:
  //       s.in0 @= zext(s.recv_opt.msg.fu_in[0] - 1, FuInType)
  //     if s.recv_opt.msg.fu_in[1] != 0:
  //       s.in1 @= zext(s.recv_opt.msg.fu_in[1] - 1, FuInType)
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.operation == OPT_FMUL:
  //       s.fmul.a @= s.recv_in[s.in0_idx].msg.payload
  //       s.fmul.b @= s.recv_in[s.in1_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      (~s.recv_opt.msg.predicate | \
  //                                       s.recv_predicate.msg.predicate)
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_FMUL_CONST:
  //       s.fmul.a @= s.recv_in[s.in0_idx].msg.payload
  //       s.fmul.b @= s.recv_const.msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      (~s.recv_opt.msg.predicate | \
  //                                       s.recv_predicate.msg.predicate)
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_const.rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     else:
  //       for j in range(num_outports):
  //         s.send_out[j].val @= b1(0)
  //       s.recv_opt.rdy @= 0
  //       s.recv_in[s.in0_idx].rdy @= 0
  //       s.recv_in[s.in1_idx].rdy @= 0
  // 
  //     if s.recv_opt.msg.predicate == b1(1):
  //       s.recv_predicate.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     s.send_out[0].msg.payload @= s.fmul.out
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_predicate__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    fmul__a = 32'd0;
    fmul__b = 32'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 6'( __const__OPT_FMUL ) ) begin
        fmul__a = recv_in__msg[in0_idx].payload;
        fmul__b = recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate );
        recv_all_val = ( recv_in__val[in0_idx] & recv_in__val[in1_idx] ) & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_FMUL_CONST ) ) begin
        fmul__a = recv_in__msg[in0_idx].payload;
        fmul__b = recv_const__msg.payload;
        send_out__msg[1'd0].predicate = recv_in__msg[in0_idx].predicate & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate );
        recv_all_val = recv_in__val[in0_idx] & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_const__rdy = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
      end
      if ( recv_opt__msg.predicate == 1'd1 ) begin
        recv_predicate__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      send_out__msg[1'd0].payload = fmul__out;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:66
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= DataAddrType(0)
  //   s.to_mem_raddr.msg @= DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:85
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:76
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 6'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:93
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //          (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;
  assign fmul__clk = clk;
  assign fmul__reset = reset;
  assign fmul__roundingMode = 3'd0;
  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];

endmodule


// PyMTL Component MulRTL Definition
// Full name: MulRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__PredicateType_CGRAData_1_1__payload_1__predicate_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__num_inports_4__num_outports_2__data_mem_size_288__vector_factor_power_0
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/MulRTL.py

module MulRTL__b48d5d572c75e2e4
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  input CGRAData_1_1__payload_1__predicate_1 recv_predicate__msg  ,
  output logic [0:0] recv_predicate__rdy  ,
  input logic [0:0] recv_predicate__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [5:0] __const__OPT_START  = 6'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [5:0] __const__OPT_MUL  = 6'd7;
  localparam logic [5:0] __const__OPT_MUL_CONST  = 6'd29;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/MulRTL.py:41
  // @update
  // def comb_logic():
  // 
  //   s.recv_all_val @= 0
  //   # For pick input register
  //   s.in0 @= 0
  //   s.in1 @= 0
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  //   for i in range(num_outports):
  //     s.send_out[i].val @= 0
  //     s.send_out[i].msg @= DataType()
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_predicate.rdy @= b1(0)
  //   s.recv_opt.rdy @= 0
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != 0:
  //       s.in0 @= zext(s.recv_opt.msg.fu_in[0] - 1, FuInType)
  //     if s.recv_opt.msg.fu_in[1] != 0:
  //       s.in1 @= zext(s.recv_opt.msg.fu_in[1] - 1, FuInType)
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.operation == OPT_MUL:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload * s.recv_in[s.in1_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      (~s.recv_opt.msg.predicate | \
  //                                       s.recv_predicate.msg.predicate) & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_MUL_CONST:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload * s.recv_const.msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      (~s.recv_opt.msg.predicate | \
  //                                       s.recv_predicate.msg.predicate) & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_const.val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_const.rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     # FIXME: https://github.com/tancheng/VectorCGRA/issues/138
  //     # elif s.recv_opt.msg.operation == OPT_DIV:
  //     #   s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload / s.recv_in[s.in1_idx].msg.payload
  //     #   s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //     #                                  s.recv_in[s.in1_idx].msg.predicate & \
  //     #                                  (~s.recv_opt.msg.predicate | \
  //     #                                   s.recv_predicate.msg.predicate) & \
  //     #                                  s.reached_vector_factor
  //     #   s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val & \
  //     #                     ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //     #   s.send_out[0].val @= s.recv_all_val
  //     #   s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //     #   s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //     #   s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     else:
  //       for j in range(num_outports):
  //         s.send_out[j].val @= b1(0)
  //       s.recv_opt.rdy @= 0
  //       s.recv_in[s.in0_idx].rdy @= 0
  //       s.recv_in[s.in1_idx].rdy @= 0
  // 
  //     if s.send_out[0].rdy & (s.recv_opt.msg.predicate == b1(1)):
  //       s.recv_predicate.rdy @= s.recv_all_val & s.send_out[0].rdy
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_predicate__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 6'( __const__OPT_MUL ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload * recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = ( ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) ) & reached_vector_factor;
        recv_all_val = ( recv_in__val[in0_idx] & recv_in__val[in1_idx] ) & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_MUL_CONST ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload * recv_const__msg.payload;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) ) & reached_vector_factor;
        recv_all_val = ( recv_in__val[in0_idx] & recv_const__val ) & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_const__rdy = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
      end
      if ( send_out__rdy[1'd0] & ( recv_opt__msg.predicate == 1'd1 ) ) begin
        recv_predicate__rdy = recv_all_val & send_out__rdy[1'd0];
      end
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:66
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= DataAddrType(0)
  //   s.to_mem_raddr.msg @= DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:85
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:76
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 6'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:93
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //          (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;
  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];

endmodule


// PyMTL Component SeqMulAdderRTL Definition
// Full name: SeqMulAdderRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__PredicateType_CGRAData_1_1__payload_1__predicate_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__num_inports_4__num_outports_2__data_mem_size_288
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/double/SeqMulAdderRTL.py

module SeqMulAdderRTL__010c52f4aa4155bc
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  input CGRAData_1_1__payload_1__predicate_1 recv_predicate__msg  ,
  output logic [0:0] recv_predicate__rdy  ,
  input logic [0:0] recv_predicate__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [5:0] __const__OPT_MUL_ADD  = 6'd18;
  localparam logic [5:0] __const__OPT_MUL  = 6'd7;
  localparam logic [5:0] __const__OPT_ADD  = 6'd2;
  localparam logic [5:0] __const__OPT_MUL_CONST_ADD  = 6'd30;
  localparam logic [5:0] __const__OPT_MUL_CONST  = 6'd29;
  localparam logic [5:0] __const__OPT_PAS  = 6'd31;
  localparam logic [5:0] __const__OPT_MUL_SUB  = 6'd19;
  localparam logic [5:0] __const__OPT_SUB  = 6'd4;
  localparam logic [5:0] __const__OPT_START  = 6'd0;
  //-------------------------------------------------------------
  // Component Fu0
  //-------------------------------------------------------------

  logic [0:0] Fu0__clk;
  logic [0:0] Fu0__reset;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 Fu0__from_mem_rdata__msg;
  logic [0:0] Fu0__from_mem_rdata__rdy;
  logic [0:0] Fu0__from_mem_rdata__val;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 Fu0__recv_const__msg;
  logic [0:0] Fu0__recv_const__rdy;
  logic [0:0] Fu0__recv_const__val;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 Fu0__recv_in__msg [0:3];
  logic [0:0] Fu0__recv_in__rdy [0:3];
  logic [0:0] Fu0__recv_in__val [0:3];
  CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf Fu0__recv_opt__msg;
  logic [0:0] Fu0__recv_opt__rdy;
  logic [0:0] Fu0__recv_opt__val;
  CGRAData_1_1__payload_1__predicate_1 Fu0__recv_predicate__msg;
  logic [0:0] Fu0__recv_predicate__rdy;
  logic [0:0] Fu0__recv_predicate__val;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 Fu0__send_out__msg [0:1];
  logic [0:0] Fu0__send_out__rdy [0:1];
  logic [0:0] Fu0__send_out__val [0:1];
  logic [8:0] Fu0__to_mem_raddr__msg;
  logic [0:0] Fu0__to_mem_raddr__rdy;
  logic [0:0] Fu0__to_mem_raddr__val;
  logic [8:0] Fu0__to_mem_waddr__msg;
  logic [0:0] Fu0__to_mem_waddr__rdy;
  logic [0:0] Fu0__to_mem_waddr__val;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 Fu0__to_mem_wdata__msg;
  logic [0:0] Fu0__to_mem_wdata__rdy;
  logic [0:0] Fu0__to_mem_wdata__val;

  MulRTL__b48d5d572c75e2e4 Fu0
  (
    .clk( Fu0__clk ),
    .reset( Fu0__reset ),
    .from_mem_rdata__msg( Fu0__from_mem_rdata__msg ),
    .from_mem_rdata__rdy( Fu0__from_mem_rdata__rdy ),
    .from_mem_rdata__val( Fu0__from_mem_rdata__val ),
    .recv_const__msg( Fu0__recv_const__msg ),
    .recv_const__rdy( Fu0__recv_const__rdy ),
    .recv_const__val( Fu0__recv_const__val ),
    .recv_in__msg( Fu0__recv_in__msg ),
    .recv_in__rdy( Fu0__recv_in__rdy ),
    .recv_in__val( Fu0__recv_in__val ),
    .recv_opt__msg( Fu0__recv_opt__msg ),
    .recv_opt__rdy( Fu0__recv_opt__rdy ),
    .recv_opt__val( Fu0__recv_opt__val ),
    .recv_predicate__msg( Fu0__recv_predicate__msg ),
    .recv_predicate__rdy( Fu0__recv_predicate__rdy ),
    .recv_predicate__val( Fu0__recv_predicate__val ),
    .send_out__msg( Fu0__send_out__msg ),
    .send_out__rdy( Fu0__send_out__rdy ),
    .send_out__val( Fu0__send_out__val ),
    .to_mem_raddr__msg( Fu0__to_mem_raddr__msg ),
    .to_mem_raddr__rdy( Fu0__to_mem_raddr__rdy ),
    .to_mem_raddr__val( Fu0__to_mem_raddr__val ),
    .to_mem_waddr__msg( Fu0__to_mem_waddr__msg ),
    .to_mem_waddr__rdy( Fu0__to_mem_waddr__rdy ),
    .to_mem_waddr__val( Fu0__to_mem_waddr__val ),
    .to_mem_wdata__msg( Fu0__to_mem_wdata__msg ),
    .to_mem_wdata__rdy( Fu0__to_mem_wdata__rdy ),
    .to_mem_wdata__val( Fu0__to_mem_wdata__val )
  );

  //-------------------------------------------------------------
  // End of component Fu0
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component Fu1
  //-------------------------------------------------------------

  logic [0:0] Fu1__clk;
  logic [0:0] Fu1__reset;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 Fu1__from_mem_rdata__msg;
  logic [0:0] Fu1__from_mem_rdata__rdy;
  logic [0:0] Fu1__from_mem_rdata__val;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 Fu1__recv_const__msg;
  logic [0:0] Fu1__recv_const__rdy;
  logic [0:0] Fu1__recv_const__val;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 Fu1__recv_in__msg [0:3];
  logic [0:0] Fu1__recv_in__rdy [0:3];
  logic [0:0] Fu1__recv_in__val [0:3];
  CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf Fu1__recv_opt__msg;
  logic [0:0] Fu1__recv_opt__rdy;
  logic [0:0] Fu1__recv_opt__val;
  CGRAData_1_1__payload_1__predicate_1 Fu1__recv_predicate__msg;
  logic [0:0] Fu1__recv_predicate__rdy;
  logic [0:0] Fu1__recv_predicate__val;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 Fu1__send_out__msg [0:1];
  logic [0:0] Fu1__send_out__rdy [0:1];
  logic [0:0] Fu1__send_out__val [0:1];
  logic [8:0] Fu1__to_mem_raddr__msg;
  logic [0:0] Fu1__to_mem_raddr__rdy;
  logic [0:0] Fu1__to_mem_raddr__val;
  logic [8:0] Fu1__to_mem_waddr__msg;
  logic [0:0] Fu1__to_mem_waddr__rdy;
  logic [0:0] Fu1__to_mem_waddr__val;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 Fu1__to_mem_wdata__msg;
  logic [0:0] Fu1__to_mem_wdata__rdy;
  logic [0:0] Fu1__to_mem_wdata__val;

  AdderRTL__b48d5d572c75e2e4 Fu1
  (
    .clk( Fu1__clk ),
    .reset( Fu1__reset ),
    .from_mem_rdata__msg( Fu1__from_mem_rdata__msg ),
    .from_mem_rdata__rdy( Fu1__from_mem_rdata__rdy ),
    .from_mem_rdata__val( Fu1__from_mem_rdata__val ),
    .recv_const__msg( Fu1__recv_const__msg ),
    .recv_const__rdy( Fu1__recv_const__rdy ),
    .recv_const__val( Fu1__recv_const__val ),
    .recv_in__msg( Fu1__recv_in__msg ),
    .recv_in__rdy( Fu1__recv_in__rdy ),
    .recv_in__val( Fu1__recv_in__val ),
    .recv_opt__msg( Fu1__recv_opt__msg ),
    .recv_opt__rdy( Fu1__recv_opt__rdy ),
    .recv_opt__val( Fu1__recv_opt__val ),
    .recv_predicate__msg( Fu1__recv_predicate__msg ),
    .recv_predicate__rdy( Fu1__recv_predicate__rdy ),
    .recv_predicate__val( Fu1__recv_predicate__val ),
    .send_out__msg( Fu1__send_out__msg ),
    .send_out__rdy( Fu1__send_out__rdy ),
    .send_out__val( Fu1__send_out__val ),
    .to_mem_raddr__msg( Fu1__to_mem_raddr__msg ),
    .to_mem_raddr__rdy( Fu1__to_mem_raddr__rdy ),
    .to_mem_raddr__val( Fu1__to_mem_raddr__val ),
    .to_mem_waddr__msg( Fu1__to_mem_waddr__msg ),
    .to_mem_waddr__rdy( Fu1__to_mem_waddr__rdy ),
    .to_mem_waddr__val( Fu1__to_mem_waddr__val ),
    .to_mem_wdata__msg( Fu1__to_mem_wdata__msg ),
    .to_mem_wdata__rdy( Fu1__to_mem_wdata__rdy ),
    .to_mem_wdata__val( Fu1__to_mem_wdata__val )
  );

  //-------------------------------------------------------------
  // End of component Fu1
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/TwoSeqCombo.py:85
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val   @= b1(0)
  //   s.to_mem_wdata.val   @= b1(0)
  //   s.to_mem_wdata.msg   @= s.const_zero
  //   s.to_mem_waddr.msg   @= AddrType(0)
  //   s.to_mem_raddr.msg   @= AddrType(0)
  //   s.to_mem_raddr.val   @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/double/SeqMulAdderRTL.py:28
  //   @update
  //   def update_opt():
  // 
  //     s.Fu0.recv_opt.msg @= s.recv_opt.msg
  //     s.Fu1.recv_opt.msg @= s.recv_opt.msg
  // 
  //     s.Fu0.recv_opt.msg.fu_in[0] @= 1
  //     s.Fu0.recv_opt.msg.fu_in[1] @= 2
  //     s.Fu1.recv_opt.msg.fu_in[0] @= 1
  //     s.Fu1.recv_opt.msg.fu_in[1] @= 2
  // 
  //     # Note that the predication for a combined FU should be identical/shareable,
  //     # which means the computation in different basic block cannot be combined.
  //     s.Fu0.recv_opt.msg.predicate @= s.recv_opt.msg.predicate
  //     s.Fu1.recv_opt.msg.predicate @= s.recv_opt.msg.predicate
  // 
  //     if s.recv_opt.msg.operation == OPT_MUL_ADD:
  //       s.Fu0.recv_opt.msg.operation @= OPT_MUL
  //       s.Fu1.recv_opt.msg.operation @= OPT_ADD
  //     elif s.recv_opt.msg.operation == OPT_MUL_CONST_ADD:
  //       s.Fu0.recv_opt.msg.operation @= OPT_MUL_CONST
  //       s.Fu1.recv_opt.msg.operation @= OPT_ADD
  //     elif s.recv_opt.msg.operation == OPT_MUL_CONST:
  //       s.Fu0.recv_opt.msg.operation @= OPT_MUL_CONST
  //       s.Fu1.recv_opt.msg.operation @= OPT_PAS
  //     elif s.recv_opt.msg.operation == OPT_MUL_SUB:
  //       s.Fu0.recv_opt.msg.operation @= OPT_MUL
  //       s.Fu1.recv_opt.msg.operation @= OPT_SUB
  //     else:
  //       # Indicates no computation should happen no this fused FU.
  //       # This is necessary to avoid the OPT_MUL_CONST be executed
  //       # by both Mul and MulAdder.
  //       s.Fu0.recv_opt.msg.operation @= OPT_START
  //       s.Fu1.recv_opt.msg.operation @= OPT_START
  // 
  //     # TODO: need to handle the other cases
  
  always_comb begin : update_opt
    Fu0__recv_opt__msg = recv_opt__msg;
    Fu1__recv_opt__msg = recv_opt__msg;
    Fu0__recv_opt__msg.fu_in[2'd0] = 3'd1;
    Fu0__recv_opt__msg.fu_in[2'd1] = 3'd2;
    Fu1__recv_opt__msg.fu_in[2'd0] = 3'd1;
    Fu1__recv_opt__msg.fu_in[2'd1] = 3'd2;
    Fu0__recv_opt__msg.predicate = recv_opt__msg.predicate;
    Fu1__recv_opt__msg.predicate = recv_opt__msg.predicate;
    if ( recv_opt__msg.operation == 6'( __const__OPT_MUL_ADD ) ) begin
      Fu0__recv_opt__msg.operation = 6'( __const__OPT_MUL );
      Fu1__recv_opt__msg.operation = 6'( __const__OPT_ADD );
    end
    else if ( recv_opt__msg.operation == 6'( __const__OPT_MUL_CONST_ADD ) ) begin
      Fu0__recv_opt__msg.operation = 6'( __const__OPT_MUL_CONST );
      Fu1__recv_opt__msg.operation = 6'( __const__OPT_ADD );
    end
    else if ( recv_opt__msg.operation == 6'( __const__OPT_MUL_CONST ) ) begin
      Fu0__recv_opt__msg.operation = 6'( __const__OPT_MUL_CONST );
      Fu1__recv_opt__msg.operation = 6'( __const__OPT_PAS );
    end
    else if ( recv_opt__msg.operation == 6'( __const__OPT_MUL_SUB ) ) begin
      Fu0__recv_opt__msg.operation = 6'( __const__OPT_MUL );
      Fu1__recv_opt__msg.operation = 6'( __const__OPT_SUB );
    end
    else begin
      Fu0__recv_opt__msg.operation = 6'( __const__OPT_START );
      Fu1__recv_opt__msg.operation = 6'( __const__OPT_START );
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/TwoSeqCombo.py:54
  // @update
  // def update_signal():
  // 
  //   s.recv_in[0].rdy  @= s.Fu0.recv_in[0].rdy
  //   s.recv_in[1].rdy  @= s.Fu0.recv_in[1].rdy
  //   s.recv_in[2].rdy  @= s.Fu1.recv_in[1].rdy
  // 
  //   s.Fu0.recv_in[0].val @= s.recv_in[0].val
  //   s.Fu0.recv_in[1].val @= s.recv_in[1].val
  //   s.Fu1.recv_in[0].val @= s.Fu0.send_out[0].val
  //   s.Fu1.recv_in[1].val @= s.recv_in[2].val
  // 
  //   s.Fu0.recv_opt.val @= s.recv_opt.val
  //   s.Fu1.recv_opt.val @= s.recv_opt.val
  // 
  //   s.recv_opt.rdy @= s.Fu0.recv_opt.rdy & s.Fu1.recv_opt.rdy
  // 
  //   s.send_out[0].val @= s.Fu1.send_out[0].val
  // 
  //   s.Fu0.send_out[0].rdy @= s.Fu1.recv_in[0].rdy
  //   s.Fu1.send_out[0].rdy @= s.send_out[0].rdy
  // 
  //   s.recv_predicate.rdy     @= s.Fu0.recv_predicate.rdy & \
  //                               s.Fu1.recv_predicate.rdy
  // 
  //   s.Fu0.recv_predicate.val @= s.recv_predicate.val
  //   s.Fu1.recv_predicate.val @= s.recv_predicate.val
  // 
  //   s.Fu0.recv_predicate.msg @= s.recv_predicate.msg
  //   s.Fu1.recv_predicate.msg @= s.recv_predicate.msg
  
  always_comb begin : update_signal
    recv_in__rdy[2'd0] = Fu0__recv_in__rdy[2'd0];
    recv_in__rdy[2'd1] = Fu0__recv_in__rdy[2'd1];
    recv_in__rdy[2'd2] = Fu1__recv_in__rdy[2'd1];
    Fu0__recv_in__val[2'd0] = recv_in__val[2'd0];
    Fu0__recv_in__val[2'd1] = recv_in__val[2'd1];
    Fu1__recv_in__val[2'd0] = Fu0__send_out__val[1'd0];
    Fu1__recv_in__val[2'd1] = recv_in__val[2'd2];
    Fu0__recv_opt__val = recv_opt__val;
    Fu1__recv_opt__val = recv_opt__val;
    recv_opt__rdy = Fu0__recv_opt__rdy & Fu1__recv_opt__rdy;
    send_out__val[1'd0] = Fu1__send_out__val[1'd0];
    Fu0__send_out__rdy[1'd0] = Fu1__recv_in__rdy[2'd0];
    Fu1__send_out__rdy[1'd0] = send_out__rdy[1'd0];
    recv_predicate__rdy = Fu0__recv_predicate__rdy & Fu1__recv_predicate__rdy;
    Fu0__recv_predicate__val = recv_predicate__val;
    Fu1__recv_predicate__val = recv_predicate__val;
    Fu0__recv_predicate__msg = recv_predicate__msg;
    Fu1__recv_predicate__msg = recv_predicate__msg;
  end

  assign Fu0__clk = clk;
  assign Fu0__reset = reset;
  assign Fu1__clk = clk;
  assign Fu1__reset = reset;
  assign Fu0__recv_in__msg[0] = recv_in__msg[0];
  assign Fu0__recv_in__msg[1] = recv_in__msg[1];
  assign Fu1__recv_in__msg[1] = recv_in__msg[2];
  assign Fu1__recv_in__msg[0] = Fu0__send_out__msg[0];
  assign send_out__msg[0] = Fu1__send_out__msg[0];
  assign Fu0__recv_const__msg = recv_const__msg;
  assign recv_const__rdy = Fu0__recv_const__rdy;
  assign Fu0__recv_const__val = recv_const__val;

endmodule


// PyMTL Component VectorMulRTL Definition
// Full name: VectorMulRTL__bw_8__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__num_inports_4__num_outports_2__data_mem_size_288
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/vector/VectorMulRTL.py

module VectorMulRTL__09e44bc1b5c59ebc
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [15:0] recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input logic [15:0] recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output logic [15:0] send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] 
);
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [5:0] __const__OPT_MUL  = 6'd7;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [0:0] recv_all_val;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/vector/VectorMulRTL.py:56
  // @update
  // def comb_logic():
  // 
  //   s.recv_all_val @= 0
  //   # Pick input register
  //   s.in0 @= FuInType(0)
  //   s.in1 @= FuInType(0)
  // 
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  // 
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  //   for i in range( num_outports ):
  //     s.send_out[i].val @= b1(0)
  //     s.send_out[i].msg @= DataType()
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_opt.rdy @= 0
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != FuInType(0):
  //       s.in0 @= s.recv_opt.msg.fu_in[0] - FuInType(1)
  //     if s.recv_opt.msg.fu_in[1] != FuInType(0):
  //       s.in1 @= s.recv_opt.msg.fu_in[1] - FuInType(1)
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.operation == OPT_MUL:
  //       s.send_out[0].msg @= s.recv_in[s.in0_idx].msg * s.recv_in[s.in1_idx].msg
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     else:
  //       for j in range( num_outports ):
  //         s.send_out[j].val @= b1( 0 )
  //       s.recv_opt.rdy @= 0
  //       s.recv_in[s.in0_idx].rdy @= 0
  //       s.recv_in[s.in1_idx].rdy @= 0
  // 
  //   # if s.recv_opt.msg.predicate == b1( 1 ):
  //   #   s.send_out[0].msg.predicate = s.send_out[0].msg.predicate
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = 16'd0;
    end
    recv_const__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 6'( __const__OPT_MUL ) ) begin
        send_out__msg[1'd0] = recv_in__msg[in0_idx] * recv_in__msg[in1_idx];
        recv_all_val = recv_in__val[in0_idx] & recv_in__val[in1_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
      end
    end
  end

  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];

endmodule


// PyMTL Component SumUnit Definition
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/SumUnit.py

module SumUnit__DataType_Bits32__num_inputs_4
(
  input  logic [0:0] clk ,
  input  logic [31:0] in_ [0:3],
  output logic [31:0] out ,
  input  logic [0:0] reset 
);
  logic [31:0] partial_sum [0:3];

  // PyMTL Lambda Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/SumUnit.py:37
  // s.out //= lambda: s.partial_sum[s.num_inputs-1]
  
  always_comb begin : _lambda__s_dut_cgra_0__tile_0__element_fu_12__reduce_add_out
    out = partial_sum[3'd4 - 3'd1];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/SumUnit.py:31
  // @update
  // def up_sum():
  //   s.partial_sum[0] @= s.in_[0]
  //   for i in range( 1, s.num_inputs ):
  //     s.partial_sum[i] @= s.partial_sum[i-1] + s.in_[i]
  
  always_comb begin : up_sum
    partial_sum[2'd0] = in_[2'd0];
    for ( int unsigned i = 1'd1; i < 3'd4; i += 1'd1 )
      partial_sum[2'(i)] = partial_sum[2'(i) - 2'd1] + in_[2'(i)];
  end

endmodule


// PyMTL Component VectorMulComboRTL Definition
// Full name: VectorMulComboRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__PredicateType_CGRAData_1_1__payload_1__predicate_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__num_inports_4__num_outports_2__data_mem_size_288__num_lanes_4__data_bandwidth_32
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/vector/VectorMulComboRTL.py

module VectorMulComboRTL__a499f8f134d9aa6b
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  input CGRAData_1_1__payload_1__predicate_1 recv_predicate__msg  ,
  output logic [0:0] recv_predicate__rdy  ,
  input logic [0:0] recv_predicate__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [5:0] __const__OPT_VEC_MUL  = 6'd55;
  localparam logic [0:0] __const__i_at__lambda__s_dut_cgra_0__tile_0__element_fu_12__reduce_add_in__0_  = 1'd0;
  localparam logic [0:0] __const__i_at__lambda__s_dut_cgra_0__tile_0__element_fu_12__reduce_add_in__1_  = 1'd1;
  localparam logic [1:0] __const__i_at__lambda__s_dut_cgra_0__tile_0__element_fu_12__reduce_add_in__2_  = 2'd2;
  localparam logic [1:0] __const__i_at__lambda__s_dut_cgra_0__tile_0__element_fu_12__reduce_add_in__3_  = 2'd3;
  localparam logic [1:0] __const__num_outports_at_update_input_output  = 2'd2;
  localparam logic [2:0] __const__num_lanes_at_update_input_output  = 3'd4;
  localparam logic [3:0] __const__sub_bw_at_update_input_output  = 4'd8;
  localparam logic [4:0] __const__sub_bw_2_at_update_input_output  = 5'd16;
  localparam logic [4:0] __const__sub_bw_3_at_update_input_output  = 5'd24;
  localparam logic [5:0] __const__sub_bw_4_at_update_input_output  = 6'd32;
  localparam logic [5:0] __const__data_bandwidth_at_update_input_output  = 6'd32;
  localparam logic [5:0] __const__OPT_MUL  = 6'd7;
  localparam logic [2:0] __const__num_lanes_at_update_signal  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_update_signal  = 2'd2;
  localparam logic [2:0] __const__num_lanes_at_update_opt  = 3'd4;
  localparam logic [5:0] __const__OPT_NAH  = 6'd1;
  logic [31:0] temp_result [0:3];
  //-------------------------------------------------------------
  // Component Fu[0:3]
  //-------------------------------------------------------------

  logic [0:0] Fu__clk [0:3];
  logic [0:0] Fu__reset [0:3];
  logic [15:0] Fu__recv_const__msg [0:3];
  logic [0:0] Fu__recv_const__rdy [0:3];
  logic [0:0] Fu__recv_const__val [0:3];
  logic [15:0] Fu__recv_in__msg [0:3][0:3];
  logic [0:0] Fu__recv_in__rdy [0:3][0:3];
  logic [0:0] Fu__recv_in__val [0:3][0:3];
  CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf Fu__recv_opt__msg [0:3];
  logic [0:0] Fu__recv_opt__rdy [0:3];
  logic [0:0] Fu__recv_opt__val [0:3];
  logic [15:0] Fu__send_out__msg [0:3][0:1];
  logic [0:0] Fu__send_out__rdy [0:3][0:1];
  logic [0:0] Fu__send_out__val [0:3][0:1];

  VectorMulRTL__09e44bc1b5c59ebc Fu__0
  (
    .clk( Fu__clk[0] ),
    .reset( Fu__reset[0] ),
    .recv_const__msg( Fu__recv_const__msg[0] ),
    .recv_const__rdy( Fu__recv_const__rdy[0] ),
    .recv_const__val( Fu__recv_const__val[0] ),
    .recv_in__msg( Fu__recv_in__msg[0] ),
    .recv_in__rdy( Fu__recv_in__rdy[0] ),
    .recv_in__val( Fu__recv_in__val[0] ),
    .recv_opt__msg( Fu__recv_opt__msg[0] ),
    .recv_opt__rdy( Fu__recv_opt__rdy[0] ),
    .recv_opt__val( Fu__recv_opt__val[0] ),
    .send_out__msg( Fu__send_out__msg[0] ),
    .send_out__rdy( Fu__send_out__rdy[0] ),
    .send_out__val( Fu__send_out__val[0] )
  );

  VectorMulRTL__09e44bc1b5c59ebc Fu__1
  (
    .clk( Fu__clk[1] ),
    .reset( Fu__reset[1] ),
    .recv_const__msg( Fu__recv_const__msg[1] ),
    .recv_const__rdy( Fu__recv_const__rdy[1] ),
    .recv_const__val( Fu__recv_const__val[1] ),
    .recv_in__msg( Fu__recv_in__msg[1] ),
    .recv_in__rdy( Fu__recv_in__rdy[1] ),
    .recv_in__val( Fu__recv_in__val[1] ),
    .recv_opt__msg( Fu__recv_opt__msg[1] ),
    .recv_opt__rdy( Fu__recv_opt__rdy[1] ),
    .recv_opt__val( Fu__recv_opt__val[1] ),
    .send_out__msg( Fu__send_out__msg[1] ),
    .send_out__rdy( Fu__send_out__rdy[1] ),
    .send_out__val( Fu__send_out__val[1] )
  );

  VectorMulRTL__09e44bc1b5c59ebc Fu__2
  (
    .clk( Fu__clk[2] ),
    .reset( Fu__reset[2] ),
    .recv_const__msg( Fu__recv_const__msg[2] ),
    .recv_const__rdy( Fu__recv_const__rdy[2] ),
    .recv_const__val( Fu__recv_const__val[2] ),
    .recv_in__msg( Fu__recv_in__msg[2] ),
    .recv_in__rdy( Fu__recv_in__rdy[2] ),
    .recv_in__val( Fu__recv_in__val[2] ),
    .recv_opt__msg( Fu__recv_opt__msg[2] ),
    .recv_opt__rdy( Fu__recv_opt__rdy[2] ),
    .recv_opt__val( Fu__recv_opt__val[2] ),
    .send_out__msg( Fu__send_out__msg[2] ),
    .send_out__rdy( Fu__send_out__rdy[2] ),
    .send_out__val( Fu__send_out__val[2] )
  );

  VectorMulRTL__09e44bc1b5c59ebc Fu__3
  (
    .clk( Fu__clk[3] ),
    .reset( Fu__reset[3] ),
    .recv_const__msg( Fu__recv_const__msg[3] ),
    .recv_const__rdy( Fu__recv_const__rdy[3] ),
    .recv_const__val( Fu__recv_const__val[3] ),
    .recv_in__msg( Fu__recv_in__msg[3] ),
    .recv_in__rdy( Fu__recv_in__rdy[3] ),
    .recv_in__val( Fu__recv_in__val[3] ),
    .recv_opt__msg( Fu__recv_opt__msg[3] ),
    .recv_opt__rdy( Fu__recv_opt__rdy[3] ),
    .recv_opt__val( Fu__recv_opt__val[3] ),
    .send_out__msg( Fu__send_out__msg[3] ),
    .send_out__rdy( Fu__send_out__rdy[3] ),
    .send_out__val( Fu__send_out__val[3] )
  );

  //-------------------------------------------------------------
  // End of component Fu[0:3]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component reduce_add
  //-------------------------------------------------------------

  logic [0:0] reduce_add__clk;
  logic [31:0] reduce_add__in_ [0:3];
  logic [31:0] reduce_add__out;
  logic [0:0] reduce_add__reset;

  SumUnit__DataType_Bits32__num_inputs_4 reduce_add
  (
    .clk( reduce_add__clk ),
    .in_( reduce_add__in_ ),
    .out( reduce_add__out ),
    .reset( reduce_add__reset )
  );

  //-------------------------------------------------------------
  // End of component reduce_add
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/vector/VectorMulComboRTL.py:69
  // s.reduce_add.in_[i] //= lambda: (s.temp_result[i]
  //     if s.recv_opt.msg.operation == OPT_VEC_MUL else 0)
  
  always_comb begin : _lambda__s_dut_cgra_0__tile_0__element_fu_12__reduce_add_in__0_
    reduce_add__in_[2'd0] = ( recv_opt__msg.operation == 6'( __const__OPT_VEC_MUL ) ) ? temp_result[2'( __const__i_at__lambda__s_dut_cgra_0__tile_0__element_fu_12__reduce_add_in__0_ )] : 32'd0;
  end

  // PyMTL Lambda Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/vector/VectorMulComboRTL.py:69
  // s.reduce_add.in_[i] //= lambda: (s.temp_result[i]
  //     if s.recv_opt.msg.operation == OPT_VEC_MUL else 0)
  
  always_comb begin : _lambda__s_dut_cgra_0__tile_0__element_fu_12__reduce_add_in__1_
    reduce_add__in_[2'd1] = ( recv_opt__msg.operation == 6'( __const__OPT_VEC_MUL ) ) ? temp_result[2'( __const__i_at__lambda__s_dut_cgra_0__tile_0__element_fu_12__reduce_add_in__1_ )] : 32'd0;
  end

  // PyMTL Lambda Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/vector/VectorMulComboRTL.py:69
  // s.reduce_add.in_[i] //= lambda: (s.temp_result[i]
  //     if s.recv_opt.msg.operation == OPT_VEC_MUL else 0)
  
  always_comb begin : _lambda__s_dut_cgra_0__tile_0__element_fu_12__reduce_add_in__2_
    reduce_add__in_[2'd2] = ( recv_opt__msg.operation == 6'( __const__OPT_VEC_MUL ) ) ? temp_result[2'( __const__i_at__lambda__s_dut_cgra_0__tile_0__element_fu_12__reduce_add_in__2_ )] : 32'd0;
  end

  // PyMTL Lambda Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/vector/VectorMulComboRTL.py:69
  // s.reduce_add.in_[i] //= lambda: (s.temp_result[i]
  //     if s.recv_opt.msg.operation == OPT_VEC_MUL else 0)
  
  always_comb begin : _lambda__s_dut_cgra_0__tile_0__element_fu_12__reduce_add_in__3_
    reduce_add__in_[2'd3] = ( recv_opt__msg.operation == 6'( __const__OPT_VEC_MUL ) ) ? temp_result[2'( __const__i_at__lambda__s_dut_cgra_0__tile_0__element_fu_12__reduce_add_in__3_ )] : 32'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/vector/VectorMulComboRTL.py:72
  // @update
  // def update_input_output():
  // 
  //   # Initialization to avoid latches
  //   for j in range(num_outports):
  //     s.send_out[j].val @= b1(0)
  // 
  //   s.send_out[0].val @= s.Fu[0].send_out[0].val & \
  //                        s.recv_opt.val
  //   s.send_out[0].msg.payload @= 0
  // 
  //   for i in range(num_lanes):
  //     s.temp_result[i] @= TempDataType(0)
  //     s.Fu[i].recv_in[0].msg[0:sub_bw] @= FuDataType()
  //     s.Fu[i].recv_in[1].msg[0:sub_bw] @= FuDataType()
  // 
  //   if s.recv_opt.msg.operation == OPT_VEC_MUL:
  //     # Connection: split into vectorized FUs
  //     s.Fu[0].recv_in[0].msg[0:sub_bw] @= s.recv_in[0].msg.payload[0:sub_bw]
  //     s.Fu[0].recv_in[1].msg[0:sub_bw] @= s.recv_in[1].msg.payload[0:sub_bw]
  //     s.Fu[1].recv_in[0].msg[0:sub_bw] @= s.recv_in[0].msg.payload[sub_bw:sub_bw_2]
  //     s.Fu[1].recv_in[1].msg[0:sub_bw] @= s.recv_in[1].msg.payload[sub_bw:sub_bw_2]
  //     s.Fu[2].recv_in[0].msg[0:sub_bw] @= s.recv_in[0].msg.payload[sub_bw_2:sub_bw_3]
  //     s.Fu[2].recv_in[1].msg[0:sub_bw] @= s.recv_in[1].msg.payload[sub_bw_2:sub_bw_3]
  //     s.Fu[3].recv_in[0].msg[0:sub_bw] @= s.recv_in[0].msg.payload[sub_bw_3:sub_bw_4]
  //     s.Fu[3].recv_in[1].msg[0:sub_bw] @= s.recv_in[1].msg.payload[sub_bw_3:sub_bw_4]
  // 
  //     for i in range(num_lanes):
  //       s.temp_result[i] @= TempDataType(0)
  //       s.temp_result[i][0:sub_bw_2] @= s.Fu[i].send_out[0].msg[0:sub_bw_2] << (sub_bw * i)
  // 
  //     s.send_out[0].msg.payload[0:data_bandwidth] @= s.reduce_add.out
  // 
  //   elif s.recv_opt.msg.operation == OPT_MUL: # with highest precision
  //     s.Fu[0].recv_in[0].msg[0:sub_bw] @= s.recv_in[0].msg.payload[0:sub_bw]
  //     s.Fu[0].recv_in[1].msg[0:sub_bw] @= s.recv_in[1].msg.payload[0:sub_bw]
  //     s.Fu[1].recv_in[0].msg[0:sub_bw] @= s.recv_in[0].msg.payload[0:sub_bw]
  //     s.Fu[1].recv_in[1].msg[0:sub_bw] @= s.recv_in[1].msg.payload[sub_bw:sub_bw_2]
  //     s.Fu[2].recv_in[0].msg[0:sub_bw] @= s.recv_in[0].msg.payload[sub_bw:sub_bw_2]
  //     s.Fu[2].recv_in[1].msg[0:sub_bw] @= s.recv_in[1].msg.payload[0:sub_bw]
  //     s.Fu[3].recv_in[0].msg[0:sub_bw] @= s.recv_in[0].msg.payload[sub_bw:sub_bw_2]
  //     s.Fu[3].recv_in[1].msg[0:sub_bw] @= s.recv_in[1].msg.payload[sub_bw:sub_bw_2]
  // 
  //     for i in range(num_lanes):
  //       s.temp_result[i] @= TempDataType( 0 )
  //       s.temp_result[i][0:sub_bw_2] @= s.Fu[i].send_out[0].msg[0:sub_bw_2]
  // 
  //     s.send_out[0].msg.payload[0:data_bandwidth] @= \
  //         s.temp_result[0] + \
  //         (s.temp_result[1] << sub_bw) + \
  //         (s.temp_result[2] << sub_bw) + \
  //         (s.temp_result[3] << (sub_bw*2))
  // 
  //   else:
  //     for j in range(num_outports):
  //       s.send_out[j].val @= b1(0)
  
  always_comb begin : update_input_output
    for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_update_input_output ); j += 1'd1 )
      send_out__val[1'(j)] = 1'd0;
    send_out__val[1'd0] = Fu__send_out__val[2'd0][1'd0] & recv_opt__val;
    send_out__msg[1'd0].payload = 32'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_lanes_at_update_input_output ); i += 1'd1 ) begin
      temp_result[2'(i)] = 32'd0;
      Fu__recv_in__msg[2'(i)][2'd0][4'd7:4'd0] = 8'd0;
      Fu__recv_in__msg[2'(i)][2'd1][4'd7:4'd0] = 8'd0;
    end
    if ( recv_opt__msg.operation == 6'( __const__OPT_VEC_MUL ) ) begin
      Fu__recv_in__msg[2'd0][2'd0][4'd7:4'd0] = recv_in__msg[2'd0].payload[5'd7:5'd0];
      Fu__recv_in__msg[2'd0][2'd1][4'd7:4'd0] = recv_in__msg[2'd1].payload[5'd7:5'd0];
      Fu__recv_in__msg[2'd1][2'd0][4'd7:4'd0] = recv_in__msg[2'd0].payload[5'd15:5'( __const__sub_bw_at_update_input_output )];
      Fu__recv_in__msg[2'd1][2'd1][4'd7:4'd0] = recv_in__msg[2'd1].payload[5'd15:5'( __const__sub_bw_at_update_input_output )];
      Fu__recv_in__msg[2'd2][2'd0][4'd7:4'd0] = recv_in__msg[2'd0].payload[5'd23:5'( __const__sub_bw_2_at_update_input_output )];
      Fu__recv_in__msg[2'd2][2'd1][4'd7:4'd0] = recv_in__msg[2'd1].payload[5'd23:5'( __const__sub_bw_2_at_update_input_output )];
      Fu__recv_in__msg[2'd3][2'd0][4'd7:4'd0] = recv_in__msg[2'd0].payload[5'd31:5'( __const__sub_bw_3_at_update_input_output )];
      Fu__recv_in__msg[2'd3][2'd1][4'd7:4'd0] = recv_in__msg[2'd1].payload[5'd31:5'( __const__sub_bw_3_at_update_input_output )];
      for ( int unsigned i = 1'd0; i < 3'( __const__num_lanes_at_update_input_output ); i += 1'd1 ) begin
        temp_result[2'(i)] = 32'd0;
        temp_result[2'(i)][5'd15:5'd0] = Fu__send_out__msg[2'(i)][1'd0][4'd15:4'd0] << ( 4'( __const__sub_bw_at_update_input_output ) * 4'(i) );
      end
      send_out__msg[1'd0].payload[5'd31:5'd0] = reduce_add__out;
    end
    else if ( recv_opt__msg.operation == 6'( __const__OPT_MUL ) ) begin
      Fu__recv_in__msg[2'd0][2'd0][4'd7:4'd0] = recv_in__msg[2'd0].payload[5'd7:5'd0];
      Fu__recv_in__msg[2'd0][2'd1][4'd7:4'd0] = recv_in__msg[2'd1].payload[5'd7:5'd0];
      Fu__recv_in__msg[2'd1][2'd0][4'd7:4'd0] = recv_in__msg[2'd0].payload[5'd7:5'd0];
      Fu__recv_in__msg[2'd1][2'd1][4'd7:4'd0] = recv_in__msg[2'd1].payload[5'd15:5'( __const__sub_bw_at_update_input_output )];
      Fu__recv_in__msg[2'd2][2'd0][4'd7:4'd0] = recv_in__msg[2'd0].payload[5'd15:5'( __const__sub_bw_at_update_input_output )];
      Fu__recv_in__msg[2'd2][2'd1][4'd7:4'd0] = recv_in__msg[2'd1].payload[5'd7:5'd0];
      Fu__recv_in__msg[2'd3][2'd0][4'd7:4'd0] = recv_in__msg[2'd0].payload[5'd15:5'( __const__sub_bw_at_update_input_output )];
      Fu__recv_in__msg[2'd3][2'd1][4'd7:4'd0] = recv_in__msg[2'd1].payload[5'd15:5'( __const__sub_bw_at_update_input_output )];
      for ( int unsigned i = 1'd0; i < 3'( __const__num_lanes_at_update_input_output ); i += 1'd1 ) begin
        temp_result[2'(i)] = 32'd0;
        temp_result[2'(i)][5'd15:5'd0] = Fu__send_out__msg[2'(i)][1'd0][4'd15:4'd0];
      end
      send_out__msg[1'd0].payload[5'd31:5'd0] = ( ( temp_result[2'd0] + ( temp_result[2'd1] << 4'( __const__sub_bw_at_update_input_output ) ) ) + ( temp_result[2'd2] << 4'( __const__sub_bw_at_update_input_output ) ) ) + ( temp_result[2'd3] << ( 4'( __const__sub_bw_at_update_input_output ) * 4'd2 ) );
    end
    else
      for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_update_input_output ); j += 1'd1 )
        send_out__val[1'(j)] = 1'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/vector/VectorMulComboRTL.py:170
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val   @= b1( 0 )
  //   s.to_mem_wdata.val   @= b1( 0 )
  //   s.to_mem_wdata.msg   @= s.const_zero
  //   s.to_mem_waddr.msg   @= AddrType( 0 )
  //   s.to_mem_raddr.msg   @= AddrType( 0 )
  //   s.to_mem_raddr.val   @= b1( 0 )
  //   s.from_mem_rdata.rdy @= b1( 0 )
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/vector/VectorMulComboRTL.py:151
  // @update
  // def update_opt():
  //   s.recv_predicate.rdy @= b1(0)
  //   s.send_out[0].msg.predicate @= b1(0)
  // 
  //   for i in range(num_lanes):
  //     s.Fu[i].recv_opt.msg.fu_in[0] @= 1
  //     s.Fu[i].recv_opt.msg.fu_in[1] @= 2
  //     s.Fu[i].recv_opt.msg.operation @= OPT_NAH
  // 
  //   if s.recv_opt.msg.predicate == b1(1):
  //     s.recv_predicate.rdy @= b1(1)
  // 
  //   if (s.recv_opt.msg.operation == OPT_VEC_MUL) | \
  //      (s.recv_opt.msg.operation == OPT_MUL):
  //     for i in range(num_lanes):
  //       s.Fu[i].recv_opt.msg.operation @= OPT_MUL
  //     s.send_out[0].msg.predicate @= s.recv_in[0].msg.predicate & s.recv_in[1].msg.predicate
  
  always_comb begin : update_opt
    recv_predicate__rdy = 1'd0;
    send_out__msg[1'd0].predicate = 1'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_lanes_at_update_opt ); i += 1'd1 ) begin
      Fu__recv_opt__msg[2'(i)].fu_in[2'd0] = 3'd1;
      Fu__recv_opt__msg[2'(i)].fu_in[2'd1] = 3'd2;
      Fu__recv_opt__msg[2'(i)].operation = 6'( __const__OPT_NAH );
    end
    if ( recv_opt__msg.predicate == 1'd1 ) begin
      recv_predicate__rdy = 1'd1;
    end
    if ( ( recv_opt__msg.operation == 6'( __const__OPT_VEC_MUL ) ) | ( recv_opt__msg.operation == 6'( __const__OPT_MUL ) ) ) begin
      for ( int unsigned i = 1'd0; i < 3'( __const__num_lanes_at_update_opt ); i += 1'd1 )
        Fu__recv_opt__msg[2'(i)].operation = 6'( __const__OPT_MUL );
      send_out__msg[1'd0].predicate = recv_in__msg[2'd0].predicate & recv_in__msg[2'd1].predicate;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/vector/VectorMulComboRTL.py:129
  // @update
  // def update_signal():
  //   s.recv_in[0].rdy @= s.Fu[0].recv_in[0].rdy
  //   s.recv_in[1].rdy @= s.Fu[0].recv_in[1].rdy
  // 
  //   for i in range(num_lanes):
  //     s.Fu[i].recv_opt.val @= s.recv_opt.val
  // 
  //     # Note that the predication for a combined FU should be identical/shareable,
  //     # which means the computation in different basic block cannot be combined.
  //     # s.Fu[i].recv_opt.msg.predicate = s.recv_opt.msg.predicate
  // 
  //     s.Fu[i].recv_in[0].val @= s.recv_in[0].val
  //     s.Fu[i].recv_in[1].val @= s.recv_in[1].val
  //     s.Fu[i].recv_const.val @= s.recv_const.val
  // 
  //     for j in range(num_outports):
  //       s.Fu[i].send_out[j].rdy @= s.send_out[j].rdy
  // 
  //   s.recv_const.rdy @= s.Fu[0].recv_const.rdy
  //   s.recv_opt.rdy @= s.send_out[0].rdy
  
  always_comb begin : update_signal
    recv_in__rdy[2'd0] = Fu__recv_in__rdy[2'd0][2'd0];
    recv_in__rdy[2'd1] = Fu__recv_in__rdy[2'd0][2'd1];
    for ( int unsigned i = 1'd0; i < 3'( __const__num_lanes_at_update_signal ); i += 1'd1 ) begin
      Fu__recv_opt__val[2'(i)] = recv_opt__val;
      Fu__recv_in__val[2'(i)][2'd0] = recv_in__val[2'd0];
      Fu__recv_in__val[2'(i)][2'd1] = recv_in__val[2'd1];
      Fu__recv_const__val[2'(i)] = recv_const__val;
      for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_update_signal ); j += 1'd1 )
        Fu__send_out__rdy[2'(i)][1'(j)] = send_out__rdy[1'(j)];
    end
    recv_const__rdy = Fu__recv_const__rdy[2'd0];
    recv_opt__rdy = send_out__rdy[1'd0];
  end

  assign Fu__clk[0] = clk;
  assign Fu__reset[0] = reset;
  assign Fu__clk[1] = clk;
  assign Fu__reset[1] = reset;
  assign Fu__clk[2] = clk;
  assign Fu__reset[2] = reset;
  assign Fu__clk[3] = clk;
  assign Fu__reset[3] = reset;
  assign reduce_add__clk = clk;
  assign reduce_add__reset = reset;

endmodule


// PyMTL Component VectorAdderRTL Definition
// Full name: VectorAdderRTL__bw_8__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__num_inports_4__num_outports_2__data_mem_size_288
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/vector/VectorAdderRTL.py

module VectorAdderRTL__09e44bc1b5c59ebc
(
  input  logic [0:0] carry_in ,
  output logic [0:0] carry_out ,
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [8:0] recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input logic [8:0] recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output logic [8:0] send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] 
);
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [5:0] __const__OPT_ADD  = 6'd2;
  localparam logic [5:0] __const__OPT_ADD_CONST  = 6'd25;
  localparam logic [5:0] __const__OPT_INC  = 6'd3;
  localparam logic [5:0] __const__OPT_SUB  = 6'd4;
  localparam logic [5:0] __const__OPT_SUB_CONST  = 6'd36;
  localparam logic [5:0] __const__OPT_PAS  = 6'd31;
  localparam logic [3:0] __const__bw_at_comb_logic  = 4'd8;
  logic [8:0] carry_in_temp;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [0:0] recv_all_val;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/vector/VectorAdderRTL.py:57
  // @update
  // def comb_logic():
  // 
  //   s.recv_all_val @= 0
  //   # For pick input register
  //   s.in0 @= 0
  //   s.in1 @= 0
  //   for i in range( num_inports ):
  //     s.recv_in[i].rdy @= b1( 0 )
  // 
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  //   for i in range( num_outports ):
  //     s.send_out[i].val @= b1(0)
  //     s.send_out[i].msg @= DataType()
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_opt.rdy @= 0
  // 
  //   s.carry_in_temp[0] @= s.carry_in
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != FuInType(0):
  //       s.in0 @= s.recv_opt.msg.fu_in[0] - FuInType(1)
  //     if s.recv_opt.msg.fu_in[1] != FuInType(0):
  //       s.in1 @= s.recv_opt.msg.fu_in[1] - FuInType(1)
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.operation == OPT_ADD:
  //       s.send_out[0].msg @= s.recv_in[s.in0_idx].msg + s.recv_in[s.in1_idx].msg + s.carry_in_temp
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_ADD_CONST:
  //       s.send_out[0].msg @= s.recv_in[s.in0_idx].msg + s.recv_const.msg + s.carry_in_temp
  //       s.recv_const.rdy @= s.send_out[0].rdy
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_const.val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_const.rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_INC:
  //       s.send_out[0].msg @= s.recv_in[s.in0_idx].msg + s.const_one
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_SUB:
  //       s.send_out[0].msg @= s.recv_in[s.in0_idx].msg - s.recv_in[s.in1_idx].msg - s.carry_in_temp
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_SUB_CONST:
  //       s.send_out[0].msg @= s.recv_in[s.in0_idx].msg - s.recv_const.msg - s.carry_in_temp
  //       s.recv_const.rdy @= s.send_out[0].rdy
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_const.val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_const.rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_PAS:
  //       s.send_out[0].msg @= s.recv_in[s.in0_idx].msg
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     else:
  //       for j in range( num_outports ):
  //         s.send_out[j].val @= b1( 0 )
  //       s.recv_opt.rdy @= 0
  //       s.recv_in[s.in0_idx].rdy @= 0
  //       s.recv_in[s.in1_idx].rdy @= 0
  // 
  //   s.carry_out @= s.send_out[0].msg[bw:bw+1]
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = 9'd0;
    end
    recv_const__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    carry_in_temp[4'd0] = carry_in;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 6'( __const__OPT_ADD ) ) begin
        send_out__msg[1'd0] = ( recv_in__msg[in0_idx] + recv_in__msg[in1_idx] ) + carry_in_temp;
        recv_all_val = recv_in__val[in0_idx] & recv_in__val[in1_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_ADD_CONST ) ) begin
        send_out__msg[1'd0] = ( recv_in__msg[in0_idx] + recv_const__msg ) + carry_in_temp;
        recv_const__rdy = send_out__rdy[1'd0];
        recv_all_val = recv_in__val[in0_idx] & recv_const__val;
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_const__rdy = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_INC ) ) begin
        send_out__msg[1'd0] = recv_in__msg[in0_idx] + 9'd1;
        recv_all_val = recv_in__val[in0_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_SUB ) ) begin
        send_out__msg[1'd0] = ( recv_in__msg[in0_idx] - recv_in__msg[in1_idx] ) - carry_in_temp;
        recv_all_val = recv_in__val[in0_idx] & recv_in__val[in1_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_SUB_CONST ) ) begin
        send_out__msg[1'd0] = ( recv_in__msg[in0_idx] - recv_const__msg ) - carry_in_temp;
        recv_const__rdy = send_out__rdy[1'd0];
        recv_all_val = recv_in__val[in0_idx] & recv_const__val;
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_const__rdy = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_PAS ) ) begin
        send_out__msg[1'd0] = recv_in__msg[in0_idx];
        recv_all_val = recv_in__val[in0_idx];
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
      end
    end
    carry_out = send_out__msg[1'd0][4'd8:4'( __const__bw_at_comb_logic )];
  end

  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];

endmodule


// PyMTL Component VectorAdderComboRTL Definition
// Full name: VectorAdderComboRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__PredicateType_CGRAData_1_1__payload_1__predicate_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__num_inports_4__num_outports_2__data_mem_size_288__num_lanes_4__data_bandwidth_32
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/vector/VectorAdderComboRTL.py

module VectorAdderComboRTL__a499f8f134d9aa6b
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  input CGRAData_1_1__payload_1__predicate_1 recv_predicate__msg  ,
  output logic [0:0] recv_predicate__rdy  ,
  input logic [0:0] recv_predicate__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [2:0] __const__num_lanes_at_update_signal  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_update_signal  = 2'd2;
  localparam logic [1:0] __const__num_outports_at_update_opt  = 2'd2;
  localparam logic [2:0] __const__num_lanes_at_update_opt  = 3'd4;
  localparam logic [5:0] __const__OPT_NAH  = 6'd1;
  localparam logic [5:0] __const__OPT_VEC_ADD  = 6'd50;
  localparam logic [5:0] __const__OPT_ADD  = 6'd2;
  localparam logic [5:0] __const__OPT_VEC_SUB  = 6'd53;
  localparam logic [5:0] __const__OPT_SUB  = 6'd4;
  localparam logic [5:0] __const__OPT_VEC_ADD_CONST  = 6'd52;
  localparam logic [5:0] __const__OPT_ADD_CONST  = 6'd25;
  localparam logic [5:0] __const__OPT_VEC_SUB_CONST  = 6'd54;
  localparam logic [5:0] __const__OPT_SUB_CONST  = 6'd36;
  //-------------------------------------------------------------
  // Component Fu[0:3]
  //-------------------------------------------------------------

  logic [0:0] Fu__carry_in [0:3];
  logic [0:0] Fu__carry_out [0:3];
  logic [0:0] Fu__clk [0:3];
  logic [0:0] Fu__reset [0:3];
  logic [8:0] Fu__recv_const__msg [0:3];
  logic [0:0] Fu__recv_const__rdy [0:3];
  logic [0:0] Fu__recv_const__val [0:3];
  logic [8:0] Fu__recv_in__msg [0:3][0:3];
  logic [0:0] Fu__recv_in__rdy [0:3][0:3];
  logic [0:0] Fu__recv_in__val [0:3][0:3];
  CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf Fu__recv_opt__msg [0:3];
  logic [0:0] Fu__recv_opt__rdy [0:3];
  logic [0:0] Fu__recv_opt__val [0:3];
  logic [8:0] Fu__send_out__msg [0:3][0:1];
  logic [0:0] Fu__send_out__rdy [0:3][0:1];
  logic [0:0] Fu__send_out__val [0:3][0:1];

  VectorAdderRTL__09e44bc1b5c59ebc Fu__0
  (
    .carry_in( Fu__carry_in[0] ),
    .carry_out( Fu__carry_out[0] ),
    .clk( Fu__clk[0] ),
    .reset( Fu__reset[0] ),
    .recv_const__msg( Fu__recv_const__msg[0] ),
    .recv_const__rdy( Fu__recv_const__rdy[0] ),
    .recv_const__val( Fu__recv_const__val[0] ),
    .recv_in__msg( Fu__recv_in__msg[0] ),
    .recv_in__rdy( Fu__recv_in__rdy[0] ),
    .recv_in__val( Fu__recv_in__val[0] ),
    .recv_opt__msg( Fu__recv_opt__msg[0] ),
    .recv_opt__rdy( Fu__recv_opt__rdy[0] ),
    .recv_opt__val( Fu__recv_opt__val[0] ),
    .send_out__msg( Fu__send_out__msg[0] ),
    .send_out__rdy( Fu__send_out__rdy[0] ),
    .send_out__val( Fu__send_out__val[0] )
  );

  VectorAdderRTL__09e44bc1b5c59ebc Fu__1
  (
    .carry_in( Fu__carry_in[1] ),
    .carry_out( Fu__carry_out[1] ),
    .clk( Fu__clk[1] ),
    .reset( Fu__reset[1] ),
    .recv_const__msg( Fu__recv_const__msg[1] ),
    .recv_const__rdy( Fu__recv_const__rdy[1] ),
    .recv_const__val( Fu__recv_const__val[1] ),
    .recv_in__msg( Fu__recv_in__msg[1] ),
    .recv_in__rdy( Fu__recv_in__rdy[1] ),
    .recv_in__val( Fu__recv_in__val[1] ),
    .recv_opt__msg( Fu__recv_opt__msg[1] ),
    .recv_opt__rdy( Fu__recv_opt__rdy[1] ),
    .recv_opt__val( Fu__recv_opt__val[1] ),
    .send_out__msg( Fu__send_out__msg[1] ),
    .send_out__rdy( Fu__send_out__rdy[1] ),
    .send_out__val( Fu__send_out__val[1] )
  );

  VectorAdderRTL__09e44bc1b5c59ebc Fu__2
  (
    .carry_in( Fu__carry_in[2] ),
    .carry_out( Fu__carry_out[2] ),
    .clk( Fu__clk[2] ),
    .reset( Fu__reset[2] ),
    .recv_const__msg( Fu__recv_const__msg[2] ),
    .recv_const__rdy( Fu__recv_const__rdy[2] ),
    .recv_const__val( Fu__recv_const__val[2] ),
    .recv_in__msg( Fu__recv_in__msg[2] ),
    .recv_in__rdy( Fu__recv_in__rdy[2] ),
    .recv_in__val( Fu__recv_in__val[2] ),
    .recv_opt__msg( Fu__recv_opt__msg[2] ),
    .recv_opt__rdy( Fu__recv_opt__rdy[2] ),
    .recv_opt__val( Fu__recv_opt__val[2] ),
    .send_out__msg( Fu__send_out__msg[2] ),
    .send_out__rdy( Fu__send_out__rdy[2] ),
    .send_out__val( Fu__send_out__val[2] )
  );

  VectorAdderRTL__09e44bc1b5c59ebc Fu__3
  (
    .carry_in( Fu__carry_in[3] ),
    .carry_out( Fu__carry_out[3] ),
    .clk( Fu__clk[3] ),
    .reset( Fu__reset[3] ),
    .recv_const__msg( Fu__recv_const__msg[3] ),
    .recv_const__rdy( Fu__recv_const__rdy[3] ),
    .recv_const__val( Fu__recv_const__val[3] ),
    .recv_in__msg( Fu__recv_in__msg[3] ),
    .recv_in__rdy( Fu__recv_in__rdy[3] ),
    .recv_in__val( Fu__recv_in__val[3] ),
    .recv_opt__msg( Fu__recv_opt__msg[3] ),
    .recv_opt__rdy( Fu__recv_opt__rdy[3] ),
    .recv_opt__val( Fu__recv_opt__val[3] ),
    .send_out__msg( Fu__send_out__msg[3] ),
    .send_out__rdy( Fu__send_out__rdy[3] ),
    .send_out__val( Fu__send_out__val[3] )
  );

  //-------------------------------------------------------------
  // End of component Fu[0:3]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/vector/VectorAdderComboRTL.py:135
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val   @= b1( 0 )
  //   s.to_mem_wdata.val   @= b1( 0 )
  //   s.to_mem_wdata.msg   @= s.const_zero
  //   s.to_mem_waddr.msg   @= AddrType( 0 )
  //   s.to_mem_raddr.msg   @= AddrType( 0 )
  //   s.to_mem_raddr.val   @= b1( 0 )
  //   s.from_mem_rdata.rdy @= b1( 0 )
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/vector/VectorAdderComboRTL.py:87
  // @update
  // def update_opt():
  // 
  //   for j in range( num_outports ):
  //     s.send_out[j].val @= b1(0)
  //     s.send_out[j].msg.predicate @= b1(0)
  // 
  //   s.send_out[0].val @= s.Fu[0].send_out[0].val & \
  //                        s.recv_opt.val
  // 
  //   s.recv_predicate.rdy @= b1(0)
  // 
  //   for i in range(num_lanes):
  //     s.Fu[i].recv_opt.msg.fu_in[0] @= 1
  //     s.Fu[i].recv_opt.msg.fu_in[1] @= 2
  //     s.Fu[i].recv_opt.msg.operation @= OPT_NAH
  // 
  //   if s.recv_opt.msg.predicate == b1( 1 ):
  //     s.recv_predicate.rdy @= b1( 1 )
  // 
  //   if ( s.recv_opt.msg.operation == OPT_VEC_ADD ) | \
  //      ( s.recv_opt.msg.operation == OPT_ADD ):
  //     for i in range(num_lanes):
  //       s.Fu[i].recv_opt.msg.operation @= OPT_ADD
  //     s.send_out[0].msg.predicate @= s.recv_in[0].msg.predicate & s.recv_in[1].msg.predicate
  // 
  //   elif ( s.recv_opt.msg.operation == OPT_VEC_SUB ) | \
  //        ( s.recv_opt.msg.operation == OPT_SUB ):
  //     for i in range(num_lanes):
  //       s.Fu[i].recv_opt.msg.operation @= OPT_SUB
  //     s.send_out[0].msg.predicate @= s.recv_in[0].msg.predicate & s.recv_in[1].msg.predicate
  // 
  //   elif ( s.recv_opt.msg.operation == OPT_VEC_ADD_CONST ) | \
  //        ( s.recv_opt.msg.operation == OPT_ADD_CONST ):
  //     for i in range(num_lanes):
  //       s.Fu[i].recv_opt.msg.operation @= OPT_ADD_CONST
  //     s.send_out[0].msg.predicate @= s.recv_in[0].msg.predicate
  // 
  //   elif (s.recv_opt.msg.operation == OPT_VEC_SUB_CONST ) | \
  //        (s.recv_opt.msg.operation == OPT_SUB_CONST ):
  //     for i in range(num_lanes):
  //       s.Fu[i].recv_opt.msg.operation @= OPT_SUB_CONST
  //     s.send_out[0].msg.predicate @= s.recv_in[0].msg.predicate
  // 
  //   else:
  //     for j in range( num_outports ):
  //       s.send_out[j].val @= b1( 0 )
  
  always_comb begin : update_opt
    for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_update_opt ); j += 1'd1 ) begin
      send_out__val[1'(j)] = 1'd0;
      send_out__msg[1'(j)].predicate = 1'd0;
    end
    send_out__val[1'd0] = Fu__send_out__val[2'd0][1'd0] & recv_opt__val;
    recv_predicate__rdy = 1'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_lanes_at_update_opt ); i += 1'd1 ) begin
      Fu__recv_opt__msg[2'(i)].fu_in[2'd0] = 3'd1;
      Fu__recv_opt__msg[2'(i)].fu_in[2'd1] = 3'd2;
      Fu__recv_opt__msg[2'(i)].operation = 6'( __const__OPT_NAH );
    end
    if ( recv_opt__msg.predicate == 1'd1 ) begin
      recv_predicate__rdy = 1'd1;
    end
    if ( ( recv_opt__msg.operation == 6'( __const__OPT_VEC_ADD ) ) | ( recv_opt__msg.operation == 6'( __const__OPT_ADD ) ) ) begin
      for ( int unsigned i = 1'd0; i < 3'( __const__num_lanes_at_update_opt ); i += 1'd1 )
        Fu__recv_opt__msg[2'(i)].operation = 6'( __const__OPT_ADD );
      send_out__msg[1'd0].predicate = recv_in__msg[2'd0].predicate & recv_in__msg[2'd1].predicate;
    end
    else if ( ( recv_opt__msg.operation == 6'( __const__OPT_VEC_SUB ) ) | ( recv_opt__msg.operation == 6'( __const__OPT_SUB ) ) ) begin
      for ( int unsigned i = 1'd0; i < 3'( __const__num_lanes_at_update_opt ); i += 1'd1 )
        Fu__recv_opt__msg[2'(i)].operation = 6'( __const__OPT_SUB );
      send_out__msg[1'd0].predicate = recv_in__msg[2'd0].predicate & recv_in__msg[2'd1].predicate;
    end
    else if ( ( recv_opt__msg.operation == 6'( __const__OPT_VEC_ADD_CONST ) ) | ( recv_opt__msg.operation == 6'( __const__OPT_ADD_CONST ) ) ) begin
      for ( int unsigned i = 1'd0; i < 3'( __const__num_lanes_at_update_opt ); i += 1'd1 )
        Fu__recv_opt__msg[2'(i)].operation = 6'( __const__OPT_ADD_CONST );
      send_out__msg[1'd0].predicate = recv_in__msg[2'd0].predicate;
    end
    else if ( ( recv_opt__msg.operation == 6'( __const__OPT_VEC_SUB_CONST ) ) | ( recv_opt__msg.operation == 6'( __const__OPT_SUB_CONST ) ) ) begin
      for ( int unsigned i = 1'd0; i < 3'( __const__num_lanes_at_update_opt ); i += 1'd1 )
        Fu__recv_opt__msg[2'(i)].operation = 6'( __const__OPT_SUB_CONST );
      send_out__msg[1'd0].predicate = recv_in__msg[2'd0].predicate;
    end
    else
      for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_update_opt ); j += 1'd1 )
        send_out__val[1'(j)] = 1'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/vector/VectorAdderComboRTL.py:66
  // @update
  // def update_signal():
  //   s.recv_in[0].rdy @= s.Fu[0].recv_in[0].rdy
  //   s.recv_in[1].rdy @= s.Fu[0].recv_in[1].rdy
  // 
  //   for i in range(num_lanes):
  //     s.Fu[i].recv_opt.val @= s.recv_opt.val
  // 
  //     for j in range(num_outports):
  //       s.Fu[i].send_out[j].rdy @= s.send_out[j].rdy
  // 
  //     s.Fu[i].recv_in[0].val @= s.recv_in[0].val
  //     s.Fu[i].recv_in[1].val @= s.recv_in[1].val
  //     s.Fu[i].recv_const.val @= s.recv_const.val
  // 
  //     # Note that the predication for a combined FU should be identical/shareable,
  //     # which means the computation in different basic block cannot be combined.
  //     # s.Fu[i].recv_opt.msg.predicate = s.recv_opt.msg.predicate
  //   s.recv_const.rdy @= s.Fu[0].recv_const.rdy
  //   s.recv_opt.rdy @= s.Fu[0].recv_opt.rdy
  
  always_comb begin : update_signal
    recv_in__rdy[2'd0] = Fu__recv_in__rdy[2'd0][2'd0];
    recv_in__rdy[2'd1] = Fu__recv_in__rdy[2'd0][2'd1];
    for ( int unsigned i = 1'd0; i < 3'( __const__num_lanes_at_update_signal ); i += 1'd1 ) begin
      Fu__recv_opt__val[2'(i)] = recv_opt__val;
      for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_update_signal ); j += 1'd1 )
        Fu__send_out__rdy[2'(i)][1'(j)] = send_out__rdy[1'(j)];
      Fu__recv_in__val[2'(i)][2'd0] = recv_in__val[2'd0];
      Fu__recv_in__val[2'(i)][2'd1] = recv_in__val[2'd1];
      Fu__recv_const__val[2'(i)] = recv_const__val;
    end
    recv_const__rdy = Fu__recv_const__rdy[2'd0];
    recv_opt__rdy = Fu__recv_opt__rdy[2'd0];
  end

  assign Fu__clk[0] = clk;
  assign Fu__reset[0] = reset;
  assign Fu__clk[1] = clk;
  assign Fu__reset[1] = reset;
  assign Fu__clk[2] = clk;
  assign Fu__reset[2] = reset;
  assign Fu__clk[3] = clk;
  assign Fu__reset[3] = reset;
  assign Fu__carry_in[0] = 1'd0;
  assign Fu__carry_in[1] = Fu__carry_out[0];
  assign Fu__carry_in[2] = Fu__carry_out[1];
  assign Fu__carry_in[3] = Fu__carry_out[2];
  assign Fu__recv_in__msg[0][0][7:0] = recv_in__msg[0].payload[7:0];
  assign Fu__recv_in__msg[0][1][7:0] = recv_in__msg[1].payload[7:0];
  assign Fu__recv_const__msg[0][7:0] = recv_const__msg.payload[7:0];
  assign send_out__msg[0].payload[7:0] = Fu__send_out__msg[0][0][7:0];
  assign Fu__recv_in__msg[1][0][7:0] = recv_in__msg[0].payload[15:8];
  assign Fu__recv_in__msg[1][1][7:0] = recv_in__msg[1].payload[15:8];
  assign Fu__recv_const__msg[1][7:0] = recv_const__msg.payload[15:8];
  assign send_out__msg[0].payload[15:8] = Fu__send_out__msg[1][0][7:0];
  assign Fu__recv_in__msg[2][0][7:0] = recv_in__msg[0].payload[23:16];
  assign Fu__recv_in__msg[2][1][7:0] = recv_in__msg[1].payload[23:16];
  assign Fu__recv_const__msg[2][7:0] = recv_const__msg.payload[23:16];
  assign send_out__msg[0].payload[23:16] = Fu__send_out__msg[2][0][7:0];
  assign Fu__recv_in__msg[3][0][7:0] = recv_in__msg[0].payload[31:24];
  assign Fu__recv_in__msg[3][1][7:0] = recv_in__msg[1].payload[31:24];
  assign Fu__recv_const__msg[3][7:0] = recv_const__msg.payload[31:24];
  assign send_out__msg[0].payload[31:24] = Fu__send_out__msg[3][0][7:0];

endmodule


// PyMTL Component NahRTL Definition
// Full name: NahRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__PredicateType_CGRAData_1_1__payload_1__predicate_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__num_inports_4__num_outports_2__data_mem_size_288__vector_factor_power_0
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/NahRTL.py

module NahRTL__b48d5d572c75e2e4
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  input CGRAData_1_1__payload_1__predicate_1 recv_predicate__msg  ,
  output logic [0:0] recv_predicate__rdy  ,
  input logic [0:0] recv_predicate__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [5:0] __const__OPT_START  = 6'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [5:0] __const__OPT_NAH  = 6'd1;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/NahRTL.py:26
  // @update
  // def comb_logic():
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_opt.rdy @= 0
  //   # For pick input register
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  // 
  //   for i in range( num_outports ):
  //     # s.send_out[i].val @= s.recv_opt.val
  //     s.send_out[i].val @= 0
  //     s.send_out[i].msg @= DataType()
  // 
  //   s.recv_predicate.rdy @= b1(0)
  // 
  //   if s.recv_opt.msg.operation == OPT_NAH:
  //     s.recv_opt.rdy @= 1
  //   else:
  //     for j in range(num_outports):
  //       s.send_out[j].val @= b1(0)
  //     s.recv_opt.rdy @= 0
  
  always_comb begin : comb_logic
    recv_const__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_predicate__rdy = 1'd0;
    if ( recv_opt__msg.operation == 6'( __const__OPT_NAH ) ) begin
      recv_opt__rdy = 1'd1;
    end
    else begin
      for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
        send_out__val[1'(j)] = 1'd0;
      recv_opt__rdy = 1'd0;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:66
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= DataAddrType(0)
  //   s.to_mem_raddr.msg @= DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:85
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:76
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 6'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:93
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //          (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;

endmodule


// PyMTL Component LogicRTL Definition
// Full name: LogicRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__PredicateType_CGRAData_1_1__payload_1__predicate_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__num_inports_4__num_outports_2__data_mem_size_288__vector_factor_power_0
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/LogicRTL.py

module LogicRTL__b48d5d572c75e2e4
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  input CGRAData_1_1__payload_1__predicate_1 recv_predicate__msg  ,
  output logic [0:0] recv_predicate__rdy  ,
  input logic [0:0] recv_predicate__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [5:0] __const__OPT_START  = 6'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [5:0] __const__OPT_OR  = 6'd8;
  localparam logic [5:0] __const__OPT_AND  = 6'd10;
  localparam logic [5:0] __const__OPT_NOT  = 6'd11;
  localparam logic [5:0] __const__OPT_XOR  = 6'd9;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/LogicRTL.py:40
  // @update
  // def comb_logic():
  // 
  //   s.recv_all_val @= 0
  //   # For pick input register
  //   s.in0 @= 0
  //   s.in1 @= 0
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  //   for i in range( num_outports ):
  //     s.send_out[i].val @= b1(0)
  //     s.send_out[i].msg @= DataType()
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_predicate.rdy @= b1(0)
  //   s.recv_opt.rdy @= 0
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != FuInType(0):
  //       s.in0 @= s.recv_opt.msg.fu_in[0] - FuInType(1)
  //     if s.recv_opt.msg.fu_in[1] != FuInType(0):
  //       s.in1 @= s.recv_opt.msg.fu_in[1] - FuInType(1)
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.operation == OPT_OR:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload | s.recv_in[s.in1_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      (~s.recv_opt.msg.predicate | \
  //                                       s.recv_predicate.msg.predicate) & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_AND:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload & s.recv_in[s.in1_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      (~s.recv_opt.msg.predicate | \
  //                                       s.recv_predicate.msg.predicate) & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_NOT:
  //       s.send_out[0].msg.payload @= ~ s.recv_in[s.in0_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      (~s.recv_opt.msg.predicate | \
  //                                       s.recv_predicate.msg.predicate) & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_XOR:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload ^ s.recv_in[s.in1_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      (~s.recv_opt.msg.predicate | \
  //                                       s.recv_predicate.msg.predicate) & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  //     else:
  //       for j in range(num_outports):
  //         s.send_out[j].val @= b1(0)
  //       s.recv_opt.rdy @= 0
  //       s.recv_in[s.in0_idx].rdy @= 0
  //       s.recv_in[s.in1_idx].rdy @= 0
  // 
  //     if s.send_out[0].rdy & (s.recv_opt.msg.predicate == b1(1)):
  //       s.recv_predicate.rdy @= s.recv_all_val & s.send_out[0].rdy
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_predicate__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 6'( __const__OPT_OR ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload | recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = ( ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) ) & reached_vector_factor;
        recv_all_val = ( recv_in__val[in0_idx] & recv_in__val[in1_idx] ) & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_AND ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload & recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = ( ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) ) & reached_vector_factor;
        recv_all_val = ( recv_in__val[in0_idx] & recv_in__val[in1_idx] ) & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_NOT ) ) begin
        send_out__msg[1'd0].payload = ~recv_in__msg[in0_idx].payload;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) ) & reached_vector_factor;
        recv_all_val = recv_in__val[in0_idx] & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_XOR ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload ^ recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = ( ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) ) & reached_vector_factor;
        recv_all_val = ( recv_in__val[in0_idx] & recv_in__val[in1_idx] ) & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
      end
      if ( send_out__rdy[1'd0] & ( recv_opt__msg.predicate == 1'd1 ) ) begin
        recv_predicate__rdy = recv_all_val & send_out__rdy[1'd0];
      end
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:66
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= DataAddrType(0)
  //   s.to_mem_raddr.msg @= DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:85
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:76
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 6'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:93
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //          (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;
  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];

endmodule


// PyMTL Component ShifterRTL Definition
// Full name: ShifterRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__PredicateType_CGRAData_1_1__payload_1__predicate_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__num_inports_4__num_outports_2__data_mem_size_288__vector_factor_power_0
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/ShifterRTL.py

module ShifterRTL__b48d5d572c75e2e4
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  input CGRAData_1_1__payload_1__predicate_1 recv_predicate__msg  ,
  output logic [0:0] recv_predicate__rdy  ,
  input logic [0:0] recv_predicate__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [5:0] __const__OPT_START  = 6'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [5:0] __const__OPT_LLS  = 6'd5;
  localparam logic [5:0] __const__OPT_LRS  = 6'd6;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/ShifterRTL.py:41
  // @update
  // def comb_logic():
  // 
  //   s.recv_all_val @= 0
  //   # For pick input register
  //   s.in0 @= FuInType(0)
  //   s.in1 @= FuInType(0)
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  //   for i in range(num_outports):
  //     s.send_out[i].val @= 0
  //     s.send_out[i].msg @= DataType()
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_predicate.rdy @= b1(0)
  //   s.recv_opt.rdy @= 0
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != FuInType(0):
  //       s.in0 @= s.recv_opt.msg.fu_in[0] - FuInType(1)
  //     if s.recv_opt.msg.fu_in[1] != FuInType(0):
  //       s.in1 @= s.recv_opt.msg.fu_in[1] - FuInType(1)
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.operation == OPT_LLS:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload << s.recv_in[s.in1_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      (~s.recv_opt.msg.predicate | \
  //                                       s.recv_predicate.msg.predicate) & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_LRS:
  //       s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload >> s.recv_in[s.in1_idx].msg.payload
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      (~s.recv_opt.msg.predicate | \
  //                                       s.recv_predicate.msg.predicate) & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     else:
  //       for j in range(num_outports):
  //         s.send_out[j].val @= b1(0)
  //       s.recv_opt.rdy @= 0
  //       s.recv_in[s.in0_idx].rdy @= 0
  //       s.recv_in[s.in1_idx].rdy @= 0
  // 
  //     if s.send_out[0].rdy & s.recv_opt.msg.predicate == b1(1):
  //       s.recv_predicate.rdy @= s.recv_all_val & s.send_out[0].rdy
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_predicate__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 6'( __const__OPT_LLS ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload << recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = ( ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) ) & reached_vector_factor;
        recv_all_val = ( recv_in__val[in0_idx] & recv_in__val[in1_idx] ) & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_LRS ) ) begin
        send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload >> recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = ( ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) ) & reached_vector_factor;
        recv_all_val = ( recv_in__val[in0_idx] & recv_in__val[in1_idx] ) & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
      end
      if ( ( send_out__rdy[1'd0] & recv_opt__msg.predicate ) == 1'd1 ) begin
        recv_predicate__rdy = recv_all_val & send_out__rdy[1'd0];
      end
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:66
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= DataAddrType(0)
  //   s.to_mem_raddr.msg @= DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:85
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:76
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 6'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:93
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //          (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;
  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];

endmodule


// PyMTL Component PhiRTL Definition
// Full name: PhiRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__PredicateType_CGRAData_1_1__payload_1__predicate_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__num_inports_4__num_outports_2__data_mem_size_288__vector_factor_power_0
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/PhiRTL.py

module PhiRTL__b48d5d572c75e2e4
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  input CGRAData_1_1__payload_1__predicate_1 recv_predicate__msg  ,
  output logic [0:0] recv_predicate__rdy  ,
  input logic [0:0] recv_predicate__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [5:0] __const__OPT_START  = 6'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [5:0] __const__OPT_PHI  = 6'd17;
  localparam logic [5:0] __const__OPT_PHI_CONST  = 6'd32;
  logic [0:0] first;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/PhiRTL.py:42
  //    @update
  //    def comb_logic():
  //      s.recv_all_val @= 0
  //      # For pick input register
  //      s.in0 @= 0
  //      s.in1 @= 0
  //      for i in range(num_inports):
  //        s.recv_in[i].rdy @= b1(0)
  //      for i in range(num_outports):
  //        s.send_out[i].val @= 0
  //        s.send_out[i].msg @= DataType()
  // 
  //      s.recv_const.rdy @= 0
  //      s.recv_predicate.rdy @= b1(0)
  //      s.recv_opt.rdy @= 0
  // 
  //      if s.recv_opt.val:
  //        if s.recv_opt.msg.fu_in[0] != FuInType(0):
  //          s.in0 @= s.recv_opt.msg.fu_in[0] - FuInType(1)
  //        if s.recv_opt.msg.fu_in[1] != FuInType(0):
  //          s.in1 @= s.recv_opt.msg.fu_in[1] - FuInType(1)
  // 
  //      # TODO: decision needs to be made. Adder could be in FU vector width. Or only effective once on the boundary.
  //      # if s.recv_opt.val:
  //      if s.recv_opt.val:
  //        if s.recv_opt.msg.operation == OPT_PHI:
  //          if s.recv_in[s.in0_idx].msg.predicate == Bits1(1):
  //            s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload
  //            s.send_out[0].msg.predicate @= (~s.recv_opt.msg.predicate | \
  //                                            s.recv_predicate.msg.predicate) & \
  //                                           s.reached_vector_factor
  //          elif s.recv_in[s.in1_idx].msg.predicate == Bits1(1):
  //            s.send_out[0].msg.payload @= s.recv_in[s.in1_idx].msg.payload
  //            s.send_out[0].msg.predicate @= (~s.recv_opt.msg.predicate | \
  //                                            s.recv_predicate.msg.predicate) & \
  //                                           s.reached_vector_factor
  //          else: # No predecessor is active.
  //            s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload
  //            s.send_out[0].msg.predicate @= 0
  //          s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val & \
  //                            ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //          s.send_out[0].val @= s.recv_all_val
  //          s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //          s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //          s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //          s.recv_predicate.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //          # if (s.recv_opt.msg.predicate == b1(1)) & \
  //          #    (s.recv_predicate.msg.payload == b1(0)):
  //          #   s.recv_predicate.rdy @= b1(0)
  //          #   s.recv_in[s.in0_idx].rdy @= b1(0)
  //          #   s.recv_in[s.in1_idx].rdy @= b1(0)
  //          #   s.recv_opt.rdy @= 0
  //          #   s.send_out[0].val @= 0
  // 
  //        elif s.recv_opt.msg.operation == OPT_PHI_CONST:
  //          if s.recv_in[s.in0_idx].msg.predicate == Bits1(1):
  //            s.send_out[0].msg.payload @= s.recv_in[s.in0_idx].msg.payload
  //          else:
  //            s.send_out[0].msg.payload @= s.recv_const.msg.payload
  // 
  //          s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_const.val & \
  //                            ((s.recv_opt.msg.predicate == b1(0)) | \
  //                             (s.recv_predicate.val & ~s.first) | s.first)
  //          s.send_out[0].val @= s.recv_all_val
  //          s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //          s.recv_const.rdy @= s.recv_all_val & s.send_out[0].rdy
  //          s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //          # Predication signal not arrive yet.
  //          #if ~s.first & \
  //          #   (s.recv_opt.msg.predicate == b1(1)) & \
  //          #   (s.recv_predicate.msg.payload == b1(0)):
  //          #  s.recv_in[s.in0_idx].rdy @= b1(0)
  //          #  s.recv_opt.rdy @= 0
  //          #  s.recv_const.rdy @= 0
  //          #  s.send_out[0].val @= 0
  //          # No need to consume predication signal if opcode doesn't indicate that.
  //          if s.first:
  //            s.send_out[0].msg.predicate @= s.reached_vector_factor
  //            s.recv_predicate.rdy @= 0
  //          elif ~s.first & (s.recv_opt.msg.predicate == 0):
  //            s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                           s.reached_vector_factor
  //            s.recv_predicate.rdy @= 0
  //          elif s.recv_opt.msg.predicate == 1:
  //            s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                           (s.recv_predicate.msg.payload == 1) & \
  //                                           s.reached_vector_factor
  //            s.recv_predicate.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //        else:
  //          for j in range(num_outports):
  //            s.send_out[j].val @= b1(0)
  //          s.recv_opt.rdy @= 0
  //          s.recv_in[s.in0_idx].rdy @= 0
  //          s.recv_in[s.in1_idx].rdy @= 0
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_predicate__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 6'( __const__OPT_PHI ) ) begin
        if ( recv_in__msg[in0_idx].predicate == 1'd1 ) begin
          send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload;
          send_out__msg[1'd0].predicate = ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) & reached_vector_factor;
        end
        else if ( recv_in__msg[in1_idx].predicate == 1'd1 ) begin
          send_out__msg[1'd0].payload = recv_in__msg[in1_idx].payload;
          send_out__msg[1'd0].predicate = ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) & reached_vector_factor;
        end
        else begin
          send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload;
          send_out__msg[1'd0].predicate = 1'd0;
        end
        recv_all_val = ( recv_in__val[in0_idx] & recv_in__val[in1_idx] ) & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
        recv_predicate__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_PHI_CONST ) ) begin
        if ( recv_in__msg[in0_idx].predicate == 1'd1 ) begin
          send_out__msg[1'd0].payload = recv_in__msg[in0_idx].payload;
        end
        else
          send_out__msg[1'd0].payload = recv_const__msg.payload;
        recv_all_val = ( recv_in__val[in0_idx] & recv_const__val ) & ( ( ( recv_opt__msg.predicate == 1'd0 ) | ( recv_predicate__val & ( ~first ) ) ) | first );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_const__rdy = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
        if ( first ) begin
          send_out__msg[1'd0].predicate = reached_vector_factor;
          recv_predicate__rdy = 1'd0;
        end
        else if ( ( ~first ) & ( recv_opt__msg.predicate == 1'd0 ) ) begin
          send_out__msg[1'd0].predicate = recv_in__msg[in0_idx].predicate & reached_vector_factor;
          recv_predicate__rdy = 1'd0;
        end
        else if ( recv_opt__msg.predicate == 1'd1 ) begin
          send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & ( recv_predicate__msg.payload == 1'd1 ) ) & reached_vector_factor;
          recv_predicate__rdy = recv_all_val & send_out__rdy[1'd0];
        end
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
      end
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:66
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= DataAddrType(0)
  //   s.to_mem_raddr.msg @= DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:85
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/PhiRTL.py:143
  // @update_ff
  // def br_start_once():
  //   if s.reset:
  //     s.first <<= b1(1)
  //   if (s.recv_opt.msg.operation == OPT_PHI_CONST) & s.reached_vector_factor:
  //     s.first <<= b1(0)
  
  always_ff @(posedge clk) begin : br_start_once
    if ( reset ) begin
      first <= 1'd1;
    end
    if ( ( recv_opt__msg.operation == 6'( __const__OPT_PHI_CONST ) ) & reached_vector_factor ) begin
      first <= 1'd0;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:76
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 6'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:93
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //          (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;
  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];

endmodule


// PyMTL Component CompRTL Definition
// Full name: CompRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__PredicateType_CGRAData_1_1__payload_1__predicate_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__num_inports_4__num_outports_2__data_mem_size_288__vector_factor_power_0
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/CompRTL.py

module CompRTL__b48d5d572c75e2e4
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  input CGRAData_1_1__payload_1__predicate_1 recv_predicate__msg  ,
  output logic [0:0] recv_predicate__rdy  ,
  input logic [0:0] recv_predicate__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_one  = { 32'd1, 1'd0, 1'd0, 1'd0 };
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [5:0] __const__OPT_START  = 6'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [2:0] __const__num_inports_at_read_reg  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_read_reg  = 2'd2;
  localparam logic [5:0] __const__OPT_EQ  = 6'd14;
  localparam logic [5:0] __const__OPT_EQ_CONST  = 6'd33;
  localparam logic [5:0] __const__OPT_LT  = 6'd60;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/CompRTL.py:44
  // @update
  // def read_reg():
  // 
  //   s.recv_all_val @= 0
  //   # For pick input register
  //   s.in0 @= FuInType(0)
  //   s.in1 @= FuInType(0)
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  //   for i in range(num_outports):
  //     s.send_out[i].val @= 0
  //     s.send_out[i].msg @= DataType()
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_predicate.rdy @= b1(0)
  //   s.recv_opt.rdy @= 0
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != FuInType( 0 ):
  //       s.in0 @= s.recv_opt.msg.fu_in[0] - FuInType(1)
  //     if s.recv_opt.msg.fu_in[1] != FuInType(0):
  //       s.in1 @= s.recv_opt.msg.fu_in[1] - FuInType(1)
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.operation == OPT_EQ:
  //       if s.recv_in[s.in0_idx].msg.payload == s.recv_in[s.in1_idx].msg.payload:
  //         s.send_out[0].msg @= s.const_one
  //       else:
  //         s.send_out[0].msg @= s.const_zero
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      (~s.recv_opt.msg.predicate | \
  //                                       s.recv_predicate.msg.predicate) & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_EQ_CONST:
  //       if s.recv_in[s.in0_idx].msg.payload == s.recv_const.msg.payload:
  //         s.send_out[0].msg @= s.const_one
  //       else:
  //         s.send_out[0].msg @= s.const_zero
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      (~s.recv_opt.msg.predicate | \
  //                                       s.recv_predicate.msg.predicate) & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_const.val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_const.rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_LT:
  //       if s.recv_in[s.in0_idx].msg.payload < s.recv_in[s.in1_idx].msg.payload:
  //         s.send_out[0].msg @= s.const_one
  //       else:
  //         s.send_out[0].msg @= s.const_zero
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      (~s.recv_opt.msg.predicate | \
  //                                       s.recv_predicate.msg.predicate) & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //     else:
  //       for j in range(num_outports):
  //         s.send_out[j].val @= b1(0)
  //       s.recv_opt.rdy @= 0
  //       s.recv_in[s.in0_idx].rdy @= 0
  //       s.recv_in[s.in1_idx].rdy @= 0
  // 
  //     if s.recv_opt.msg.predicate == b1(1):
  //       s.recv_predicate.rdy @= s.recv_all_val & s.send_out[0].rdy
  
  always_comb begin : read_reg
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_read_reg ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_read_reg ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_predicate__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 6'( __const__OPT_EQ ) ) begin
        if ( recv_in__msg[in0_idx].payload == recv_in__msg[in1_idx].payload ) begin
          send_out__msg[1'd0] = const_one;
        end
        else
          send_out__msg[1'd0] = const_zero;
        send_out__msg[1'd0].predicate = ( ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) ) & reached_vector_factor;
        recv_all_val = ( recv_in__val[in0_idx] & recv_in__val[in1_idx] ) & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_EQ_CONST ) ) begin
        if ( recv_in__msg[in0_idx].payload == recv_const__msg.payload ) begin
          send_out__msg[1'd0] = const_one;
        end
        else
          send_out__msg[1'd0] = const_zero;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) ) & reached_vector_factor;
        recv_all_val = ( recv_in__val[in0_idx] & recv_const__val ) & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_const__rdy = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_LT ) ) begin
        if ( recv_in__msg[in0_idx].payload < recv_in__msg[in1_idx].payload ) begin
          send_out__msg[1'd0] = const_one;
        end
        else
          send_out__msg[1'd0] = const_zero;
        send_out__msg[1'd0].predicate = ( ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) ) & reached_vector_factor;
        recv_all_val = ( recv_in__val[in0_idx] & recv_in__val[in1_idx] ) & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_read_reg ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
      end
      if ( recv_opt__msg.predicate == 1'd1 ) begin
        recv_predicate__rdy = recv_all_val & send_out__rdy[1'd0];
      end
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:66
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= DataAddrType(0)
  //   s.to_mem_raddr.msg @= DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:85
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:76
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 6'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:93
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //          (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;
  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];

endmodule


// PyMTL Component BranchRTL Definition
// Full name: BranchRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__PredicateType_CGRAData_1_1__payload_1__predicate_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__num_inports_4__num_outports_2__data_mem_size_288__vector_factor_power_0
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/BranchRTL.py

module BranchRTL__b48d5d572c75e2e4
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  input CGRAData_1_1__payload_1__predicate_1 recv_predicate__msg  ,
  output logic [0:0] recv_predicate__rdy  ,
  input logic [0:0] recv_predicate__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [5:0] __const__OPT_START  = 6'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [5:0] __const__OPT_BRH  = 6'd16;
  localparam logic [5:0] __const__OPT_BRH_START  = 6'd34;
  logic [0:0] first;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/BranchRTL.py:42
  // @update
  // def comb_logic():
  // 
  //   s.recv_all_val @= 0
  //   # For pick input register
  //   s.in0 @= 0
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  //   for i in range(num_outports):
  //     s.send_out[i].val @= 0
  //     s.send_out[i].msg @= DataType()
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_predicate.rdy @= b1(0)
  //   s.recv_opt.rdy @= 0
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != FuInType(0):
  //       s.in0 @= s.recv_opt.msg.fu_in[0] - FuInType(1)
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.operation == OPT_BRH:
  //       # Branch is only used to set predication rather than delivering value.
  //       s.send_out[0].msg @= DataType(ZeroType(0), b1(0), b1(0), b1(0))
  //       s.send_out[1].msg @= DataType(ZeroType(0), b1(0), b1(0), b1(0))
  //       if s.recv_in[s.in0_idx].msg.payload == s.const_zero.payload:
  //         s.send_out[0].msg.predicate @= (~s.recv_opt.msg.predicate | \
  //                                         s.recv_predicate.msg.predicate) & \
  //                                        s.reached_vector_factor
  //         s.send_out[1].msg.predicate @= Bits1(0)
  //       else:
  //         s.send_out[0].msg.predicate @= Bits1(0)
  //         s.send_out[1].msg.predicate @= (~s.recv_opt.msg.predicate | \
  //                                         s.recv_predicate.msg.predicate) & \
  //                                        s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.send_out[0].val @= s.recv_all_val
  //       s.send_out[1].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy & s.send_out[1].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy & s.send_out[1].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_BRH_START:
  //       s.send_out[0].msg @= DataType(ZeroType(0), b1(0), b1(0), b1(0))
  //       s.send_out[1].msg @= DataType(ZeroType(0), b1(0), b1(0), b1(0))
  //       # branch_start could be the entry of a function, which runs
  //       # only once.
  //       if s.first:
  //         s.send_out[0].msg.predicate @= s.reached_vector_factor
  //         s.send_out[1].msg.predicate @= Bits1(0)
  //       else:
  //         s.send_out[0].msg.predicate @= Bits1(0)
  //         s.send_out[1].msg.predicate @= s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.send_out[0].val @= s.recv_all_val
  //       s.send_out[1].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy & s.send_out[1].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy & s.send_out[1].rdy
  // 
  //     else:
  //       for j in range( num_outports ):
  //         s.send_out[j].val @= b1( 0 )
  //       s.recv_opt.rdy @= 0
  //       s.recv_in[s.in0_idx].rdy @= 0
  // 
  //     if (s.recv_opt.msg.predicate == 1) & \
  //        (s.recv_opt.msg.operation != OPT_BRH_START):
  //       s.recv_predicate.rdy @= s.recv_all_val & s.send_out[0].rdy & s.send_out[1].rdy
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_predicate__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 6'( __const__OPT_BRH ) ) begin
        send_out__msg[1'd0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
        send_out__msg[1'd1] = { 32'd0, 1'd0, 1'd0, 1'd0 };
        if ( recv_in__msg[in0_idx].payload == 32'd0 ) begin
          send_out__msg[1'd0].predicate = ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) & reached_vector_factor;
          send_out__msg[1'd1].predicate = 1'd0;
        end
        else begin
          send_out__msg[1'd0].predicate = 1'd0;
          send_out__msg[1'd1].predicate = ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) & reached_vector_factor;
        end
        recv_all_val = recv_in__val[in0_idx] & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        send_out__val[1'd1] = recv_all_val;
        recv_in__rdy[in0_idx] = ( recv_all_val & send_out__rdy[1'd0] ) & send_out__rdy[1'd1];
        recv_opt__rdy = ( recv_all_val & send_out__rdy[1'd0] ) & send_out__rdy[1'd1];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_BRH_START ) ) begin
        send_out__msg[1'd0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
        send_out__msg[1'd1] = { 32'd0, 1'd0, 1'd0, 1'd0 };
        if ( first ) begin
          send_out__msg[1'd0].predicate = reached_vector_factor;
          send_out__msg[1'd1].predicate = 1'd0;
        end
        else begin
          send_out__msg[1'd0].predicate = 1'd0;
          send_out__msg[1'd1].predicate = reached_vector_factor;
        end
        recv_all_val = recv_in__val[in0_idx] & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        send_out__val[1'd1] = recv_all_val;
        recv_in__rdy[in0_idx] = ( recv_all_val & send_out__rdy[1'd0] ) & send_out__rdy[1'd1];
        recv_opt__rdy = ( recv_all_val & send_out__rdy[1'd0] ) & send_out__rdy[1'd1];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
      end
      if ( ( recv_opt__msg.predicate == 1'd1 ) & ( recv_opt__msg.operation != 6'( __const__OPT_BRH_START ) ) ) begin
        recv_predicate__rdy = ( recv_all_val & send_out__rdy[1'd0] ) & send_out__rdy[1'd1];
      end
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:66
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= DataAddrType(0)
  //   s.to_mem_raddr.msg @= DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:85
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/BranchRTL.py:114
  // @update_ff
  // def br_start_once():
  //   if s.reset:
  //     s.first <<= b1(1)
  //   if (s.recv_opt.msg.operation == OPT_BRH_START) & s.reached_vector_factor:
  //     s.first <<= b1(0)
  
  always_ff @(posedge clk) begin : br_start_once
    if ( reset ) begin
      first <= 1'd1;
    end
    if ( ( recv_opt__msg.operation == 6'( __const__OPT_BRH_START ) ) & reached_vector_factor ) begin
      first <= 1'd0;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:76
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 6'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:93
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //          (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;
  assign in0_idx = in0[1:0];

endmodule


// PyMTL Component MemUnitRTL Definition
// Full name: MemUnitRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__PredicateType_CGRAData_1_1__payload_1__predicate_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__num_inports_4__num_outports_2__data_mem_size_288__vector_factor_power_0
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/MemUnitRTL.py

module MemUnitRTL__b48d5d572c75e2e4
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  input CGRAData_1_1__payload_1__predicate_1 recv_predicate__msg  ,
  output logic [0:0] recv_predicate__rdy  ,
  input logic [0:0] recv_predicate__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [5:0] __const__OPT_LD  = 6'd12;
  localparam logic [5:0] __const__OPT_LD_CONST  = 6'd28;
  localparam logic [5:0] __const__OPT_STR  = 6'd13;
  localparam logic [5:0] __const__OPT_STR_CONST  = 6'd58;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [3:0] recv_in_val_vector;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/MemUnitRTL.py:63
  // @update
  // def comb_logic():
  // 
  //   s.recv_all_val @= 0
  //   # For pick input register
  //   s.in0 @= FuInType(0)
  //   s.in1 @= FuInType(0)
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  //   for i in range(num_outports):
  //     s.send_out[i].val @= 0
  //     s.send_out[i].msg @= DataType()
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_predicate.rdy @= b1(0)
  //   s.recv_opt.rdy @= 0
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != 0:
  //       s.in0 @= zext(s.recv_opt.msg.fu_in[0] - 1, FuInType)
  //     if s.recv_opt.msg.fu_in[1] != 0:
  //       s.in1 @= zext(s.recv_opt.msg.fu_in[1] - 1, FuInType)
  // 
  //   s.to_mem_waddr.val @= 0
  //   s.to_mem_waddr.msg @= AddrType()
  //   s.to_mem_wdata.val @= 0
  //   s.to_mem_wdata.msg @= DataType()
  //   s.to_mem_raddr.val @= 0
  //   s.to_mem_raddr.msg @= AddrType()
  //   s.from_mem_rdata.rdy @= 0
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.operation == OPT_LD:
  //       # s.recv_in[s.in0_idx].rdy @= s.to_mem_raddr.rdy
  //       # s.recv_in[s.in1_idx].rdy @= s.from_mem_rdata.rdy
  //       # s.to_mem_raddr.val @= s.recv_in[s.in0_idx].val
  //       # s.from_mem_rdata.rdy @= s.send_out[0].rdy
  //       # s.send_out[0].val @= s.recv_opt.val & \
  //       #                      s.recv_in[s.in0_idx].val & \
  //       #                      s.recv_in[s.in1_idx].val & \
  //       #                      s.from_mem_rdata.val & \
  //       #                      s.to_mem_raddr.val
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val) # FIXME: Use ~ after checking translation
  //       # FIXME: to_mem_raddr shouldn't be ready if the existing request not yet returned.
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.to_mem_raddr.rdy
  //       s.to_mem_raddr.msg @= AddrType(s.recv_in[s.in0_idx].msg.payload[0:AddrType.nbits])
  //       s.to_mem_raddr.val @= s.recv_all_val
  //       s.from_mem_rdata.rdy @= s.send_out[0].rdy
  //       # FIXME: As the memory access might take more than one cycle,
  //       # the send_out valid no need to depend on recv_all_val.
  //       s.send_out[0].val @= s.from_mem_rdata.val
  //       s.send_out[0].msg @= s.from_mem_rdata.msg
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.from_mem_rdata.msg.predicate & \
  //                                      (~s.recv_opt.msg.predicate | \
  //                                       s.recv_predicate.msg.predicate) & \
  //                                      s.reached_vector_factor
  //       s.recv_opt.rdy @= s.send_out[0].rdy & s.from_mem_rdata.val
  //       if s.recv_opt.msg.predicate == 1:
  //         s.recv_predicate.rdy @= s.from_mem_rdata.val & s.send_out[0].rdy
  // 
  //     # LD_CONST indicates the address is a const.
  //     elif s.recv_opt.msg.operation == OPT_LD_CONST:
  //       s.recv_all_val @= s.recv_const.val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.recv_const.rdy @= s.recv_all_val & s.to_mem_raddr.rdy
  //       s.to_mem_raddr.msg @= AddrType(s.recv_const.msg.payload[0:AddrType.nbits])
  //       s.to_mem_raddr.val @= s.recv_all_val
  //       s.from_mem_rdata.rdy @= s.send_out[0].rdy
  //       s.send_out[0].val @= s.from_mem_rdata.val
  //       s.send_out[0].msg @= s.from_mem_rdata.msg
  //       s.send_out[0].msg.predicate @= s.recv_const.msg.predicate & \
  //                                      s.from_mem_rdata.msg.predicate & \
  //                                      (~s.recv_opt.msg.predicate | \
  //                                       s.recv_predicate.msg.predicate) & \
  //                                      s.reached_vector_factor
  //       s.recv_opt.rdy @= s.send_out[0].rdy & s.from_mem_rdata.val
  //       if s.recv_opt.msg.predicate == 1:
  //         s.recv_predicate.rdy @= s.from_mem_rdata.val & s.send_out[0].rdy
  // 
  //     elif s.recv_opt.msg.operation == OPT_STR:
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & \
  //                         s.recv_in[s.in1_idx].val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.to_mem_waddr.rdy & s.to_mem_wdata.rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.to_mem_waddr.rdy & s.to_mem_wdata.rdy
  //       s.to_mem_waddr.msg @= AddrType(s.recv_in[0].msg.payload[0:AddrType.nbits])
  //       s.to_mem_waddr.val @= s.recv_all_val
  //       s.to_mem_wdata.msg @= s.recv_in[s.in1_idx].msg
  //       s.to_mem_wdata.msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                       s.recv_in[s.in1_idx].msg.predicate & \
  //                                       (~s.recv_opt.msg.predicate | \
  //                                        s.recv_predicate.msg.predicate) & \
  //                                       s.reached_vector_factor
  //       s.to_mem_wdata.val @= s.recv_all_val
  // 
  //       # `send_out` is meaningless for store operation.
  //       s.send_out[0].val @= b1(0)
  // 
  //       s.recv_opt.rdy @= s.recv_all_val & s.to_mem_waddr.rdy & s.to_mem_wdata.rdy
  // 
  //       if s.recv_opt.msg.predicate == 1:
  //         s.recv_predicate.rdy @= s.recv_all_val
  // 
  //     # STR_CONST indicates the address is a const.
  //     elif s.recv_opt.msg.operation == OPT_STR_CONST:
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & \
  //                         s.recv_const.val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.recv_const.rdy @= s.recv_all_val & s.to_mem_waddr.rdy & s.to_mem_wdata.rdy
  //       # Only needs one input register to indicate the storing data.
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.to_mem_waddr.rdy & s.to_mem_wdata.rdy
  //       s.to_mem_waddr.msg @= AddrType(s.recv_const.msg.payload[0:AddrType.nbits])
  //       s.to_mem_waddr.val @= s.recv_all_val
  //       s.to_mem_wdata.msg @= s.recv_in[s.in0_idx].msg
  //       s.to_mem_wdata.msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                       s.recv_const.msg.predicate & \
  //                                       (~s.recv_opt.msg.predicate | \
  //                                        s.recv_predicate.msg.predicate) & \
  //                                       s.reached_vector_factor
  //       s.to_mem_wdata.val @= s.recv_all_val
  // 
  //       # `send_out` is meaningless for store operation.
  //       s.send_out[0].val @= b1(0)
  // 
  //       s.recv_opt.rdy @= s.recv_all_val & s.to_mem_waddr.rdy & s.to_mem_wdata.rdy
  // 
  //       if s.recv_opt.msg.predicate == 1:
  //         s.recv_predicate.rdy @= s.recv_all_val
  // 
  //     else:
  //       for j in range(num_outports):
  //         s.send_out[j].val @= b1(0)
  //       s.recv_opt.rdy @= 0
  //       s.recv_in[s.in0_idx].rdy @= 0
  //       s.recv_in[s.in1_idx].rdy @= 0
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_predicate__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    to_mem_waddr__val = 1'd0;
    to_mem_waddr__msg = 9'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = { 32'd0, 1'd0, 1'd0, 1'd0 };
    to_mem_raddr__val = 1'd0;
    to_mem_raddr__msg = 9'd0;
    from_mem_rdata__rdy = 1'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 6'( __const__OPT_LD ) ) begin
        recv_all_val = recv_in__val[in0_idx] & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        recv_in__rdy[in0_idx] = recv_all_val & to_mem_raddr__rdy;
        to_mem_raddr__msg = 9'( recv_in__msg[in0_idx].payload[5'd8:5'd0] );
        to_mem_raddr__val = recv_all_val;
        from_mem_rdata__rdy = send_out__rdy[1'd0];
        send_out__val[1'd0] = from_mem_rdata__val;
        send_out__msg[1'd0] = from_mem_rdata__msg;
        send_out__msg[1'd0].predicate = ( ( recv_in__msg[in0_idx].predicate & from_mem_rdata__msg.predicate ) & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) ) & reached_vector_factor;
        recv_opt__rdy = send_out__rdy[1'd0] & from_mem_rdata__val;
        if ( recv_opt__msg.predicate == 1'd1 ) begin
          recv_predicate__rdy = from_mem_rdata__val & send_out__rdy[1'd0];
        end
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_LD_CONST ) ) begin
        recv_all_val = recv_const__val & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        recv_const__rdy = recv_all_val & to_mem_raddr__rdy;
        to_mem_raddr__msg = 9'( recv_const__msg.payload[5'd8:5'd0] );
        to_mem_raddr__val = recv_all_val;
        from_mem_rdata__rdy = send_out__rdy[1'd0];
        send_out__val[1'd0] = from_mem_rdata__val;
        send_out__msg[1'd0] = from_mem_rdata__msg;
        send_out__msg[1'd0].predicate = ( ( recv_const__msg.predicate & from_mem_rdata__msg.predicate ) & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) ) & reached_vector_factor;
        recv_opt__rdy = send_out__rdy[1'd0] & from_mem_rdata__val;
        if ( recv_opt__msg.predicate == 1'd1 ) begin
          recv_predicate__rdy = from_mem_rdata__val & send_out__rdy[1'd0];
        end
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_STR ) ) begin
        recv_all_val = ( recv_in__val[in0_idx] & recv_in__val[in1_idx] ) & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        recv_in__rdy[in0_idx] = ( recv_all_val & to_mem_waddr__rdy ) & to_mem_wdata__rdy;
        recv_in__rdy[in1_idx] = ( recv_all_val & to_mem_waddr__rdy ) & to_mem_wdata__rdy;
        to_mem_waddr__msg = 9'( recv_in__msg[2'd0].payload[5'd8:5'd0] );
        to_mem_waddr__val = recv_all_val;
        to_mem_wdata__msg = recv_in__msg[in1_idx];
        to_mem_wdata__msg.predicate = ( ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) ) & reached_vector_factor;
        to_mem_wdata__val = recv_all_val;
        send_out__val[1'd0] = 1'd0;
        recv_opt__rdy = ( recv_all_val & to_mem_waddr__rdy ) & to_mem_wdata__rdy;
        if ( recv_opt__msg.predicate == 1'd1 ) begin
          recv_predicate__rdy = recv_all_val;
        end
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_STR_CONST ) ) begin
        recv_all_val = ( recv_in__val[in0_idx] & recv_const__val ) & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        recv_const__rdy = ( recv_all_val & to_mem_waddr__rdy ) & to_mem_wdata__rdy;
        recv_in__rdy[in0_idx] = ( recv_all_val & to_mem_waddr__rdy ) & to_mem_wdata__rdy;
        to_mem_waddr__msg = 9'( recv_const__msg.payload[5'd8:5'd0] );
        to_mem_waddr__val = recv_all_val;
        to_mem_wdata__msg = recv_in__msg[in0_idx];
        to_mem_wdata__msg.predicate = ( ( recv_in__msg[in0_idx].predicate & recv_const__msg.predicate ) & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) ) & reached_vector_factor;
        to_mem_wdata__val = recv_all_val;
        send_out__val[1'd0] = 1'd0;
        recv_opt__rdy = ( recv_all_val & to_mem_waddr__rdy ) & to_mem_wdata__rdy;
        if ( recv_opt__msg.predicate == 1'd1 ) begin
          recv_predicate__rdy = recv_all_val;
        end
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
      end
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/MemUnitRTL.py:201
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/MemUnitRTL.py:209
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //          (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];
  assign vector_factor_power = 3'd0;

endmodule


// PyMTL Component SelRTL Definition
// Full name: SelRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__PredicateType_CGRAData_1_1__payload_1__predicate_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__num_inports_4__num_outports_2__data_mem_size_288__vector_factor_power_0
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/SelRTL.py

module SelRTL__b48d5d572c75e2e4
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  input CGRAData_1_1__payload_1__predicate_1 recv_predicate__msg  ,
  output logic [0:0] recv_predicate__rdy  ,
  input logic [0:0] recv_predicate__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [5:0] __const__OPT_SEL  = 6'd27;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [2:0] in2;
  logic [1:0] in2_idx;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/SelRTL.py:77
  // @update
  // def comb_logic():
  // 
  //   s.recv_all_val @= 0
  //   # For pick input register, Selector needs at least 3 inputs
  //   s.in0 @= FuInType(0)
  //   s.in1 @= FuInType(0)
  //   s.in2 @= FuInType(0)
  //   for i in range(num_inports):
  //     s.recv_in[i].rdy @= b1(0)
  // 
  //   s.recv_const.rdy @= 0
  //   s.recv_predicate.rdy @= b1(0)
  //   s.recv_opt.rdy @= s.send_out[0].rdy
  // 
  //   for i in range(num_outports):
  //     s.send_out[i].val @= 0
  //     s.send_out[i].msg @= DataType()
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.fu_in[0] != FuInType(0):
  //       s.in0 @= s.recv_opt.msg.fu_in[0] - FuInType(1)
  //     if s.recv_opt.msg.fu_in[1] != FuInType(0):
  //       s.in1 @= s.recv_opt.msg.fu_in[1] - FuInType(1)
  //     if s.recv_opt.msg.fu_in[2] != FuInType(0):
  //       s.in2 @= s.recv_opt.msg.fu_in[2] - FuInType(1)
  // 
  //   if s.recv_opt.val:
  //     if s.recv_opt.msg.operation == OPT_SEL:
  //       if s.recv_in[s.in0_idx].msg.payload == s.true.payload:
  //         s.send_out[0].msg @= s.recv_in[s.in1_idx].msg
  //       else:
  //         s.send_out[0].msg @= s.recv_in[s.in2_idx].msg
  //       s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                      s.recv_in[s.in1_idx].msg.predicate & \
  //                                      s.recv_in[s.in2_idx].msg.predicate & \
  //                                      (~s.recv_opt.msg.predicate | \
  //                                       s.recv_predicate.msg.predicate) & \
  //                                      s.reached_vector_factor
  //       s.recv_all_val @= s.recv_in[s.in0_idx].val & \
  //                         s.recv_in[s.in1_idx].val & \
  //                         s.recv_in[s.in2_idx].val & \
  //                         ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //       s.send_out[0].val @= s.recv_all_val
  //       s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_in[s.in2_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //       s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  //     else:
  //       for j in range(num_outports):
  //         s.send_out[j].val @= b1(0)
  //       s.recv_opt.rdy @= 0
  //       s.recv_in[s.in0_idx].rdy @= 0
  //       s.recv_in[s.in1_idx].rdy @= 0
  //       s.recv_in[s.in2_idx].rdy @= 0
  // 
  //     if s.send_out[0].rdy & (s.recv_opt.msg.predicate == b1(1)):
  //       s.recv_predicate.rdy @= s.recv_all_val & s.send_out[0].rdy
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    in2 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    recv_const__rdy = 1'd0;
    recv_predicate__rdy = 1'd0;
    recv_opt__rdy = send_out__rdy[1'd0];
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd2] != 3'd0 ) begin
        in2 = recv_opt__msg.fu_in[2'd2] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 6'( __const__OPT_SEL ) ) begin
        if ( recv_in__msg[in0_idx].payload == 32'd1 ) begin
          send_out__msg[1'd0] = recv_in__msg[in1_idx];
        end
        else
          send_out__msg[1'd0] = recv_in__msg[in2_idx];
        send_out__msg[1'd0].predicate = ( ( ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & recv_in__msg[in2_idx].predicate ) & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate ) ) & reached_vector_factor;
        recv_all_val = ( ( recv_in__val[in0_idx] & recv_in__val[in1_idx] ) & recv_in__val[in2_idx] ) & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in2_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
        recv_in__rdy[in2_idx] = 1'd0;
      end
      if ( send_out__rdy[1'd0] & ( recv_opt__msg.predicate == 1'd1 ) ) begin
        recv_predicate__rdy = recv_all_val & send_out__rdy[1'd0];
      end
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/SelRTL.py:67
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= AddrType(0)
  //   s.to_mem_raddr.msg @= AddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/SelRTL.py:136
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/single/SelRTL.py:144
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //          (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];
  assign in2_idx = in2[1:0];
  assign vector_factor_power = 3'd0;

endmodule


// PyMTL VerilogPlaceholder AddRecFN Definition
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/AddRecFNRTL.py

//***********************************************************
// Pickled source file of placeholder AddRecFN__expWidth_9__sigWidth_23
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder AddRecFN
//-----------------------------------------------------------

`ifndef ADDRECFN
`define ADDRECFN

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component AddRecFN__expWidth_9__sigWidth_23.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!

`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_primitives.v" 0
`ifndef __HARDFLOAT_PRIMITIVES_VI__
`define __HARDFLOAT_PRIMITIVES_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    reverse#(parameter width = 1) (
        input [(width - 1):0] in, output [(width - 1):0] out
    );

    genvar ix;
    generate
        for (ix = 0; ix < width; ix = ix + 1) begin :Bit
            assign out[ix] = in[width - 1 - ix];
        end
    endgenerate

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    lowMaskHiLo#(
        parameter inWidth = 1,
        parameter topBound = 1,
        parameter bottomBound = 0
    ) (
        input [(inWidth - 1):0] in,
        output [(topBound - bottomBound - 1):0] out
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam numInVals = 1<<inWidth;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [numInVals:0] c;
    assign c[numInVals] = 1;
    assign c[(numInVals - 1):0] = 0;
    wire [(topBound - bottomBound - 1):0] reverseOut =
        (c>>>in)>>(numInVals - topBound);
    reverse#(topBound - bottomBound) reverse(reverseOut, out);

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    lowMaskLoHi#(
        parameter inWidth = 1,
        parameter topBound = 0,
        parameter bottomBound = 1
    ) (
        input [(inWidth - 1):0] in,
        output [(bottomBound - topBound - 1):0] out
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam numInVals = 1<<inWidth;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [numInVals:0] c;
    assign c[numInVals] = 1;
    assign c[(numInVals - 1):0] = 0;
    wire [(bottomBound - topBound - 1):0] reverseOut =
        (c>>>~in)>>(topBound + 1);
    reverse#(bottomBound - topBound) reverse(reverseOut, out);

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    countLeadingZeros#(parameter inWidth = 1, parameter countWidth = 1) (
        input [(inWidth - 1):0] in, output [(countWidth - 1):0] count
    );

    wire [(inWidth - 1):0] reverseIn;
    reverse#(inWidth) reverse_in(in, reverseIn);
    wire [inWidth:0] oneLeastReverseIn =
        {1'b1, reverseIn} & ({1'b0, ~reverseIn} + 1);
    genvar ix;
    generate
        for (ix = 0; ix <= inWidth; ix = ix + 1) begin :Bit
            wire [(countWidth - 1):0] countSoFar;
            if (ix == 0) begin
                assign countSoFar = 0;
            end else begin
                assign countSoFar =
                    Bit[ix - 1].countSoFar | (oneLeastReverseIn[ix] ? ix : 0);
                if (ix == inWidth) assign count = countSoFar;
            end
        end
    endgenerate

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    compressBy2#(parameter inWidth = 1) (
        input [(inWidth - 1):0] in, output [((inWidth - 1)/2):0] out
    );

    localparam maxBitNumReduced = (inWidth - 1)/2;
    genvar ix;
    generate
        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit
            assign out[ix] = |in[(ix*2 + 1):ix*2];
        end
    endgenerate
    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*2];

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    compressBy4#(parameter inWidth = 1) (
        input [(inWidth - 1):0] in, output [(inWidth - 1)/4:0] out
    );

    localparam maxBitNumReduced = (inWidth - 1)/4;
    genvar ix;
    generate
        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit
            assign out[ix] = |in[(ix*4 + 3):ix*4];
        end
    endgenerate
    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*4];

endmodule

`endif /* __HARDFLOAT_PRIMITIVES_VI__ */
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/isSigNaNRecFN.v" 0
`ifndef __HARDFLOAT_ISSIGNANRECFN_V__
`define __HARDFLOAT_ISSIGNANRECFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    isSigNaNRecFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in, output isSigNaN
    );

    wire isNaN =
        (in[(expWidth + sigWidth - 1):(expWidth + sigWidth - 3)] == 'b111);
    assign isSigNaN = isNaN && !in[sigWidth - 2];

endmodule

`endif /* __HARDFLOAT_ISSIGNANRECFN_V__ */
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
`ifndef __HARDFLOAT_RAWFN_VI__
`define __HARDFLOAT_RAWFN_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_consts.vi" 0
`ifndef __HARDFLOAT_CONSTS_VI__
`define __HARDFLOAT_CONSTS_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define round_near_even   3'b000
`define round_minMag      3'b001
`define round_min         3'b010
`define round_max         3'b011
`define round_near_maxMag 3'b100
`define round_odd         3'b110

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define floatControlWidth 1
`define flControl_tininessBeforeRounding 1'b0
`define flControl_tininessAfterRounding  1'b1

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flRoundOpt_sigMSBitAlwaysZero  1
`define flRoundOpt_subnormsAlwaysExact 2
`define flRoundOpt_neverUnderflows     4
`define flRoundOpt_neverOverflows      8

`endif /* __HARDFLOAT_CONSTS_VI__ */

`line 40 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_specialize.vi" 0
`ifndef __HARDFLOAT_SPECIALIZE_VI__
`define __HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    iNFromException#(parameter width = 1) (
        input signedOut,
        input isNaN,
        input sign,
        output [(width - 1):0] out
    );

    wire maxInt = isNaN || !sign;
    assign out = {signedOut ^ maxInt, {(width - 1){maxInt}}};

endmodule

`endif /* __HARDFLOAT_SPECIALIZE_VI__ */

`line 41 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0

/* ===================== Adding some extra include files ================ */
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/RISCV/HardFloat_specialize.vi" 0
`ifndef __RISCV_HARDFLOAT_SPECIALIZE_VI__
`define __RISCV_HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flControl_default `flControl_tininessAfterRounding

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
//`define HardFloat_propagateNaNPayloads

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define HardFloat_signDefaultNaN 0
`define HardFloat_fractDefaultNaN(sigWidth) {1'b1, {((sigWidth) - 2){1'b0}}}

`endif /* __RISCV_HARDFLOAT_SPECIALIZE_VI__ */

`line 44 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_rawFN.v" 0
/* ====================================================================== */

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    recFNToRawFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(expWidth + sigWidth):0] in,
        output isNaN,
        output isInf,
        output isZero,
        output sign,
        output signed [(expWidth + 1):0] sExp,
        output [sigWidth:0] sig
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [expWidth:0] exp;
    wire [(sigWidth - 2):0] fract;
    assign {sign, exp, fract} = in;
    wire isSpecial = (exp>>(expWidth - 1) == 'b11);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    assign isNaN = isSpecial &&  exp[expWidth - 2];
    assign isInf = isSpecial && !exp[expWidth - 2];
    assign isZero = (exp>>(expWidth - 2) == 'b000);
    assign sExp = exp;
    assign sig = {1'b0, !isZero, fract};

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    roundAnyRawFNToRecFN#(
        parameter inExpWidth = 3,
        parameter inSigWidth = 3,
        parameter outExpWidth = 3,
        parameter outSigWidth = 3,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,     // overrides 'infiniteExc' and 'in_*' inputs
        input infiniteExc,    // overrides 'in_*' inputs except 'in_sign'
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(inExpWidth + 1):0] in_sExp,   // limited range allowed
        input [inSigWidth:0] in_sig,
        input [2:0] roundingMode,
        output [(outExpWidth + outSigWidth):0] out,
        output [4:0] exceptionFlags
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam sigMSBitAlwaysZero =
        ((options & `flRoundOpt_sigMSBitAlwaysZero) != 0);
    localparam effectiveInSigWidth =
        sigMSBitAlwaysZero ? inSigWidth : inSigWidth + 1;
    localparam neverUnderflows =
        ((options
              & (`flRoundOpt_neverUnderflows
                     | `flRoundOpt_subnormsAlwaysExact))
             != 0)
            || (inExpWidth < outExpWidth);
    localparam neverOverflows =
        ((options & `flRoundOpt_neverOverflows) != 0)
            || (inExpWidth < outExpWidth);
    localparam adjustedExpWidth =
          (inExpWidth < outExpWidth) ? outExpWidth + 1
        : (inExpWidth == outExpWidth) ? inExpWidth + 2
        : inExpWidth + 3;
    localparam outNaNExp = 7<<(outExpWidth - 2);
    localparam outInfExp = 6<<(outExpWidth - 2);
    localparam outMaxFiniteExp = outInfExp - 1;
    localparam outMinNormExp = (1<<(outExpWidth - 1)) + 2;
    localparam outMinNonzeroExp = outMinNormExp - outSigWidth + 1;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire roundingMode_near_even   = (roundingMode == `round_near_even);
    wire roundingMode_minMag      = (roundingMode == `round_minMag);
    wire roundingMode_min         = (roundingMode == `round_min);
    wire roundingMode_max         = (roundingMode == `round_max);
    wire roundingMode_near_maxMag = (roundingMode == `round_near_maxMag);
    wire roundingMode_odd         = (roundingMode == `round_odd);
    wire roundMagUp =
        (roundingMode_min && in_sign) || (roundingMode_max && !in_sign);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaNOut = invalidExc || (!infiniteExc && in_isNaN);
`ifdef HardFloat_propagateNaNPayloads
    wire propagateNaNPayload = isNaNOut;
`else
    wire propagateNaNPayload = 0;
`endif
    wire signed [(adjustedExpWidth - 1):0] sAdjustedExp =
        in_sExp + ((1<<outExpWidth) - (1<<inExpWidth));
    wire [(outSigWidth + 2):0] adjustedSig;
    generate
        if (inSigWidth <= outSigWidth + 2) begin
            assign adjustedSig = in_sig<<(outSigWidth - inSigWidth + 2);
        end else begin
            assign adjustedSig =
                {in_sig[inSigWidth:(inSigWidth - outSigWidth - 1)],
                 |in_sig[(inSigWidth - outSigWidth - 2):0]};
        end
    endgenerate
    wire doShiftSigDown1 =
        sigMSBitAlwaysZero ? 0 : adjustedSig[outSigWidth + 2];
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire [outExpWidth:0] common_expOut;
    wire [(outSigWidth - 2):0] common_fractOut;
    wire common_overflow, common_totalUnderflow, common_underflow;
    wire common_inexact;
    generate
        if (
            neverOverflows && neverUnderflows
                && (effectiveInSigWidth <= outSigWidth)
        ) begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_expOut = sAdjustedExp + doShiftSigDown1;
            assign common_fractOut =
                doShiftSigDown1 ? adjustedSig>>3 : adjustedSig>>2;
            assign common_overflow       = 0;
            assign common_totalUnderflow = 0;
            assign common_underflow      = 0;
            assign common_inexact        = 0;
        end else begin
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire [(outSigWidth + 2):0] roundMask;
            if (neverUnderflows) begin
                assign roundMask = {doShiftSigDown1, 2'b11};
            end else begin
                wire [outSigWidth:0] roundMask_main;
                lowMaskLoHi#(
                    outExpWidth + 1,
                    outMinNormExp - outSigWidth - 1,
                    outMinNormExp
                ) lowMask_roundMask(
                        sAdjustedExp[outExpWidth:0]
                            | (propagateNaNPayload ? 1'b1<<outExpWidth : 1'b0),
                        roundMask_main
                    );
                assign roundMask = {roundMask_main | doShiftSigDown1, 2'b11};
            end
            wire [(outSigWidth + 2):0] shiftedRoundMask = roundMask>>1;
            wire [(outSigWidth + 2):0] roundPosMask =
                ~shiftedRoundMask & roundMask;
            wire roundPosBit =
                (|(adjustedSig[(outSigWidth + 2):3]
                       & roundPosMask[(outSigWidth + 2):3]))
                    || ((|(adjustedSig[2:0] & roundPosMask[2:0]))
                            && !propagateNaNPayload);
            wire anyRoundExtra =
                (|(adjustedSig[(outSigWidth + 2):3]
                       & shiftedRoundMask[(outSigWidth + 2):3]))
                    || ((|(adjustedSig[2:0] & shiftedRoundMask[2:0]))
                            && !propagateNaNPayload);
            wire anyRound = roundPosBit || anyRoundExtra;
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire roundIncr =
                ((roundingMode_near_even || roundingMode_near_maxMag)
                     && roundPosBit)
                    || (roundMagUp && anyRound);
            wire [(outSigWidth + 1):0] roundedSig =
                roundIncr
                    ? (((adjustedSig | roundMask)>>2) + 1)
                          & ~(roundingMode_near_even && roundPosBit
                                  && !anyRoundExtra
                                  ? roundMask>>1 : 0)
                    : (adjustedSig & ~roundMask)>>2
                          | (roundingMode_odd && anyRound
                                 ? roundPosMask>>1 : 0);
            wire signed [adjustedExpWidth:0] sExtAdjustedExp = sAdjustedExp;
            wire signed [adjustedExpWidth:0] sRoundedExp =
                sExtAdjustedExp + (roundedSig>>outSigWidth);
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_expOut = sRoundedExp;
            assign common_fractOut =
                doShiftSigDown1 ? roundedSig>>1 : roundedSig;
            assign common_overflow =
                neverOverflows ? 0 : (sRoundedExp>>>(outExpWidth - 1) >= 3);
            assign common_totalUnderflow =
                neverUnderflows ? 0 : (sRoundedExp < outMinNonzeroExp);
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            wire unboundedRange_roundPosBit =
                doShiftSigDown1 ? adjustedSig[2] : adjustedSig[1];
            wire unboundedRange_anyRound =
                (doShiftSigDown1 && adjustedSig[2]) || (|adjustedSig[1:0]);
            wire unboundedRange_roundIncr =
                ((roundingMode_near_even || roundingMode_near_maxMag)
                     && unboundedRange_roundPosBit)
                    || (roundMagUp && unboundedRange_anyRound);
            wire roundCarry =
                doShiftSigDown1
                    ? roundedSig[outSigWidth + 1] : roundedSig[outSigWidth];
            assign common_underflow =
                neverUnderflows ? 0
                    : common_totalUnderflow
                          || (anyRound && (sAdjustedExp>>>outExpWidth <= 0)
                                  && (doShiftSigDown1
                                          ? roundMask[3] : roundMask[2])
                                  && !(((control
                                           & `flControl_tininessAfterRounding)
                                            != 0)
                                           && !(doShiftSigDown1 ? roundMask[4]
                                                    : roundMask[3])
                                           && roundCarry && roundPosBit
                                           && unboundedRange_roundIncr));
            /*----------------------------------------------------------------
            *----------------------------------------------------------------*/
            assign common_inexact = common_totalUnderflow || anyRound;
        end
    endgenerate
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire notNaN_isSpecialInfOut = infiniteExc || in_isInf;
    wire commonCase = !isNaNOut && !notNaN_isSpecialInfOut && !in_isZero;
    wire overflow  = commonCase && common_overflow;
    wire underflow = commonCase && common_underflow;
    wire inexact = overflow || (commonCase && common_inexact);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire overflow_roundMagUp =
        roundingMode_near_even || roundingMode_near_maxMag || roundMagUp;
    wire pegMinNonzeroMagOut =
        commonCase && common_totalUnderflow
            && (roundMagUp || roundingMode_odd);
    wire pegMaxFiniteMagOut = overflow && !overflow_roundMagUp;
    wire notNaN_isInfOut =
        notNaN_isSpecialInfOut || (overflow && overflow_roundMagUp);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
`ifdef HardFloat_propagateNaNPayloads
    wire signOut = in_sign;
`else
    wire signOut = isNaNOut ? `HardFloat_signDefaultNaN : in_sign;
`endif
    wire [outExpWidth:0] expOut =
        (common_expOut
             & ~(in_isZero || common_totalUnderflow ? 7<<(outExpWidth - 2) : 0)
             & ~(pegMinNonzeroMagOut               ? ~outMinNonzeroExp    : 0)
             & ~(pegMaxFiniteMagOut                ? 1<<(outExpWidth - 1) : 0)
             & ~(notNaN_isInfOut                   ? 1<<(outExpWidth - 2) : 0))
            | (pegMinNonzeroMagOut ? outMinNonzeroExp : 0)
            | (pegMaxFiniteMagOut  ? outMaxFiniteExp  : 0)
            | (notNaN_isInfOut     ? outInfExp        : 0)
            | (isNaNOut            ? outNaNExp        : 0);
`ifdef HardFloat_propagateNaNPayloads
    wire [(outSigWidth - 2):0] fractOut =
        {isNaNOut
             || (!in_isZero && !common_totalUnderflow
                     && common_fractOut[outSigWidth - 2]),
         isNaNOut || (!in_isZero && !common_totalUnderflow)
             ? common_fractOut[(outSigWidth - 3):0] : 1'b0}
            | {(outSigWidth - 1){pegMaxFiniteMagOut}};
`else
    wire [(outSigWidth - 2):0] fractOut =
          (isNaNOut ? `HardFloat_fractDefaultNaN(outSigWidth) : 0)
        | (!in_isZero && !common_totalUnderflow
               ? common_fractOut & `HardFloat_fractDefaultNaN(outSigWidth) : 0)
        | (!isNaNOut && !in_isZero && !common_totalUnderflow
               ? common_fractOut & ~`HardFloat_fractDefaultNaN(outSigWidth)
               : 0)
        | {(outSigWidth - 1){pegMaxFiniteMagOut}};
`endif
    assign out = {signOut, expOut, fractOut};
    assign exceptionFlags =
        {invalidExc, infiniteExc, overflow, underflow, inexact};

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    roundRawFNToRecFN#(
        parameter expWidth = 3,
        parameter sigWidth = 3,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,     // overrides 'infiniteExc' and 'in_*' inputs
        input infiniteExc,    // overrides 'in_*' inputs except 'in_sign'
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(expWidth + 1):0] in_sExp,   // limited range allowed
        input [(sigWidth + 2):0] in_sig,
        input [2:0] roundingMode,
        output [(expWidth + sigWidth):0] out,
        output [4:0] exceptionFlags
    );

    roundAnyRawFNToRecFN#(expWidth, sigWidth + 2, expWidth, sigWidth, options)
        roundAnyRawFNToRecFN(
            control,
            invalidExc,
            infiniteExc,
            in_isNaN,
            in_isInf,
            in_isZero,
            in_sign,
            in_sExp,
            in_sig,
            roundingMode,
            out,
            exceptionFlags
        );

endmodule

`endif /* __HARDFLOAT_RAWFN_VI__ */

// End of all v_libs files for component AddRecFN__expWidth_9__sigWidth_23

`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/addRecFN.v" 0
`ifndef __HARDFLOAT_ADDRECFN_V__
`define __HARDFLOAT_ADDRECFN_V__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_consts.vi" 0
`ifndef __HARDFLOAT_CONSTS_VI__
`define __HARDFLOAT_CONSTS_VI__

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define round_near_even   3'b000
`define round_minMag      3'b001
`define round_min         3'b010
`define round_max         3'b011
`define round_near_maxMag 3'b100
`define round_odd         3'b110

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define floatControlWidth 1
`define flControl_tininessBeforeRounding 1'b0
`define flControl_tininessAfterRounding  1'b1

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/
`define flRoundOpt_sigMSBitAlwaysZero  1
`define flRoundOpt_subnormsAlwaysExact 2
`define flRoundOpt_neverUnderflows     4
`define flRoundOpt_neverOverflows      8

`endif /* __HARDFLOAT_CONSTS_VI__ */

`line 40 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/addRecFN.v" 0
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_specialize.vi" 0
`ifndef __HARDFLOAT_SPECIALIZE_VI__
`define __HARDFLOAT_SPECIALIZE_VI__

/*============================================================================

This Verilog source file is part of the Berkeley HardFloat IEEE Floating-Point
Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    iNFromException#(parameter width = 1) (
        input signedOut,
        input isNaN,
        input sign,
        output [(width - 1):0] out
    );

    wire maxInt = isNaN || !sign;
    assign out = {signedOut ^ maxInt, {(width - 1){maxInt}}};

endmodule

`endif /* __HARDFLOAT_SPECIALIZE_VI__ */

`line 41 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/addRecFN.v" 0

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    addRecFNToRaw#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(`floatControlWidth - 1):0] control,
        input subOp,
        input [(expWidth + sigWidth):0] a,
        input [(expWidth + sigWidth):0] b,
        input [2:0] roundingMode,
        output invalidExc,
        output out_isNaN,
        output out_isInf,
        output out_isZero,
        output out_sign,
        output signed [(expWidth + 1):0] out_sExp,
        output [(sigWidth + 2):0] out_sig
    );
`line 1 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/HardFloat_localFuncs.vi" 0

/*============================================================================

This Verilog include file is part of the Berkeley HardFloat IEEE Floating-
Point Arithmetic Package, Release 1, by John R. Hauser.

Copyright 2019 The Regents of the University of California.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions, and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

function integer clog2;
    input integer a;

    begin
        a = a - 1;
        for (clog2 = 0; a > 0; clog2 = clog2 + 1) a = a>>1;
    end

endfunction


`line 61 "/project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/source/addRecFN.v" 0

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    localparam alignDistWidth = clog2(sigWidth);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire isNaNA, isInfA, isZeroA, signA;
    wire signed [(expWidth + 1):0] sExpA;
    wire [sigWidth:0] sigA;
    recFNToRawFN#(expWidth, sigWidth)
        recFNToRawFN_a(a, isNaNA, isInfA, isZeroA, signA, sExpA, sigA);
    wire isSigNaNA;
    isSigNaNRecFN#(expWidth, sigWidth) isSigNaN_a(a, isSigNaNA);
    wire isNaNB, isInfB, isZeroB, signB;
    wire signed [(expWidth + 1):0] sExpB;
    wire [sigWidth:0] sigB;
    recFNToRawFN#(expWidth, sigWidth)
        recFNToRawFN_b(b, isNaNB, isInfB, isZeroB, signB, sExpB, sigB);
    wire effSignB = subOp ? !signB : signB;
    wire isSigNaNB;
    isSigNaNRecFN#(expWidth, sigWidth) isSigNaN_b(b, isSigNaNB);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire eqSigns = (signA == effSignB);
    wire notEqSigns_signZero = (roundingMode == `round_min) ? 1 : 0;
    wire signed [(expWidth + 1):0] sDiffExps = sExpA - sExpB;
    wire [(alignDistWidth - 1):0] modNatAlignDist =
        (sDiffExps < 0) ? sExpB - sExpA : sDiffExps;
    wire isMaxAlign =
        (sDiffExps>>>alignDistWidth != 0)
            && ((sDiffExps>>>alignDistWidth != -1)
                    || (sDiffExps[(alignDistWidth - 1):0] == 0));
    wire [(alignDistWidth - 1):0] alignDist =
        isMaxAlign ? (1<<alignDistWidth) - 1 : modNatAlignDist;
    wire closeSubMags = !eqSigns && !isMaxAlign && (modNatAlignDist <= 1);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire signed [(sigWidth + 2):0] close_alignedSigA =
          ((0 <= sDiffExps) &&  sDiffExps[0] ? sigA<<2 : 0)
        | ((0 <= sDiffExps) && !sDiffExps[0] ? sigA<<1 : 0)
        | ((sDiffExps < 0)                   ? sigA    : 0);
    wire signed [(sigWidth + 2):0] close_sSigSum =
        close_alignedSigA - (sigB<<1);
    wire [(sigWidth + 1):0] close_sigSum =
        (close_sSigSum < 0) ? -close_sSigSum : close_sSigSum;
    wire [(sigWidth + 1 + (sigWidth & 1)):0] close_adjustedSigSum =
        close_sigSum<<(sigWidth & 1);
    wire [(sigWidth + 1)/2:0] close_reduced2SigSum;
    compressBy2#(sigWidth + 2 + (sigWidth & 1))
        compressBy2_close_sigSum(close_adjustedSigSum, close_reduced2SigSum);
    wire [(alignDistWidth - 1):0] close_normDistReduced2;
    countLeadingZeros#((sigWidth + 3)/2, alignDistWidth)
        countLeadingZeros_close(close_reduced2SigSum, close_normDistReduced2);
    wire [(alignDistWidth - 1):0] close_nearNormDist =
        close_normDistReduced2<<1;
    wire [(sigWidth + 2):0] close_sigOut =
        (close_sigSum<<close_nearNormDist)<<1;
    wire close_totalCancellation =
        !(|close_sigOut[(sigWidth + 2):(sigWidth + 1)]);
    wire close_notTotalCancellation_signOut = signA ^ (close_sSigSum < 0);
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire far_signOut = (sDiffExps < 0) ? effSignB : signA;
    wire [(sigWidth - 1):0] far_sigLarger  = (sDiffExps < 0) ? sigB : sigA;
    wire [(sigWidth - 1):0] far_sigSmaller = (sDiffExps < 0) ? sigA : sigB;
    wire [(sigWidth + 4):0] far_mainAlignedSigSmaller =
        {far_sigSmaller, 5'b0}>>alignDist;
    wire [(sigWidth + 1)/4:0] far_reduced4SigSmaller;
    compressBy4#(sigWidth + 2)
        compressBy4_far_sigSmaller(
            {far_sigSmaller, 2'b00}, far_reduced4SigSmaller);
    wire [(sigWidth + 1)/4:0] far_roundExtraMask;
    lowMaskHiLo#(alignDistWidth - 2, (sigWidth + 5)/4, 0)
        lowMask_far_roundExtraMask(
            alignDist[(alignDistWidth - 1):2], far_roundExtraMask);
    wire [(sigWidth + 2):0] far_alignedSigSmaller =
        {far_mainAlignedSigSmaller>>3,
         (|far_mainAlignedSigSmaller[2:0])
             || (|(far_reduced4SigSmaller & far_roundExtraMask))};
    wire far_subMags = !eqSigns;
    wire [(sigWidth + 3):0] far_negAlignedSigSmaller =
        far_subMags ? {1'b1, ~far_alignedSigSmaller}
            : {1'b0, far_alignedSigSmaller};
    wire [(sigWidth + 3):0] far_sigSum =
        (far_sigLarger<<3) + far_negAlignedSigSmaller + far_subMags;
    wire [(sigWidth + 2):0] far_sigOut =
        far_subMags ? far_sigSum : far_sigSum>>1 | far_sigSum[0];
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire notSigNaN_invalidExc = isInfA && isInfB && !eqSigns;
    wire notNaN_isInfOut = isInfA || isInfB;
    wire addZeros = isZeroA && isZeroB;
    wire notNaN_specialCase = notNaN_isInfOut || addZeros;
    wire notNaN_isZeroOut =
        addZeros
            || (!notNaN_isInfOut && closeSubMags && close_totalCancellation);
    wire notNaN_signOut =
           (eqSigns                      && signA              )
        || (isInfA                       && signA              )
        || (isInfB                       && effSignB           )
        || (notNaN_isZeroOut && !eqSigns && notEqSigns_signZero)
        || (!notNaN_specialCase && closeSubMags && !close_totalCancellation
                                        && close_notTotalCancellation_signOut)
        || (!notNaN_specialCase && !closeSubMags && far_signOut);
    wire signed [(expWidth + 1):0] common_sExpOut =
        (closeSubMags || (sDiffExps < 0) ? sExpB : sExpA)
            - (closeSubMags ? close_nearNormDist : far_subMags);
    wire [(sigWidth + 2):0] common_sigOut =
        closeSubMags ? close_sigOut : far_sigOut;
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    assign invalidExc = isSigNaNA || isSigNaNB || notSigNaN_invalidExc;
    assign out_isInf = notNaN_isInfOut;
    assign out_isZero = notNaN_isZeroOut;
    assign out_sExp = common_sExpOut;
`ifdef HardFloat_propagateNaNPayloads
    assign out_isNaN = isNaNA || isNaNB || notSigNaN_invalidExc;
    wire signNaN;
    wire [(sigWidth - 2):0] fractNaN;
    propagateFloatNaN_add#(sigWidth)
        propagateNaN(
            control,
            subOp,
            isNaNA,
            signA,
            sigA[(sigWidth - 2):0],
            isNaNB,
            signB,
            sigB[(sigWidth - 2):0],
            signNaN,
            fractNaN
        );
    assign out_sign = out_isNaN ? signNaN : notNaN_signOut;
    assign out_sig = out_isNaN ? {1'b1, fractNaN, 2'b00} : common_sigOut;
`else
    assign out_isNaN = isNaNA || isNaNB;
    assign out_sign = notNaN_signOut;
    assign out_sig = common_sigOut;
`endif

endmodule

/*----------------------------------------------------------------------------
*----------------------------------------------------------------------------*/

module
    addRecFN#(parameter expWidth = 3, parameter sigWidth = 3) (
        input [(`floatControlWidth - 1):0] control,
        input subOp,
        input [(expWidth + sigWidth):0] a,
        input [(expWidth + sigWidth):0] b,
        input [2:0] roundingMode,
        output [(expWidth + sigWidth):0] out,
        output [4:0] exceptionFlags
    );

    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    wire invalidExc, out_isNaN, out_isInf, out_isZero, out_sign;
    wire signed [(expWidth + 1):0] out_sExp;
    wire [(sigWidth + 2):0] out_sig;
    addRecFNToRaw#(expWidth, sigWidth)
        addRecFNToRaw(
            control,
            subOp,
            a,
            b,
            roundingMode,
            invalidExc,
            out_isNaN,
            out_isInf,
            out_isZero,
            out_sign,
            out_sExp,
            out_sig
        );
    /*------------------------------------------------------------------------
    *------------------------------------------------------------------------*/
    roundRawFNToRecFN#(expWidth, sigWidth, `flRoundOpt_subnormsAlwaysExact)
        roundRawOut(
            control,
            invalidExc,
            1'b0,
            out_isNaN,
            out_isInf,
            out_isZero,
            out_sign,
            out_sExp,
            out_sig,
            roundingMode,
            out,
            exceptionFlags
        );

endmodule

`endif /* __HARDFLOAT_ADDRECFN_V__ */

`endif /* ADDRECFN */

//-----------------------------------------------------------
// Wrapper of placeholder AddRecFN__expWidth_9__sigWidth_23
//-----------------------------------------------------------

`ifndef ADDRECFN__EXPWIDTH_9__SIGWIDTH_23
`define ADDRECFN__EXPWIDTH_9__SIGWIDTH_23

module AddRecFN__expWidth_9__sigWidth_23
(
  input logic reset,
  input logic clk,
  input logic [33-1:0] a ,
  input logic [33-1:0] b ,
  input logic [1-1:0] control ,
  output logic [5-1:0] exceptionFlags ,
  output logic [33-1:0] out ,
  input logic [3-1:0] roundingMode ,
  input logic [1-1:0] subOp 
);
  addRecFN
  #(
    .expWidth( 9 ),
    .sigWidth( 23 )
  ) v
  (
    .a( a ),
    .b( b ),
    .control( control ),
    .exceptionFlags( exceptionFlags ),
    .out( out ),
    .roundingMode( roundingMode ),
    .subOp( subOp )
  );
endmodule

`endif /* ADDRECFN__EXPWIDTH_9__SIGWIDTH_23 */



// PyMTL Component AddFN Definition
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/pymtl3_hardfloat/HardFloat/AddFNRTL.py

module AddFN__expWidth_9__sigWidth_23
(
  input  logic [31:0] a ,
  input  logic [31:0] b ,
  input  logic [0:0] clk ,
  output logic [31:0] out ,
  input  logic [0:0] reset ,
  input  logic [2:0] roundingMode ,
  input  logic [0:0] subOp 
);
  logic [32:0] conv_a;
  logic [32:0] conv_b;
  logic [4:0] exception_flags;
  //-------------------------------------------------------------
  // Component adder
  //-------------------------------------------------------------

  logic [32:0] adder_a;
  logic [32:0] adder_b;
  logic [0:0] adder_clk;
  logic [0:0] adder_control;
  logic [4:0] adder_exceptionFlags;
  logic [32:0] adder_out;
  logic [0:0] adder_reset;
  logic [2:0] adder_roundingMode;
  logic [0:0] adder_subOp;

  AddRecFN__expWidth_9__sigWidth_23 adder
  (
    .a( adder_a ),
    .b( adder_b ),
    .clk( adder_clk ),
    .control( adder_control ),
    .exceptionFlags( adder_exceptionFlags ),
    .out( adder_out ),
    .reset( adder_reset ),
    .roundingMode( adder_roundingMode ),
    .subOp( adder_subOp )
  );

  //-------------------------------------------------------------
  // End of component adder
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component rec_to_std_conv
  //-------------------------------------------------------------

  logic [0:0] rec_to_std_conv_clk;
  logic [32:0] rec_to_std_conv_in_;
  logic [31:0] rec_to_std_conv_out;
  logic [0:0] rec_to_std_conv_reset;

  RecFNToFN__expWidth_9__sigWidth_23 rec_to_std_conv
  (
    .clk( rec_to_std_conv_clk ),
    .in_( rec_to_std_conv_in_ ),
    .out( rec_to_std_conv_out ),
    .reset( rec_to_std_conv_reset )
  );

  //-------------------------------------------------------------
  // End of component rec_to_std_conv
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component std_to_rec_conv_a
  //-------------------------------------------------------------

  logic [0:0] std_to_rec_conv_a_clk;
  logic [31:0] std_to_rec_conv_a_in_;
  logic [32:0] std_to_rec_conv_a_out;
  logic [0:0] std_to_rec_conv_a_reset;

  FNToRecFN__expWidth_9__sigWidth_23 std_to_rec_conv_a
  (
    .clk( std_to_rec_conv_a_clk ),
    .in_( std_to_rec_conv_a_in_ ),
    .out( std_to_rec_conv_a_out ),
    .reset( std_to_rec_conv_a_reset )
  );

  //-------------------------------------------------------------
  // End of component std_to_rec_conv_a
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component std_to_rec_conv_b
  //-------------------------------------------------------------

  logic [0:0] std_to_rec_conv_b_clk;
  logic [31:0] std_to_rec_conv_b_in_;
  logic [32:0] std_to_rec_conv_b_out;
  logic [0:0] std_to_rec_conv_b_reset;

  FNToRecFN__expWidth_9__sigWidth_23 std_to_rec_conv_b
  (
    .clk( std_to_rec_conv_b_clk ),
    .in_( std_to_rec_conv_b_in_ ),
    .out( std_to_rec_conv_b_out ),
    .reset( std_to_rec_conv_b_reset )
  );

  //-------------------------------------------------------------
  // End of component std_to_rec_conv_b
  //-------------------------------------------------------------

  assign std_to_rec_conv_a_clk = clk;
  assign std_to_rec_conv_a_reset = reset;
  assign std_to_rec_conv_b_clk = clk;
  assign std_to_rec_conv_b_reset = reset;
  assign rec_to_std_conv_clk = clk;
  assign rec_to_std_conv_reset = reset;
  assign adder_clk = clk;
  assign adder_reset = reset;
  assign std_to_rec_conv_a_in_ = a;
  assign conv_a = std_to_rec_conv_a_out;
  assign std_to_rec_conv_b_in_ = b;
  assign conv_b = std_to_rec_conv_b_out;
  assign adder_control = 1'd1;
  assign adder_a = conv_a;
  assign adder_b = conv_b;
  assign adder_roundingMode = roundingMode;
  assign adder_subOp = subOp;
  assign exception_flags = adder_exceptionFlags;
  assign rec_to_std_conv_in_ = adder_out;
  assign out = rec_to_std_conv_out;

endmodule


// PyMTL Component FpAddRTL Definition
// Full name: FpAddRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__PredicateType_CGRAData_1_1__payload_1__predicate_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__num_inports_4__num_outports_2__data_mem_size_288__exp_nbits_8__sig_nbits_23
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/float/FpAddRTL.py

module FpAddRTL__ea91a20faab79471
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  input CGRAData_1_1__payload_1__predicate_1 recv_predicate__msg  ,
  output logic [0:0] recv_predicate__rdy  ,
  input logic [0:0] recv_predicate__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_zero  = { 32'd0, 1'd0, 1'd0, 1'd0 };
  localparam logic [5:0] __const__OPT_START  = 6'd0;
  localparam logic [0:0] __const__latency_at_proceed_latency  = 1'd1;
  localparam logic [5:0] __const__OPT_FSUB  = 6'd38;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [5:0] __const__OPT_FADD  = 6'd37;
  localparam logic [5:0] __const__OPT_FADD_CONST  = 6'd39;
  localparam logic [5:0] __const__OPT_FINC  = 6'd40;
  logic [2:0] in0;
  logic [1:0] in0_idx;
  logic [2:0] in1;
  logic [1:0] in1_idx;
  logic [0:0] latency;
  logic [0:0] reached_vector_factor;
  logic [0:0] recv_all_val;
  logic [7:0] vector_factor_counter;
  logic [2:0] vector_factor_power;
  //-------------------------------------------------------------
  // Component fadd
  //-------------------------------------------------------------

  logic [31:0] fadd__a;
  logic [31:0] fadd__b;
  logic [0:0] fadd__clk;
  logic [31:0] fadd__out;
  logic [0:0] fadd__reset;
  logic [2:0] fadd__roundingMode;
  logic [0:0] fadd__subOp;

  AddFN__expWidth_9__sigWidth_23 fadd
  (
    .a( fadd__a ),
    .b( fadd__b ),
    .clk( fadd__clk ),
    .out( fadd__out ),
    .reset( fadd__reset ),
    .roundingMode( fadd__roundingMode ),
    .subOp( fadd__subOp )
  );

  //-------------------------------------------------------------
  // End of component fadd
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/float/FpAddRTL.py:50
  // s.fadd.subOp //= lambda: s.recv_opt.msg.operation == OPT_FSUB
  
  always_comb begin : _lambda__s_dut_cgra_0__tile_0__element_fu_9__fadd_subOp
    fadd__subOp = recv_opt__msg.operation == 6'( __const__OPT_FSUB );
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/float/FpAddRTL.py:65
  //   @update
  //   def comb_logic():
  // 
  //     s.recv_all_val @= 0
  //     # For pick input register
  //     s.in0 @= 0
  //     s.in1 @= 0
  //     for i in range(num_inports):
  //       s.recv_in[i].rdy @= b1(0)
  // 
  //     for i in range(num_outports):
  //       s.send_out[i].val @= 0
  //       s.send_out[i].msg @= DataType()
  // 
  //     s.recv_const.rdy @= 0
  //     s.recv_predicate.rdy @= b1(0)
  //     s.recv_opt.rdy @= 0
  // 
  //     s.fadd.a @= 0
  //     s.fadd.b @= 0
  // 
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.fu_in[0] != 0:
  //         s.in0 @= zext(s.recv_opt.msg.fu_in[0] - 1, FuInType)
  //       if s.recv_opt.msg.fu_in[1] != 0:
  //         s.in1 @= zext(s.recv_opt.msg.fu_in[1] - 1, FuInType)
  // 
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.operation == OPT_FADD:
  //         s.fadd.a @= s.recv_in[s.in0_idx].msg.payload
  //         s.fadd.b @= s.recv_in[s.in1_idx].msg.payload
  //         s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                        s.recv_in[s.in1_idx].msg.predicate & \
  //                                        (~s.recv_opt.msg.predicate | \
  //                                         s.recv_predicate.msg.predicate)
  //         s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val & \
  //                           ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //         s.send_out[0].val @= s.recv_all_val
  //         s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //         s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //         s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //       elif s.recv_opt.msg.operation == OPT_FADD_CONST:
  //         s.fadd.a @= s.recv_in[s.in0_idx].msg.payload
  //         s.fadd.b @= s.recv_const.msg.payload
  //         s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                        (~s.recv_opt.msg.predicate | \
  //                                         s.recv_predicate.msg.predicate)
  //         s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_const.val & \
  //                           ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //         s.send_out[0].val @= s.recv_all_val
  //         s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //         s.recv_const.rdy @= s.recv_all_val & s.send_out[0].rdy
  //         s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //       elif s.recv_opt.msg.operation == OPT_FINC:
  //         s.fadd.a @= s.recv_in[s.in0_idx].msg.payload
  //         s.fadd.b @= s.FLOATING_ONE
  //         s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                        (~s.recv_opt.msg.predicate | \
  //                                         s.recv_predicate.msg.predicate)
  //         s.recv_all_val @= s.recv_in[s.in0_idx].val & \
  //                           ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //         s.send_out[0].val @= s.recv_all_val & s.send_out[0].rdy
  //         s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //         s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //       elif s.recv_opt.msg.operation == OPT_FSUB:
  //         s.fadd.a @= s.recv_in[s.in0_idx].msg.payload
  //         s.fadd.b @= s.recv_in[s.in1_idx].msg.payload
  //         s.send_out[0].msg.predicate @= s.recv_in[s.in0_idx].msg.predicate & \
  //                                        s.recv_in[s.in1_idx].msg.predicate & \
  //                                        (~s.recv_opt.msg.predicate | \
  //                                         s.recv_predicate.msg.predicate)
  //         s.recv_all_val @= s.recv_in[s.in0_idx].val & s.recv_in[s.in1_idx].val & \
  //                           ((s.recv_opt.msg.predicate == b1(0)) | s.recv_predicate.val)
  //         s.send_out[0].val @= s.recv_all_val
  //         s.recv_in[s.in0_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //         s.recv_in[s.in1_idx].rdy @= s.recv_all_val & s.send_out[0].rdy
  //         s.recv_opt.rdy @= s.recv_all_val & s.send_out[0].rdy
  //       else:
  //         for j in range( num_outports ):
  //           s.send_out[j].val @= b1(0)
  //         s.recv_opt.rdy @= 0
  //         s.recv_in[s.in0_idx].rdy @= 0
  //         s.recv_in[s.in1_idx].rdy @= 0
  // 
  //       if s.recv_opt.msg.predicate == b1(1):
  //         s.recv_predicate.rdy @= s.recv_all_val & s.send_out[0].rdy
  // 
  //       s.send_out[0].msg.payload @= s.fadd.out
  
  always_comb begin : comb_logic
    recv_all_val = 1'd0;
    in0 = 3'd0;
    in1 = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_comb_logic ); i += 1'd1 )
      recv_in__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_outports_at_comb_logic ); i += 1'd1 ) begin
      send_out__val[1'(i)] = 1'd0;
      send_out__msg[1'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_const__rdy = 1'd0;
    recv_predicate__rdy = 1'd0;
    recv_opt__rdy = 1'd0;
    fadd__a = 32'd0;
    fadd__b = 32'd0;
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.fu_in[2'd0] != 3'd0 ) begin
        in0 = recv_opt__msg.fu_in[2'd0] - 3'd1;
      end
      if ( recv_opt__msg.fu_in[2'd1] != 3'd0 ) begin
        in1 = recv_opt__msg.fu_in[2'd1] - 3'd1;
      end
    end
    if ( recv_opt__val ) begin
      if ( recv_opt__msg.operation == 6'( __const__OPT_FADD ) ) begin
        fadd__a = recv_in__msg[in0_idx].payload;
        fadd__b = recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate );
        recv_all_val = ( recv_in__val[in0_idx] & recv_in__val[in1_idx] ) & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_FADD_CONST ) ) begin
        fadd__a = recv_in__msg[in0_idx].payload;
        fadd__b = recv_const__msg.payload;
        send_out__msg[1'd0].predicate = recv_in__msg[in0_idx].predicate & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate );
        recv_all_val = ( recv_in__val[in0_idx] & recv_const__val ) & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_const__rdy = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_FINC ) ) begin
        fadd__a = recv_in__msg[in0_idx].payload;
        fadd__b = 32'd1065353216;
        send_out__msg[1'd0].predicate = recv_in__msg[in0_idx].predicate & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate );
        recv_all_val = recv_in__val[in0_idx] & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else if ( recv_opt__msg.operation == 6'( __const__OPT_FSUB ) ) begin
        fadd__a = recv_in__msg[in0_idx].payload;
        fadd__b = recv_in__msg[in1_idx].payload;
        send_out__msg[1'd0].predicate = ( recv_in__msg[in0_idx].predicate & recv_in__msg[in1_idx].predicate ) & ( ( ~recv_opt__msg.predicate ) | recv_predicate__msg.predicate );
        recv_all_val = ( recv_in__val[in0_idx] & recv_in__val[in1_idx] ) & ( ( recv_opt__msg.predicate == 1'd0 ) | recv_predicate__val );
        send_out__val[1'd0] = recv_all_val;
        recv_in__rdy[in0_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_in__rdy[in1_idx] = recv_all_val & send_out__rdy[1'd0];
        recv_opt__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      else begin
        for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 )
          send_out__val[1'(j)] = 1'd0;
        recv_opt__rdy = 1'd0;
        recv_in__rdy[in0_idx] = 1'd0;
        recv_in__rdy[in1_idx] = 1'd0;
      end
      if ( recv_opt__msg.predicate == 1'd1 ) begin
        recv_predicate__rdy = recv_all_val & send_out__rdy[1'd0];
      end
      send_out__msg[1'd0].payload = fadd__out;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:66
  // @update
  // def update_mem():
  //   s.to_mem_waddr.val @= b1(0)
  //   s.to_mem_wdata.val @= b1(0)
  //   s.to_mem_wdata.msg @= s.const_zero
  //   s.to_mem_waddr.msg @= DataAddrType(0)
  //   s.to_mem_raddr.msg @= DataAddrType(0)
  //   s.to_mem_raddr.val @= b1(0)
  //   s.from_mem_rdata.rdy @= b1(0)
  
  always_comb begin : update_mem
    to_mem_waddr__val = 1'd0;
    to_mem_wdata__val = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 9'd0;
    to_mem_raddr__msg = 9'd0;
    to_mem_raddr__val = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:85
  // @update
  // def update_reached_vector_factor():
  //   s.reached_vector_factor @= 0
  //   if s.recv_opt.val & (s.vector_factor_counter + \
  //                        (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) >= \
  //                        (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //     s.reached_vector_factor @= 1
  
  always_comb begin : update_reached_vector_factor
    reached_vector_factor = 1'd0;
    if ( recv_opt__val & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) >= ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
      reached_vector_factor = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:76
  // @update_ff
  // def proceed_latency():
  //   if s.recv_opt.msg.operation == OPT_START:
  //     s.latency <<= LatencyType(0)
  //   elif s.latency == latency - 1:
  //     s.latency <<= LatencyType(0)
  //   else:
  //     s.latency <<= s.latency + LatencyType(1)
  
  always_ff @(posedge clk) begin : proceed_latency
    if ( recv_opt__msg.operation == 6'( __const__OPT_START ) ) begin
      latency <= 1'd0;
    end
    else if ( latency == ( 1'( __const__latency_at_proceed_latency ) - 1'd1 ) ) begin
      latency <= 1'd0;
    end
    else
      latency <= latency + 1'd1;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/basic/Fu.py:93
  // @update_ff
  // def update_vector_factor_counter():
  //   if s.reset:
  //     s.vector_factor_counter <<= 0
  //   else:
  //     if s.recv_opt.val:
  //       if s.recv_opt.msg.is_last_ctrl & \
  //          (s.vector_factor_counter + \
  //           (VectorFactorType(1) << zext(s.vector_factor_power, VectorFactorType)) < \
  //          (VectorFactorType(1) << zext(s.recv_opt.msg.vector_factor_power, VectorFactorType))):
  //         s.vector_factor_counter <<= s.vector_factor_counter + \
  //                                     (VectorFactorType(1) << zext(s.vector_factor_power, \
  //                                                                  VectorFactorType))
  //       elif s.recv_opt.msg.is_last_ctrl & s.reached_vector_factor:
  //         s.vector_factor_counter <<= 0
  
  always_ff @(posedge clk) begin : update_vector_factor_counter
    if ( reset ) begin
      vector_factor_counter <= 8'd0;
    end
    else if ( recv_opt__val ) begin
      if ( recv_opt__msg.is_last_ctrl & ( ( vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } ) ) < ( 8'd1 << { { 5 { 1'b0 } }, recv_opt__msg.vector_factor_power } ) ) ) begin
        vector_factor_counter <= vector_factor_counter + ( 8'd1 << { { 5 { 1'b0 } }, vector_factor_power } );
      end
      else if ( recv_opt__msg.is_last_ctrl & reached_vector_factor ) begin
        vector_factor_counter <= 8'd0;
      end
    end
  end

  assign vector_factor_power = 3'd0;
  assign fadd__clk = clk;
  assign fadd__reset = reset;
  assign fadd__roundingMode = 3'd0;
  assign in0_idx = in0[1:0];
  assign in1_idx = in1[1:0];

endmodule


// PyMTL Component FlexibleFuRTL Definition
// Full name: FlexibleFuRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__PredicateType_CGRAData_1_1__payload_1__predicate_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__num_inports_4__num_outports_2__data_mem_size_288__num_tiles_4__FuList_[<class 'VectorCGRA.fu.single.AdderRTL.AdderRTL'>, <class 'VectorCGRA.fu.single.MulRTL.MulRTL'>, <class 'VectorCGRA.fu.single.LogicRTL.LogicRTL'>, <class 'VectorCGRA.fu.single.ShifterRTL.ShifterRTL'>, <class 'VectorCGRA.fu.single.PhiRTL.PhiRTL'>, <class 'VectorCGRA.fu.single.CompRTL.CompRTL'>, <class 'VectorCGRA.fu.single.BranchRTL.BranchRTL'>, <class 'VectorCGRA.fu.single.MemUnitRTL.MemUnitRTL'>, <class 'VectorCGRA.fu.single.SelRTL.SelRTL'>, <class 'VectorCGRA.fu.float.FpAddRTL.FpAddRTL'>, <class 'VectorCGRA.fu.float.FpMulRTL.FpMulRTL'>, <class 'VectorCGRA.fu.double.SeqMulAdderRTL.SeqMulAdderRTL'>, <class 'VectorCGRA.fu.vector.VectorMulComboRTL.VectorMulComboRTL'>, <class 'VectorCGRA.fu.vector.VectorAdderComboRTL.VectorAdderComboRTL'>, <class 'VectorCGRA.fu.single.NahRTL.NahRTL'>]
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/flexible/FlexibleFuRTL.py

module FlexibleFuRTL__87f5ec13648cf169
(
  input  logic [0:0] clk ,
  input  logic [2:0] prologue_count_inport ,
  input  logic [0:0] reset ,
  input  logic [2:0] tile_id ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg [0:14] ,
  output logic [0:0] from_mem_rdata__rdy [0:14] ,
  input logic [0:0] from_mem_rdata__val [0:14] ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_const__msg  ,
  output logic [0:0] recv_const__rdy  ,
  input logic [0:0] recv_const__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_in__msg [0:3] ,
  output logic [0:0] recv_in__rdy [0:3] ,
  input logic [0:0] recv_in__val [0:3] ,
  input CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  input CGRAData_1_1__payload_1__predicate_1 recv_predicate__msg  ,
  output logic [0:0] recv_predicate__rdy  ,
  input logic [0:0] recv_predicate__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_out__msg [0:1] ,
  input logic [0:0] send_out__rdy [0:1] ,
  output logic [0:0] send_out__val [0:1] ,
  output logic [8:0] to_mem_raddr__msg [0:14] ,
  input logic [0:0] to_mem_raddr__rdy [0:14] ,
  output logic [0:0] to_mem_raddr__val [0:14] ,
  output logic [8:0] to_mem_waddr__msg [0:14] ,
  input logic [0:0] to_mem_waddr__rdy [0:14] ,
  output logic [0:0] to_mem_waddr__val [0:14] ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg [0:14] ,
  input logic [0:0] to_mem_wdata__rdy [0:14] ,
  output logic [0:0] to_mem_wdata__val [0:14] 
);
  localparam logic [1:0] __const__num_outports_at_comb_logic  = 2'd2;
  localparam logic [2:0] __const__num_inports_at_comb_logic  = 3'd4;
  logic [14:0] fu_recv_const_rdy_vector;
  logic [14:0] fu_recv_in_rdy_vector [0:3];
  logic [14:0] fu_recv_opt_rdy_vector;
  logic [14:0] fu_recv_predicate_rdy_vector;
  //-------------------------------------------------------------
  // Component fu[0:14]
  //-------------------------------------------------------------

  logic [0:0] fu__clk [0:14];
  logic [0:0] fu__reset [0:14];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 fu__from_mem_rdata__msg [0:14];
  logic [0:0] fu__from_mem_rdata__rdy [0:14];
  logic [0:0] fu__from_mem_rdata__val [0:14];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 fu__recv_const__msg [0:14];
  logic [0:0] fu__recv_const__rdy [0:14];
  logic [0:0] fu__recv_const__val [0:14];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 fu__recv_in__msg [0:14][0:3];
  logic [0:0] fu__recv_in__rdy [0:14][0:3];
  logic [0:0] fu__recv_in__val [0:14][0:3];
  CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf fu__recv_opt__msg [0:14];
  logic [0:0] fu__recv_opt__rdy [0:14];
  logic [0:0] fu__recv_opt__val [0:14];
  CGRAData_1_1__payload_1__predicate_1 fu__recv_predicate__msg [0:14];
  logic [0:0] fu__recv_predicate__rdy [0:14];
  logic [0:0] fu__recv_predicate__val [0:14];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 fu__send_out__msg [0:14][0:1];
  logic [0:0] fu__send_out__rdy [0:14][0:1];
  logic [0:0] fu__send_out__val [0:14][0:1];
  logic [8:0] fu__to_mem_raddr__msg [0:14];
  logic [0:0] fu__to_mem_raddr__rdy [0:14];
  logic [0:0] fu__to_mem_raddr__val [0:14];
  logic [8:0] fu__to_mem_waddr__msg [0:14];
  logic [0:0] fu__to_mem_waddr__rdy [0:14];
  logic [0:0] fu__to_mem_waddr__val [0:14];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 fu__to_mem_wdata__msg [0:14];
  logic [0:0] fu__to_mem_wdata__rdy [0:14];
  logic [0:0] fu__to_mem_wdata__val [0:14];

  AdderRTL__b48d5d572c75e2e4 fu__0
  (
    .clk( fu__clk[0] ),
    .reset( fu__reset[0] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[0] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[0] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[0] ),
    .recv_const__msg( fu__recv_const__msg[0] ),
    .recv_const__rdy( fu__recv_const__rdy[0] ),
    .recv_const__val( fu__recv_const__val[0] ),
    .recv_in__msg( fu__recv_in__msg[0] ),
    .recv_in__rdy( fu__recv_in__rdy[0] ),
    .recv_in__val( fu__recv_in__val[0] ),
    .recv_opt__msg( fu__recv_opt__msg[0] ),
    .recv_opt__rdy( fu__recv_opt__rdy[0] ),
    .recv_opt__val( fu__recv_opt__val[0] ),
    .recv_predicate__msg( fu__recv_predicate__msg[0] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[0] ),
    .recv_predicate__val( fu__recv_predicate__val[0] ),
    .send_out__msg( fu__send_out__msg[0] ),
    .send_out__rdy( fu__send_out__rdy[0] ),
    .send_out__val( fu__send_out__val[0] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[0] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[0] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[0] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[0] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[0] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[0] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[0] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[0] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[0] )
  );

  MulRTL__b48d5d572c75e2e4 fu__1
  (
    .clk( fu__clk[1] ),
    .reset( fu__reset[1] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[1] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[1] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[1] ),
    .recv_const__msg( fu__recv_const__msg[1] ),
    .recv_const__rdy( fu__recv_const__rdy[1] ),
    .recv_const__val( fu__recv_const__val[1] ),
    .recv_in__msg( fu__recv_in__msg[1] ),
    .recv_in__rdy( fu__recv_in__rdy[1] ),
    .recv_in__val( fu__recv_in__val[1] ),
    .recv_opt__msg( fu__recv_opt__msg[1] ),
    .recv_opt__rdy( fu__recv_opt__rdy[1] ),
    .recv_opt__val( fu__recv_opt__val[1] ),
    .recv_predicate__msg( fu__recv_predicate__msg[1] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[1] ),
    .recv_predicate__val( fu__recv_predicate__val[1] ),
    .send_out__msg( fu__send_out__msg[1] ),
    .send_out__rdy( fu__send_out__rdy[1] ),
    .send_out__val( fu__send_out__val[1] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[1] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[1] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[1] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[1] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[1] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[1] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[1] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[1] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[1] )
  );

  LogicRTL__b48d5d572c75e2e4 fu__2
  (
    .clk( fu__clk[2] ),
    .reset( fu__reset[2] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[2] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[2] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[2] ),
    .recv_const__msg( fu__recv_const__msg[2] ),
    .recv_const__rdy( fu__recv_const__rdy[2] ),
    .recv_const__val( fu__recv_const__val[2] ),
    .recv_in__msg( fu__recv_in__msg[2] ),
    .recv_in__rdy( fu__recv_in__rdy[2] ),
    .recv_in__val( fu__recv_in__val[2] ),
    .recv_opt__msg( fu__recv_opt__msg[2] ),
    .recv_opt__rdy( fu__recv_opt__rdy[2] ),
    .recv_opt__val( fu__recv_opt__val[2] ),
    .recv_predicate__msg( fu__recv_predicate__msg[2] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[2] ),
    .recv_predicate__val( fu__recv_predicate__val[2] ),
    .send_out__msg( fu__send_out__msg[2] ),
    .send_out__rdy( fu__send_out__rdy[2] ),
    .send_out__val( fu__send_out__val[2] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[2] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[2] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[2] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[2] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[2] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[2] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[2] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[2] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[2] )
  );

  ShifterRTL__b48d5d572c75e2e4 fu__3
  (
    .clk( fu__clk[3] ),
    .reset( fu__reset[3] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[3] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[3] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[3] ),
    .recv_const__msg( fu__recv_const__msg[3] ),
    .recv_const__rdy( fu__recv_const__rdy[3] ),
    .recv_const__val( fu__recv_const__val[3] ),
    .recv_in__msg( fu__recv_in__msg[3] ),
    .recv_in__rdy( fu__recv_in__rdy[3] ),
    .recv_in__val( fu__recv_in__val[3] ),
    .recv_opt__msg( fu__recv_opt__msg[3] ),
    .recv_opt__rdy( fu__recv_opt__rdy[3] ),
    .recv_opt__val( fu__recv_opt__val[3] ),
    .recv_predicate__msg( fu__recv_predicate__msg[3] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[3] ),
    .recv_predicate__val( fu__recv_predicate__val[3] ),
    .send_out__msg( fu__send_out__msg[3] ),
    .send_out__rdy( fu__send_out__rdy[3] ),
    .send_out__val( fu__send_out__val[3] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[3] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[3] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[3] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[3] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[3] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[3] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[3] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[3] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[3] )
  );

  PhiRTL__b48d5d572c75e2e4 fu__4
  (
    .clk( fu__clk[4] ),
    .reset( fu__reset[4] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[4] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[4] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[4] ),
    .recv_const__msg( fu__recv_const__msg[4] ),
    .recv_const__rdy( fu__recv_const__rdy[4] ),
    .recv_const__val( fu__recv_const__val[4] ),
    .recv_in__msg( fu__recv_in__msg[4] ),
    .recv_in__rdy( fu__recv_in__rdy[4] ),
    .recv_in__val( fu__recv_in__val[4] ),
    .recv_opt__msg( fu__recv_opt__msg[4] ),
    .recv_opt__rdy( fu__recv_opt__rdy[4] ),
    .recv_opt__val( fu__recv_opt__val[4] ),
    .recv_predicate__msg( fu__recv_predicate__msg[4] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[4] ),
    .recv_predicate__val( fu__recv_predicate__val[4] ),
    .send_out__msg( fu__send_out__msg[4] ),
    .send_out__rdy( fu__send_out__rdy[4] ),
    .send_out__val( fu__send_out__val[4] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[4] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[4] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[4] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[4] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[4] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[4] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[4] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[4] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[4] )
  );

  CompRTL__b48d5d572c75e2e4 fu__5
  (
    .clk( fu__clk[5] ),
    .reset( fu__reset[5] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[5] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[5] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[5] ),
    .recv_const__msg( fu__recv_const__msg[5] ),
    .recv_const__rdy( fu__recv_const__rdy[5] ),
    .recv_const__val( fu__recv_const__val[5] ),
    .recv_in__msg( fu__recv_in__msg[5] ),
    .recv_in__rdy( fu__recv_in__rdy[5] ),
    .recv_in__val( fu__recv_in__val[5] ),
    .recv_opt__msg( fu__recv_opt__msg[5] ),
    .recv_opt__rdy( fu__recv_opt__rdy[5] ),
    .recv_opt__val( fu__recv_opt__val[5] ),
    .recv_predicate__msg( fu__recv_predicate__msg[5] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[5] ),
    .recv_predicate__val( fu__recv_predicate__val[5] ),
    .send_out__msg( fu__send_out__msg[5] ),
    .send_out__rdy( fu__send_out__rdy[5] ),
    .send_out__val( fu__send_out__val[5] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[5] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[5] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[5] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[5] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[5] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[5] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[5] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[5] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[5] )
  );

  BranchRTL__b48d5d572c75e2e4 fu__6
  (
    .clk( fu__clk[6] ),
    .reset( fu__reset[6] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[6] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[6] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[6] ),
    .recv_const__msg( fu__recv_const__msg[6] ),
    .recv_const__rdy( fu__recv_const__rdy[6] ),
    .recv_const__val( fu__recv_const__val[6] ),
    .recv_in__msg( fu__recv_in__msg[6] ),
    .recv_in__rdy( fu__recv_in__rdy[6] ),
    .recv_in__val( fu__recv_in__val[6] ),
    .recv_opt__msg( fu__recv_opt__msg[6] ),
    .recv_opt__rdy( fu__recv_opt__rdy[6] ),
    .recv_opt__val( fu__recv_opt__val[6] ),
    .recv_predicate__msg( fu__recv_predicate__msg[6] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[6] ),
    .recv_predicate__val( fu__recv_predicate__val[6] ),
    .send_out__msg( fu__send_out__msg[6] ),
    .send_out__rdy( fu__send_out__rdy[6] ),
    .send_out__val( fu__send_out__val[6] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[6] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[6] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[6] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[6] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[6] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[6] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[6] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[6] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[6] )
  );

  MemUnitRTL__b48d5d572c75e2e4 fu__7
  (
    .clk( fu__clk[7] ),
    .reset( fu__reset[7] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[7] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[7] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[7] ),
    .recv_const__msg( fu__recv_const__msg[7] ),
    .recv_const__rdy( fu__recv_const__rdy[7] ),
    .recv_const__val( fu__recv_const__val[7] ),
    .recv_in__msg( fu__recv_in__msg[7] ),
    .recv_in__rdy( fu__recv_in__rdy[7] ),
    .recv_in__val( fu__recv_in__val[7] ),
    .recv_opt__msg( fu__recv_opt__msg[7] ),
    .recv_opt__rdy( fu__recv_opt__rdy[7] ),
    .recv_opt__val( fu__recv_opt__val[7] ),
    .recv_predicate__msg( fu__recv_predicate__msg[7] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[7] ),
    .recv_predicate__val( fu__recv_predicate__val[7] ),
    .send_out__msg( fu__send_out__msg[7] ),
    .send_out__rdy( fu__send_out__rdy[7] ),
    .send_out__val( fu__send_out__val[7] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[7] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[7] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[7] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[7] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[7] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[7] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[7] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[7] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[7] )
  );

  SelRTL__b48d5d572c75e2e4 fu__8
  (
    .clk( fu__clk[8] ),
    .reset( fu__reset[8] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[8] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[8] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[8] ),
    .recv_const__msg( fu__recv_const__msg[8] ),
    .recv_const__rdy( fu__recv_const__rdy[8] ),
    .recv_const__val( fu__recv_const__val[8] ),
    .recv_in__msg( fu__recv_in__msg[8] ),
    .recv_in__rdy( fu__recv_in__rdy[8] ),
    .recv_in__val( fu__recv_in__val[8] ),
    .recv_opt__msg( fu__recv_opt__msg[8] ),
    .recv_opt__rdy( fu__recv_opt__rdy[8] ),
    .recv_opt__val( fu__recv_opt__val[8] ),
    .recv_predicate__msg( fu__recv_predicate__msg[8] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[8] ),
    .recv_predicate__val( fu__recv_predicate__val[8] ),
    .send_out__msg( fu__send_out__msg[8] ),
    .send_out__rdy( fu__send_out__rdy[8] ),
    .send_out__val( fu__send_out__val[8] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[8] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[8] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[8] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[8] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[8] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[8] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[8] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[8] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[8] )
  );

  FpAddRTL__ea91a20faab79471 fu__9
  (
    .clk( fu__clk[9] ),
    .reset( fu__reset[9] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[9] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[9] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[9] ),
    .recv_const__msg( fu__recv_const__msg[9] ),
    .recv_const__rdy( fu__recv_const__rdy[9] ),
    .recv_const__val( fu__recv_const__val[9] ),
    .recv_in__msg( fu__recv_in__msg[9] ),
    .recv_in__rdy( fu__recv_in__rdy[9] ),
    .recv_in__val( fu__recv_in__val[9] ),
    .recv_opt__msg( fu__recv_opt__msg[9] ),
    .recv_opt__rdy( fu__recv_opt__rdy[9] ),
    .recv_opt__val( fu__recv_opt__val[9] ),
    .recv_predicate__msg( fu__recv_predicate__msg[9] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[9] ),
    .recv_predicate__val( fu__recv_predicate__val[9] ),
    .send_out__msg( fu__send_out__msg[9] ),
    .send_out__rdy( fu__send_out__rdy[9] ),
    .send_out__val( fu__send_out__val[9] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[9] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[9] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[9] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[9] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[9] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[9] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[9] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[9] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[9] )
  );

  FpMulRTL__ea91a20faab79471 fu__10
  (
    .clk( fu__clk[10] ),
    .reset( fu__reset[10] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[10] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[10] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[10] ),
    .recv_const__msg( fu__recv_const__msg[10] ),
    .recv_const__rdy( fu__recv_const__rdy[10] ),
    .recv_const__val( fu__recv_const__val[10] ),
    .recv_in__msg( fu__recv_in__msg[10] ),
    .recv_in__rdy( fu__recv_in__rdy[10] ),
    .recv_in__val( fu__recv_in__val[10] ),
    .recv_opt__msg( fu__recv_opt__msg[10] ),
    .recv_opt__rdy( fu__recv_opt__rdy[10] ),
    .recv_opt__val( fu__recv_opt__val[10] ),
    .recv_predicate__msg( fu__recv_predicate__msg[10] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[10] ),
    .recv_predicate__val( fu__recv_predicate__val[10] ),
    .send_out__msg( fu__send_out__msg[10] ),
    .send_out__rdy( fu__send_out__rdy[10] ),
    .send_out__val( fu__send_out__val[10] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[10] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[10] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[10] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[10] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[10] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[10] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[10] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[10] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[10] )
  );

  SeqMulAdderRTL__010c52f4aa4155bc fu__11
  (
    .clk( fu__clk[11] ),
    .reset( fu__reset[11] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[11] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[11] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[11] ),
    .recv_const__msg( fu__recv_const__msg[11] ),
    .recv_const__rdy( fu__recv_const__rdy[11] ),
    .recv_const__val( fu__recv_const__val[11] ),
    .recv_in__msg( fu__recv_in__msg[11] ),
    .recv_in__rdy( fu__recv_in__rdy[11] ),
    .recv_in__val( fu__recv_in__val[11] ),
    .recv_opt__msg( fu__recv_opt__msg[11] ),
    .recv_opt__rdy( fu__recv_opt__rdy[11] ),
    .recv_opt__val( fu__recv_opt__val[11] ),
    .recv_predicate__msg( fu__recv_predicate__msg[11] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[11] ),
    .recv_predicate__val( fu__recv_predicate__val[11] ),
    .send_out__msg( fu__send_out__msg[11] ),
    .send_out__rdy( fu__send_out__rdy[11] ),
    .send_out__val( fu__send_out__val[11] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[11] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[11] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[11] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[11] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[11] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[11] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[11] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[11] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[11] )
  );

  VectorMulComboRTL__a499f8f134d9aa6b fu__12
  (
    .clk( fu__clk[12] ),
    .reset( fu__reset[12] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[12] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[12] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[12] ),
    .recv_const__msg( fu__recv_const__msg[12] ),
    .recv_const__rdy( fu__recv_const__rdy[12] ),
    .recv_const__val( fu__recv_const__val[12] ),
    .recv_in__msg( fu__recv_in__msg[12] ),
    .recv_in__rdy( fu__recv_in__rdy[12] ),
    .recv_in__val( fu__recv_in__val[12] ),
    .recv_opt__msg( fu__recv_opt__msg[12] ),
    .recv_opt__rdy( fu__recv_opt__rdy[12] ),
    .recv_opt__val( fu__recv_opt__val[12] ),
    .recv_predicate__msg( fu__recv_predicate__msg[12] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[12] ),
    .recv_predicate__val( fu__recv_predicate__val[12] ),
    .send_out__msg( fu__send_out__msg[12] ),
    .send_out__rdy( fu__send_out__rdy[12] ),
    .send_out__val( fu__send_out__val[12] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[12] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[12] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[12] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[12] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[12] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[12] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[12] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[12] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[12] )
  );

  VectorAdderComboRTL__a499f8f134d9aa6b fu__13
  (
    .clk( fu__clk[13] ),
    .reset( fu__reset[13] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[13] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[13] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[13] ),
    .recv_const__msg( fu__recv_const__msg[13] ),
    .recv_const__rdy( fu__recv_const__rdy[13] ),
    .recv_const__val( fu__recv_const__val[13] ),
    .recv_in__msg( fu__recv_in__msg[13] ),
    .recv_in__rdy( fu__recv_in__rdy[13] ),
    .recv_in__val( fu__recv_in__val[13] ),
    .recv_opt__msg( fu__recv_opt__msg[13] ),
    .recv_opt__rdy( fu__recv_opt__rdy[13] ),
    .recv_opt__val( fu__recv_opt__val[13] ),
    .recv_predicate__msg( fu__recv_predicate__msg[13] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[13] ),
    .recv_predicate__val( fu__recv_predicate__val[13] ),
    .send_out__msg( fu__send_out__msg[13] ),
    .send_out__rdy( fu__send_out__rdy[13] ),
    .send_out__val( fu__send_out__val[13] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[13] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[13] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[13] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[13] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[13] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[13] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[13] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[13] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[13] )
  );

  NahRTL__b48d5d572c75e2e4 fu__14
  (
    .clk( fu__clk[14] ),
    .reset( fu__reset[14] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[14] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[14] ),
    .from_mem_rdata__val( fu__from_mem_rdata__val[14] ),
    .recv_const__msg( fu__recv_const__msg[14] ),
    .recv_const__rdy( fu__recv_const__rdy[14] ),
    .recv_const__val( fu__recv_const__val[14] ),
    .recv_in__msg( fu__recv_in__msg[14] ),
    .recv_in__rdy( fu__recv_in__rdy[14] ),
    .recv_in__val( fu__recv_in__val[14] ),
    .recv_opt__msg( fu__recv_opt__msg[14] ),
    .recv_opt__rdy( fu__recv_opt__rdy[14] ),
    .recv_opt__val( fu__recv_opt__val[14] ),
    .recv_predicate__msg( fu__recv_predicate__msg[14] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[14] ),
    .recv_predicate__val( fu__recv_predicate__val[14] ),
    .send_out__msg( fu__send_out__msg[14] ),
    .send_out__rdy( fu__send_out__rdy[14] ),
    .send_out__val( fu__send_out__val[14] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[14] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[14] ),
    .to_mem_raddr__val( fu__to_mem_raddr__val[14] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[14] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[14] ),
    .to_mem_waddr__val( fu__to_mem_waddr__val[14] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[14] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[14] ),
    .to_mem_wdata__val( fu__to_mem_wdata__val[14] )
  );

  //-------------------------------------------------------------
  // End of component fu[0:14]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/fu/flexible/FlexibleFuRTL.py:68
  // @update
  // def comb_logic():
  // 
  //   for j in range(num_outports):
  //     s.send_out[j].val @= b1(0)
  //     s.send_out[j].msg @= DataType()
  // 
  //   for i in range(s.fu_list_size):
  // 
  //     # const connection
  //     s.fu[i].recv_const.msg @= s.recv_const.msg
  //     s.fu[i].recv_const.val @= s.recv_const.val
  //     s.fu_recv_const_rdy_vector[i] @= s.fu[i].recv_const.rdy
  // 
  //     # opt connection
  //     s.fu[i].recv_opt.msg @= s.recv_opt.msg
  //     s.fu[i].recv_opt.val  @= s.recv_opt.val
  //     s.fu_recv_opt_rdy_vector[i] @= s.fu[i].recv_opt.rdy
  // 
  //     # Note that the predication for a combined FU should be identical/shareable,
  //     # which means the computation in different basic block cannot be combined.
  //     s.fu[i].recv_opt.msg.predicate @= s.recv_opt.msg.predicate
  //     s.fu[i].recv_predicate.val @= s.recv_predicate.val
  //     s.fu_recv_predicate_rdy_vector[i] @= s.fu[i].recv_predicate.rdy
  //     s.fu[i].recv_predicate.msg @= s.recv_predicate.msg
  // 
  //     # send_out connection
  //     for j in range(num_outports):
  //       # FIXME: need reduce_or here: https://github.com/tancheng/VectorCGRA/issues/51.
  //       if s.fu[i].send_out[j].val:
  //         s.send_out[j].msg @= s.fu[i].send_out[j].msg
  //         s.send_out[j].val @= s.fu[i].send_out[j].val
  //       s.fu[i].send_out[j].rdy @= s.send_out[j].rdy
  // 
  //   s.recv_const.rdy @= reduce_or(s.fu_recv_const_rdy_vector)
  //   s.recv_predicate.rdy @= reduce_or(s.fu_recv_predicate_rdy_vector)
  //   # Operation (especially mem access) won't perform more than once, because once the
  //   # operation is performance (i.e., the recv_opt.rdy would be set), the `element_done`
  //   # register would be set and be respected.
  //   s.recv_opt.rdy @= reduce_or(s.fu_recv_opt_rdy_vector) | (s.prologue_count_inport != 0)
  // 
  //   for j in range(num_inports):
  //     s.recv_in[j].rdy @= b1(0)
  // 
  //   # recv_in connection
  //   for port in range(num_inports):
  //     for i in range(s.fu_list_size):
  //       s.fu[i].recv_in[port].msg @= s.recv_in[port].msg
  //       s.fu[i].recv_in[port].val @= s.recv_in[port].val
  //       # s.recv_in[j].rdy       @= s.fu[i].recv_in[j].rdy | s.recv_in[j].rdy
  //       s.fu_recv_in_rdy_vector[port][i] @= s.fu[i].recv_in[port].rdy
  //     s.recv_in[port].rdy @= reduce_or(s.fu_recv_in_rdy_vector[port])
  
  always_comb begin : comb_logic
    for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 ) begin
      send_out__val[1'(j)] = 1'd0;
      send_out__msg[1'(j)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    for ( int unsigned i = 1'd0; i < 4'd15; i += 1'd1 ) begin
      fu__recv_const__msg[4'(i)] = recv_const__msg;
      fu__recv_const__val[4'(i)] = recv_const__val;
      fu_recv_const_rdy_vector[4'(i)] = fu__recv_const__rdy[4'(i)];
      fu__recv_opt__msg[4'(i)] = recv_opt__msg;
      fu__recv_opt__val[4'(i)] = recv_opt__val;
      fu_recv_opt_rdy_vector[4'(i)] = fu__recv_opt__rdy[4'(i)];
      fu__recv_opt__msg[4'(i)].predicate = recv_opt__msg.predicate;
      fu__recv_predicate__val[4'(i)] = recv_predicate__val;
      fu_recv_predicate_rdy_vector[4'(i)] = fu__recv_predicate__rdy[4'(i)];
      fu__recv_predicate__msg[4'(i)] = recv_predicate__msg;
      for ( int unsigned j = 1'd0; j < 2'( __const__num_outports_at_comb_logic ); j += 1'd1 ) begin
        if ( fu__send_out__val[4'(i)][1'(j)] ) begin
          send_out__msg[1'(j)] = fu__send_out__msg[4'(i)][1'(j)];
          send_out__val[1'(j)] = fu__send_out__val[4'(i)][1'(j)];
        end
        fu__send_out__rdy[4'(i)][1'(j)] = send_out__rdy[1'(j)];
      end
    end
    recv_const__rdy = ( | fu_recv_const_rdy_vector );
    recv_predicate__rdy = ( | fu_recv_predicate_rdy_vector );
    recv_opt__rdy = ( | fu_recv_opt_rdy_vector ) | ( prologue_count_inport != 3'd0 );
    for ( int unsigned j = 1'd0; j < 3'( __const__num_inports_at_comb_logic ); j += 1'd1 )
      recv_in__rdy[2'(j)] = 1'd0;
    for ( int unsigned port = 1'd0; port < 3'( __const__num_inports_at_comb_logic ); port += 1'd1 ) begin
      for ( int unsigned i = 1'd0; i < 4'd15; i += 1'd1 ) begin
        fu__recv_in__msg[4'(i)][2'(port)] = recv_in__msg[2'(port)];
        fu__recv_in__val[4'(i)][2'(port)] = recv_in__val[2'(port)];
        fu_recv_in_rdy_vector[2'(port)][4'(i)] = fu__recv_in__rdy[4'(i)][2'(port)];
      end
      recv_in__rdy[2'(port)] = ( | fu_recv_in_rdy_vector[2'(port)] );
    end
  end

  assign fu__clk[0] = clk;
  assign fu__reset[0] = reset;
  assign fu__clk[1] = clk;
  assign fu__reset[1] = reset;
  assign fu__clk[2] = clk;
  assign fu__reset[2] = reset;
  assign fu__clk[3] = clk;
  assign fu__reset[3] = reset;
  assign fu__clk[4] = clk;
  assign fu__reset[4] = reset;
  assign fu__clk[5] = clk;
  assign fu__reset[5] = reset;
  assign fu__clk[6] = clk;
  assign fu__reset[6] = reset;
  assign fu__clk[7] = clk;
  assign fu__reset[7] = reset;
  assign fu__clk[8] = clk;
  assign fu__reset[8] = reset;
  assign fu__clk[9] = clk;
  assign fu__reset[9] = reset;
  assign fu__clk[10] = clk;
  assign fu__reset[10] = reset;
  assign fu__clk[11] = clk;
  assign fu__reset[11] = reset;
  assign fu__clk[12] = clk;
  assign fu__reset[12] = reset;
  assign fu__clk[13] = clk;
  assign fu__reset[13] = reset;
  assign fu__clk[14] = clk;
  assign fu__reset[14] = reset;
  assign to_mem_raddr__msg[0] = fu__to_mem_raddr__msg[0];
  assign fu__to_mem_raddr__rdy[0] = to_mem_raddr__rdy[0];
  assign to_mem_raddr__val[0] = fu__to_mem_raddr__val[0];
  assign fu__from_mem_rdata__msg[0] = from_mem_rdata__msg[0];
  assign from_mem_rdata__rdy[0] = fu__from_mem_rdata__rdy[0];
  assign fu__from_mem_rdata__val[0] = from_mem_rdata__val[0];
  assign to_mem_waddr__msg[0] = fu__to_mem_waddr__msg[0];
  assign fu__to_mem_waddr__rdy[0] = to_mem_waddr__rdy[0];
  assign to_mem_waddr__val[0] = fu__to_mem_waddr__val[0];
  assign to_mem_wdata__msg[0] = fu__to_mem_wdata__msg[0];
  assign fu__to_mem_wdata__rdy[0] = to_mem_wdata__rdy[0];
  assign to_mem_wdata__val[0] = fu__to_mem_wdata__val[0];
  assign to_mem_raddr__msg[1] = fu__to_mem_raddr__msg[1];
  assign fu__to_mem_raddr__rdy[1] = to_mem_raddr__rdy[1];
  assign to_mem_raddr__val[1] = fu__to_mem_raddr__val[1];
  assign fu__from_mem_rdata__msg[1] = from_mem_rdata__msg[1];
  assign from_mem_rdata__rdy[1] = fu__from_mem_rdata__rdy[1];
  assign fu__from_mem_rdata__val[1] = from_mem_rdata__val[1];
  assign to_mem_waddr__msg[1] = fu__to_mem_waddr__msg[1];
  assign fu__to_mem_waddr__rdy[1] = to_mem_waddr__rdy[1];
  assign to_mem_waddr__val[1] = fu__to_mem_waddr__val[1];
  assign to_mem_wdata__msg[1] = fu__to_mem_wdata__msg[1];
  assign fu__to_mem_wdata__rdy[1] = to_mem_wdata__rdy[1];
  assign to_mem_wdata__val[1] = fu__to_mem_wdata__val[1];
  assign to_mem_raddr__msg[2] = fu__to_mem_raddr__msg[2];
  assign fu__to_mem_raddr__rdy[2] = to_mem_raddr__rdy[2];
  assign to_mem_raddr__val[2] = fu__to_mem_raddr__val[2];
  assign fu__from_mem_rdata__msg[2] = from_mem_rdata__msg[2];
  assign from_mem_rdata__rdy[2] = fu__from_mem_rdata__rdy[2];
  assign fu__from_mem_rdata__val[2] = from_mem_rdata__val[2];
  assign to_mem_waddr__msg[2] = fu__to_mem_waddr__msg[2];
  assign fu__to_mem_waddr__rdy[2] = to_mem_waddr__rdy[2];
  assign to_mem_waddr__val[2] = fu__to_mem_waddr__val[2];
  assign to_mem_wdata__msg[2] = fu__to_mem_wdata__msg[2];
  assign fu__to_mem_wdata__rdy[2] = to_mem_wdata__rdy[2];
  assign to_mem_wdata__val[2] = fu__to_mem_wdata__val[2];
  assign to_mem_raddr__msg[3] = fu__to_mem_raddr__msg[3];
  assign fu__to_mem_raddr__rdy[3] = to_mem_raddr__rdy[3];
  assign to_mem_raddr__val[3] = fu__to_mem_raddr__val[3];
  assign fu__from_mem_rdata__msg[3] = from_mem_rdata__msg[3];
  assign from_mem_rdata__rdy[3] = fu__from_mem_rdata__rdy[3];
  assign fu__from_mem_rdata__val[3] = from_mem_rdata__val[3];
  assign to_mem_waddr__msg[3] = fu__to_mem_waddr__msg[3];
  assign fu__to_mem_waddr__rdy[3] = to_mem_waddr__rdy[3];
  assign to_mem_waddr__val[3] = fu__to_mem_waddr__val[3];
  assign to_mem_wdata__msg[3] = fu__to_mem_wdata__msg[3];
  assign fu__to_mem_wdata__rdy[3] = to_mem_wdata__rdy[3];
  assign to_mem_wdata__val[3] = fu__to_mem_wdata__val[3];
  assign to_mem_raddr__msg[4] = fu__to_mem_raddr__msg[4];
  assign fu__to_mem_raddr__rdy[4] = to_mem_raddr__rdy[4];
  assign to_mem_raddr__val[4] = fu__to_mem_raddr__val[4];
  assign fu__from_mem_rdata__msg[4] = from_mem_rdata__msg[4];
  assign from_mem_rdata__rdy[4] = fu__from_mem_rdata__rdy[4];
  assign fu__from_mem_rdata__val[4] = from_mem_rdata__val[4];
  assign to_mem_waddr__msg[4] = fu__to_mem_waddr__msg[4];
  assign fu__to_mem_waddr__rdy[4] = to_mem_waddr__rdy[4];
  assign to_mem_waddr__val[4] = fu__to_mem_waddr__val[4];
  assign to_mem_wdata__msg[4] = fu__to_mem_wdata__msg[4];
  assign fu__to_mem_wdata__rdy[4] = to_mem_wdata__rdy[4];
  assign to_mem_wdata__val[4] = fu__to_mem_wdata__val[4];
  assign to_mem_raddr__msg[5] = fu__to_mem_raddr__msg[5];
  assign fu__to_mem_raddr__rdy[5] = to_mem_raddr__rdy[5];
  assign to_mem_raddr__val[5] = fu__to_mem_raddr__val[5];
  assign fu__from_mem_rdata__msg[5] = from_mem_rdata__msg[5];
  assign from_mem_rdata__rdy[5] = fu__from_mem_rdata__rdy[5];
  assign fu__from_mem_rdata__val[5] = from_mem_rdata__val[5];
  assign to_mem_waddr__msg[5] = fu__to_mem_waddr__msg[5];
  assign fu__to_mem_waddr__rdy[5] = to_mem_waddr__rdy[5];
  assign to_mem_waddr__val[5] = fu__to_mem_waddr__val[5];
  assign to_mem_wdata__msg[5] = fu__to_mem_wdata__msg[5];
  assign fu__to_mem_wdata__rdy[5] = to_mem_wdata__rdy[5];
  assign to_mem_wdata__val[5] = fu__to_mem_wdata__val[5];
  assign to_mem_raddr__msg[6] = fu__to_mem_raddr__msg[6];
  assign fu__to_mem_raddr__rdy[6] = to_mem_raddr__rdy[6];
  assign to_mem_raddr__val[6] = fu__to_mem_raddr__val[6];
  assign fu__from_mem_rdata__msg[6] = from_mem_rdata__msg[6];
  assign from_mem_rdata__rdy[6] = fu__from_mem_rdata__rdy[6];
  assign fu__from_mem_rdata__val[6] = from_mem_rdata__val[6];
  assign to_mem_waddr__msg[6] = fu__to_mem_waddr__msg[6];
  assign fu__to_mem_waddr__rdy[6] = to_mem_waddr__rdy[6];
  assign to_mem_waddr__val[6] = fu__to_mem_waddr__val[6];
  assign to_mem_wdata__msg[6] = fu__to_mem_wdata__msg[6];
  assign fu__to_mem_wdata__rdy[6] = to_mem_wdata__rdy[6];
  assign to_mem_wdata__val[6] = fu__to_mem_wdata__val[6];
  assign to_mem_raddr__msg[7] = fu__to_mem_raddr__msg[7];
  assign fu__to_mem_raddr__rdy[7] = to_mem_raddr__rdy[7];
  assign to_mem_raddr__val[7] = fu__to_mem_raddr__val[7];
  assign fu__from_mem_rdata__msg[7] = from_mem_rdata__msg[7];
  assign from_mem_rdata__rdy[7] = fu__from_mem_rdata__rdy[7];
  assign fu__from_mem_rdata__val[7] = from_mem_rdata__val[7];
  assign to_mem_waddr__msg[7] = fu__to_mem_waddr__msg[7];
  assign fu__to_mem_waddr__rdy[7] = to_mem_waddr__rdy[7];
  assign to_mem_waddr__val[7] = fu__to_mem_waddr__val[7];
  assign to_mem_wdata__msg[7] = fu__to_mem_wdata__msg[7];
  assign fu__to_mem_wdata__rdy[7] = to_mem_wdata__rdy[7];
  assign to_mem_wdata__val[7] = fu__to_mem_wdata__val[7];
  assign to_mem_raddr__msg[8] = fu__to_mem_raddr__msg[8];
  assign fu__to_mem_raddr__rdy[8] = to_mem_raddr__rdy[8];
  assign to_mem_raddr__val[8] = fu__to_mem_raddr__val[8];
  assign fu__from_mem_rdata__msg[8] = from_mem_rdata__msg[8];
  assign from_mem_rdata__rdy[8] = fu__from_mem_rdata__rdy[8];
  assign fu__from_mem_rdata__val[8] = from_mem_rdata__val[8];
  assign to_mem_waddr__msg[8] = fu__to_mem_waddr__msg[8];
  assign fu__to_mem_waddr__rdy[8] = to_mem_waddr__rdy[8];
  assign to_mem_waddr__val[8] = fu__to_mem_waddr__val[8];
  assign to_mem_wdata__msg[8] = fu__to_mem_wdata__msg[8];
  assign fu__to_mem_wdata__rdy[8] = to_mem_wdata__rdy[8];
  assign to_mem_wdata__val[8] = fu__to_mem_wdata__val[8];
  assign to_mem_raddr__msg[9] = fu__to_mem_raddr__msg[9];
  assign fu__to_mem_raddr__rdy[9] = to_mem_raddr__rdy[9];
  assign to_mem_raddr__val[9] = fu__to_mem_raddr__val[9];
  assign fu__from_mem_rdata__msg[9] = from_mem_rdata__msg[9];
  assign from_mem_rdata__rdy[9] = fu__from_mem_rdata__rdy[9];
  assign fu__from_mem_rdata__val[9] = from_mem_rdata__val[9];
  assign to_mem_waddr__msg[9] = fu__to_mem_waddr__msg[9];
  assign fu__to_mem_waddr__rdy[9] = to_mem_waddr__rdy[9];
  assign to_mem_waddr__val[9] = fu__to_mem_waddr__val[9];
  assign to_mem_wdata__msg[9] = fu__to_mem_wdata__msg[9];
  assign fu__to_mem_wdata__rdy[9] = to_mem_wdata__rdy[9];
  assign to_mem_wdata__val[9] = fu__to_mem_wdata__val[9];
  assign to_mem_raddr__msg[10] = fu__to_mem_raddr__msg[10];
  assign fu__to_mem_raddr__rdy[10] = to_mem_raddr__rdy[10];
  assign to_mem_raddr__val[10] = fu__to_mem_raddr__val[10];
  assign fu__from_mem_rdata__msg[10] = from_mem_rdata__msg[10];
  assign from_mem_rdata__rdy[10] = fu__from_mem_rdata__rdy[10];
  assign fu__from_mem_rdata__val[10] = from_mem_rdata__val[10];
  assign to_mem_waddr__msg[10] = fu__to_mem_waddr__msg[10];
  assign fu__to_mem_waddr__rdy[10] = to_mem_waddr__rdy[10];
  assign to_mem_waddr__val[10] = fu__to_mem_waddr__val[10];
  assign to_mem_wdata__msg[10] = fu__to_mem_wdata__msg[10];
  assign fu__to_mem_wdata__rdy[10] = to_mem_wdata__rdy[10];
  assign to_mem_wdata__val[10] = fu__to_mem_wdata__val[10];
  assign to_mem_raddr__msg[11] = fu__to_mem_raddr__msg[11];
  assign fu__to_mem_raddr__rdy[11] = to_mem_raddr__rdy[11];
  assign to_mem_raddr__val[11] = fu__to_mem_raddr__val[11];
  assign fu__from_mem_rdata__msg[11] = from_mem_rdata__msg[11];
  assign from_mem_rdata__rdy[11] = fu__from_mem_rdata__rdy[11];
  assign fu__from_mem_rdata__val[11] = from_mem_rdata__val[11];
  assign to_mem_waddr__msg[11] = fu__to_mem_waddr__msg[11];
  assign fu__to_mem_waddr__rdy[11] = to_mem_waddr__rdy[11];
  assign to_mem_waddr__val[11] = fu__to_mem_waddr__val[11];
  assign to_mem_wdata__msg[11] = fu__to_mem_wdata__msg[11];
  assign fu__to_mem_wdata__rdy[11] = to_mem_wdata__rdy[11];
  assign to_mem_wdata__val[11] = fu__to_mem_wdata__val[11];
  assign to_mem_raddr__msg[12] = fu__to_mem_raddr__msg[12];
  assign fu__to_mem_raddr__rdy[12] = to_mem_raddr__rdy[12];
  assign to_mem_raddr__val[12] = fu__to_mem_raddr__val[12];
  assign fu__from_mem_rdata__msg[12] = from_mem_rdata__msg[12];
  assign from_mem_rdata__rdy[12] = fu__from_mem_rdata__rdy[12];
  assign fu__from_mem_rdata__val[12] = from_mem_rdata__val[12];
  assign to_mem_waddr__msg[12] = fu__to_mem_waddr__msg[12];
  assign fu__to_mem_waddr__rdy[12] = to_mem_waddr__rdy[12];
  assign to_mem_waddr__val[12] = fu__to_mem_waddr__val[12];
  assign to_mem_wdata__msg[12] = fu__to_mem_wdata__msg[12];
  assign fu__to_mem_wdata__rdy[12] = to_mem_wdata__rdy[12];
  assign to_mem_wdata__val[12] = fu__to_mem_wdata__val[12];
  assign to_mem_raddr__msg[13] = fu__to_mem_raddr__msg[13];
  assign fu__to_mem_raddr__rdy[13] = to_mem_raddr__rdy[13];
  assign to_mem_raddr__val[13] = fu__to_mem_raddr__val[13];
  assign fu__from_mem_rdata__msg[13] = from_mem_rdata__msg[13];
  assign from_mem_rdata__rdy[13] = fu__from_mem_rdata__rdy[13];
  assign fu__from_mem_rdata__val[13] = from_mem_rdata__val[13];
  assign to_mem_waddr__msg[13] = fu__to_mem_waddr__msg[13];
  assign fu__to_mem_waddr__rdy[13] = to_mem_waddr__rdy[13];
  assign to_mem_waddr__val[13] = fu__to_mem_waddr__val[13];
  assign to_mem_wdata__msg[13] = fu__to_mem_wdata__msg[13];
  assign fu__to_mem_wdata__rdy[13] = to_mem_wdata__rdy[13];
  assign to_mem_wdata__val[13] = fu__to_mem_wdata__val[13];
  assign to_mem_raddr__msg[14] = fu__to_mem_raddr__msg[14];
  assign fu__to_mem_raddr__rdy[14] = to_mem_raddr__rdy[14];
  assign to_mem_raddr__val[14] = fu__to_mem_raddr__val[14];
  assign fu__from_mem_rdata__msg[14] = from_mem_rdata__msg[14];
  assign from_mem_rdata__rdy[14] = fu__from_mem_rdata__rdy[14];
  assign fu__from_mem_rdata__val[14] = from_mem_rdata__val[14];
  assign to_mem_waddr__msg[14] = fu__to_mem_waddr__msg[14];
  assign fu__to_mem_waddr__rdy[14] = to_mem_waddr__rdy[14];
  assign to_mem_waddr__val[14] = fu__to_mem_waddr__val[14];
  assign to_mem_wdata__msg[14] = fu__to_mem_wdata__msg[14];
  assign fu__to_mem_wdata__rdy[14] = to_mem_wdata__rdy[14];
  assign to_mem_wdata__val[14] = fu__to_mem_wdata__val[14];

endmodule


// PyMTL Component CrossbarRTL Definition
// Full name: CrossbarRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__PredicateType_CGRAData_1_1__payload_1__predicate_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__num_inports_2__num_outports_8__num_tiles_4
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/CrossbarRTL.py

module CrossbarRTL__51a4a9c5505a1f59
(
  input  logic [0:0] clk ,
  input  logic [0:0] compute_done ,
  input  logic [0:0] crossbar_id ,
  input  logic [1:0] crossbar_outport [0:7],
  input  logic [2:0] prologue_count_inport [0:1],
  input  logic [0:0] reset ,
  input  logic [2:0] tile_id ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_data__msg [0:1] ,
  output logic [0:0] recv_data__rdy [0:1] ,
  input logic [0:0] recv_data__val [0:1] ,
  input CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_data__msg [0:7] ,
  input logic [0:0] send_data__rdy [0:7] ,
  output logic [0:0] send_data__val [0:7] ,
  output CGRAData_1_1__payload_1__predicate_1 send_predicate__msg  ,
  input logic [0:0] send_predicate__rdy  ,
  output logic [0:0] send_predicate__val  
);
  localparam logic [1:0] __const__num_inports_at_update_signal  = 2'd2;
  localparam logic [3:0] __const__num_outports_at_update_signal  = 4'd8;
  localparam logic [5:0] __const__OPT_START  = 6'd0;
  localparam logic [1:0] __const__num_inports_at_update_prologue_counter  = 2'd2;
  localparam logic [3:0] __const__num_outports_at_update_prologue_counter  = 4'd8;
  localparam logic [3:0] __const__num_outports_at_update_prologue_allowing_vector  = 4'd8;
  localparam logic [3:0] __const__num_outports_at_update_prologue_or_valid_vector  = 4'd8;
  localparam logic [3:0] __const__num_outports_at_update_in_dir_vector  = 4'd8;
  localparam logic [3:0] __const__num_outports_at_update_rdy_vector  = 4'd8;
  localparam logic [1:0] __const__num_inports_at_update_rdy_vector  = 2'd2;
  localparam logic [3:0] __const__num_outports_at_update_valid_vector  = 4'd8;
  localparam logic [1:0] __const__num_inports_at_update_recv_required_vector  = 2'd2;
  localparam logic [3:0] __const__num_outports_at_update_recv_required_vector  = 4'd8;
  localparam logic [3:0] __const__num_outports_at_update_send_required_vector  = 4'd8;
  logic [1:0] in_dir [0:7];
  logic [0:0] in_dir_local [0:7];
  logic [7:0] prologue_allowing_vector;
  logic [2:0] prologue_count_wire [0:1];
  logic [2:0] prologue_counter [0:1];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_data_msg [0:1];
  logic [0:0] recv_data_val [0:1];
  logic [1:0] recv_predicate_vector;
  logic [1:0] recv_required_vector;
  logic [7:0] recv_valid_or_prologue_allowing_vector;
  logic [7:0] recv_valid_vector;
  logic [7:0] send_rdy_vector;
  logic [7:0] send_required_vector;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/CrossbarRTL.py:144
  // @update
  // def update_in_dir_vector():
  // 
  //   for i in range(num_outports):
  //     s.in_dir[i] @= 0
  //     s.in_dir_local[i] @= 0
  // 
  //   for i in range(num_outports):
  //     s.in_dir[i] @= s.crossbar_outport[i]
  //     if s.in_dir[i] > 0:
  //       s.in_dir_local[i] @= trunc(s.in_dir[i] - 1, NumInportType)
  
  always_comb begin : update_in_dir_vector
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_in_dir_vector ); i += 1'd1 ) begin
      in_dir[3'(i)] = 2'd0;
      in_dir_local[3'(i)] = 1'd0;
    end
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_in_dir_vector ); i += 1'd1 ) begin
      in_dir[3'(i)] = crossbar_outport[3'(i)];
      if ( in_dir[3'(i)] > 2'd0 ) begin
        in_dir_local[3'(i)] = 1'(in_dir[3'(i)] - 2'd1);
      end
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/CrossbarRTL.py:125
  // @update
  // def update_prologue_allowing_vector():
  //   s.prologue_allowing_vector @= 0
  //   for i in range(num_outports):
  //     if s.in_dir[i] > 0:
  //       # Records whether the prologue steps have already been satisfied.
  //       s.prologue_allowing_vector[i] @= \
  //         (s.prologue_counter[s.in_dir_local[i]] < \
  //          s.prologue_count_wire[s.in_dir_local[i]])
  //     else:
  //       s.prologue_allowing_vector[i] @= 1
  
  always_comb begin : update_prologue_allowing_vector
    prologue_allowing_vector = 8'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_prologue_allowing_vector ); i += 1'd1 )
      if ( in_dir[3'(i)] > 2'd0 ) begin
        prologue_allowing_vector[3'(i)] = prologue_counter[in_dir_local[3'(i)]] < prologue_count_wire[in_dir_local[3'(i)]];
      end
      else
        prologue_allowing_vector[3'(i)] = 1'd1;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/CrossbarRTL.py:137
  // @update
  // def update_prologue_or_valid_vector():
  //   s.recv_valid_or_prologue_allowing_vector @= 0
  //   for i in range(num_outports):
  //     s.recv_valid_or_prologue_allowing_vector[i] @= \
  //         s.recv_valid_vector[i] | s.prologue_allowing_vector[i]
  
  always_comb begin : update_prologue_or_valid_vector
    recv_valid_or_prologue_allowing_vector = 8'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_prologue_or_valid_vector ); i += 1'd1 )
      recv_valid_or_prologue_allowing_vector[3'(i)] = recv_valid_vector[3'(i)] | prologue_allowing_vector[3'(i)];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/CrossbarRTL.py:156
  // @update
  // def update_rdy_vector():
  //   s.send_rdy_vector @= 0
  //   for i in range(num_outports):
  //     # The `num_inports` indicates the number of outports that go to other tiles.
  //     # Specifically, if the compute already done, we shouldn't care the ones
  //     # (i.e., i >= num_inports) go to the FU's inports. In other words, we skip
  //     # the rdy checking on the FU's inports (connecting from crossbar_outport) if
  //     # the compute is already completed.
  //     if (s.in_dir[i] > 0) & (~s.compute_done | (i < num_inports)):
  //       s.send_rdy_vector[i] @= s.send_data[i].rdy
  //     else:
  //       s.send_rdy_vector[i] @= 1
  
  always_comb begin : update_rdy_vector
    send_rdy_vector = 8'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_rdy_vector ); i += 1'd1 )
      if ( ( in_dir[3'(i)] > 2'd0 ) & ( ( ~compute_done ) | ( 3'(i) < 3'( __const__num_inports_at_update_rdy_vector ) ) ) ) begin
        send_rdy_vector[3'(i)] = send_data__rdy[3'(i)];
      end
      else
        send_rdy_vector[3'(i)] = 1'd1;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/CrossbarRTL.py:179
  // @update
  // def update_recv_required_vector():
  //   for i in range(num_inports):
  //     s.recv_required_vector[i] @= 0
  // 
  //   for i in range(num_outports):
  //     if s.in_dir[i] > 0:
  //       s.recv_required_vector[s.in_dir_local[i]] @= 1
  
  always_comb begin : update_recv_required_vector
    for ( int unsigned i = 1'd0; i < 2'( __const__num_inports_at_update_recv_required_vector ); i += 1'd1 )
      recv_required_vector[1'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_recv_required_vector ); i += 1'd1 )
      if ( in_dir[3'(i)] > 2'd0 ) begin
        recv_required_vector[in_dir_local[3'(i)]] = 1'd1;
      end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/CrossbarRTL.py:188
  // @update
  // def update_send_required_vector():
  // 
  //   for i in range(num_outports):
  //     s.send_required_vector[i] @= 0
  // 
  //   for i in range(num_outports):
  //     if s.in_dir[i] > 0:
  //       s.send_required_vector[i] @= 1
  
  always_comb begin : update_send_required_vector
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_send_required_vector ); i += 1'd1 )
      send_required_vector[3'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_send_required_vector ); i += 1'd1 )
      if ( in_dir[3'(i)] > 2'd0 ) begin
        send_required_vector[3'(i)] = 1'd1;
      end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/CrossbarRTL.py:68
  // @update
  // def update_signal():
  //   s.recv_predicate_vector @= 0
  //   s.send_predicate.val @= 0
  //   s.send_predicate.msg @= PredicateType()
  //   for i in range(num_inports):
  //     s.recv_data[i].rdy @= 0
  //   for i in range(num_outports):
  //     s.send_data[i].val @= 0
  //     s.send_data[i].msg @= DataType()
  //   s.recv_opt.rdy @= 0
  // 
  //   # For predication register update. 'predicate' and 'predicate_in' no need
  //   # to be active at the same time. Specifically, the 'predicate' is for
  //   # the operation at the current cycle while the 'predicate_in' accumulates
  //   # the predicate and pushes into the predicate register that will be used
  //   # in the future.
  //   if s.recv_opt.msg.predicate:
  //     s.send_predicate.msg @= PredicateType(b1(0), b1(0))
  // 
  //   if s.recv_opt.val & (s.recv_opt.msg.operation != OPT_START):
  //     for i in range(num_inports):
  //       # Set predicate once the recv_data is stable (i.e., en == true).
  //       # FIXME: Let's re-think the predicate support in next PR.
  //       if s.recv_opt.msg.routing_predicate_in[i]:
  //         s.send_predicate.val @= b1(1)
  //         s.send_predicate.msg.payload @= b1(1)
  //         s.recv_predicate_vector[i] @= s.recv_data[i].msg.predicate
  // 
  //     for i in range(num_inports):
  //       s.recv_data[i].rdy @= reduce_and(s.recv_valid_vector) & \
  //                             reduce_and(s.send_rdy_vector) & \
  //                             s.recv_required_vector[i]
  // 
  //     for i in range(num_outports):
  //       s.send_data[i].val @= reduce_and(s.recv_valid_vector) & \
  //                             s.send_required_vector[i]
  //       if reduce_and(s.recv_valid_vector) & \
  //          s.send_required_vector[i]:
  //         s.send_data[i].msg.payload @= s.recv_data_msg[s.in_dir_local[i]].payload
  //         s.send_data[i].msg.predicate @= s.recv_data_msg[s.in_dir_local[i]].predicate
  // 
  //     s.send_predicate.msg.predicate @= reduce_or(s.recv_predicate_vector)
  //     s.recv_opt.rdy @= reduce_and(s.send_rdy_vector) & \
  //                       reduce_and(s.recv_valid_or_prologue_allowing_vector)
  
  always_comb begin : update_signal
    recv_predicate_vector = 2'd0;
    send_predicate__val = 1'd0;
    send_predicate__msg = { 1'd0, 1'd0 };
    for ( int unsigned i = 1'd0; i < 2'( __const__num_inports_at_update_signal ); i += 1'd1 )
      recv_data__rdy[1'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_signal ); i += 1'd1 ) begin
      send_data__val[3'(i)] = 1'd0;
      send_data__msg[3'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_opt__rdy = 1'd0;
    if ( recv_opt__msg.predicate ) begin
      send_predicate__msg = { 1'd0, 1'd0 };
    end
    if ( recv_opt__val & ( recv_opt__msg.operation != 6'( __const__OPT_START ) ) ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__num_inports_at_update_signal ); i += 1'd1 )
        if ( recv_opt__msg.routing_predicate_in[2'(i)] ) begin
          send_predicate__val = 1'd1;
          send_predicate__msg.payload = 1'd1;
          recv_predicate_vector[1'(i)] = recv_data__msg[1'(i)].predicate;
        end
      for ( int unsigned i = 1'd0; i < 2'( __const__num_inports_at_update_signal ); i += 1'd1 )
        recv_data__rdy[1'(i)] = ( ( & recv_valid_vector ) & ( & send_rdy_vector ) ) & recv_required_vector[1'(i)];
      for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_signal ); i += 1'd1 ) begin
        send_data__val[3'(i)] = ( & recv_valid_vector ) & send_required_vector[3'(i)];
        if ( ( & recv_valid_vector ) & send_required_vector[3'(i)] ) begin
          send_data__msg[3'(i)].payload = recv_data_msg[in_dir_local[3'(i)]].payload;
          send_data__msg[3'(i)].predicate = recv_data_msg[in_dir_local[3'(i)]].predicate;
        end
      end
      send_predicate__msg.predicate = ( | recv_predicate_vector );
      recv_opt__rdy = ( & send_rdy_vector ) & ( & recv_valid_or_prologue_allowing_vector );
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/CrossbarRTL.py:170
  // @update
  // def update_valid_vector():
  //   s.recv_valid_vector @= 0
  //   for i in range(num_outports):
  //     if s.in_dir[i] > 0:
  //       s.recv_valid_vector[i] @= s.recv_data_val[s.in_dir_local[i]]
  //     else:
  //       s.recv_valid_vector[i] @= 1
  
  always_comb begin : update_valid_vector
    recv_valid_vector = 8'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_valid_vector ); i += 1'd1 )
      if ( in_dir[3'(i)] > 2'd0 ) begin
        recv_valid_vector[3'(i)] = recv_data_val[in_dir_local[3'(i)]];
      end
      else
        recv_valid_vector[3'(i)] = 1'd1;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/CrossbarRTL.py:114
  // @update_ff
  // def update_prologue_counter():
  //   if s.reset:
  //     for i in range(num_inports):
  //       s.prologue_counter[i] <<= 0
  //   elif s.recv_opt.rdy:
  //     for i in range(num_outports):
  //       if (s.in_dir[i] > 0) & \
  //          (s.prologue_counter[s.in_dir_local[i]] < s.prologue_count_wire[s.in_dir_local[i]]):
  //         s.prologue_counter[s.in_dir_local[i]] <<= s.prologue_counter[s.in_dir_local[i]] + 1
  
  always_ff @(posedge clk) begin : update_prologue_counter
    if ( reset ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__num_inports_at_update_prologue_counter ); i += 1'd1 )
        prologue_counter[1'(i)] <= 3'd0;
    end
    else if ( recv_opt__rdy ) begin
      for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_prologue_counter ); i += 1'd1 )
        if ( ( in_dir[3'(i)] > 2'd0 ) & ( prologue_counter[in_dir_local[3'(i)]] < prologue_count_wire[in_dir_local[3'(i)]] ) ) begin
          prologue_counter[in_dir_local[3'(i)]] <= prologue_counter[in_dir_local[3'(i)]] + 3'd1;
        end
    end
  end

  assign recv_data_msg[0] = recv_data__msg[0];
  assign recv_data_val[0] = recv_data__val[0];
  assign recv_data_msg[1] = recv_data__msg[1];
  assign recv_data_val[1] = recv_data__val[1];
  assign prologue_count_wire[0] = prologue_count_inport[0];
  assign prologue_count_wire[1] = prologue_count_inport[1];

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_CGRAData_1_1__payload_1__predicate_1__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py

module RegisterFile__351680845b4f9dfa
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output CGRAData_1_1__payload_1__predicate_1 rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  CGRAData_1_1__payload_1__predicate_1 wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  CGRAData_1_1__payload_1__predicate_1 regs [0:1];

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueueDpathRTL Definition
// Full name: NormalQueueDpathRTL__EntryType_CGRAData_1_1__payload_1__predicate_1__num_entries_2
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueDpathRTL__d3f62ca56ef20036
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr ,
  input  CGRAData_1_1__payload_1__predicate_1 recv_msg ,
  input  logic [0:0] reset ,
  output CGRAData_1_1__payload_1__predicate_1 send_msg ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component rf
  //-------------------------------------------------------------

  logic [0:0] rf__clk;
  logic [0:0] rf__raddr [0:0];
  CGRAData_1_1__payload_1__predicate_1 rf__rdata [0:0];
  logic [0:0] rf__reset;
  logic [0:0] rf__waddr [0:0];
  CGRAData_1_1__payload_1__predicate_1 rf__wdata [0:0];
  logic [0:0] rf__wen [0:0];

  RegisterFile__351680845b4f9dfa rf
  (
    .clk( rf__clk ),
    .raddr( rf__raddr ),
    .rdata( rf__rdata ),
    .reset( rf__reset ),
    .waddr( rf__waddr ),
    .wdata( rf__wdata ),
    .wen( rf__wen )
  );

  //-------------------------------------------------------------
  // End of component rf
  //-------------------------------------------------------------

  assign rf__clk = clk;
  assign rf__reset = reset;
  assign rf__raddr[0] = raddr;
  assign send_msg = rf__rdata[0];
  assign rf__wen[0] = wen;
  assign rf__waddr[0] = waddr;
  assign rf__wdata[0] = recv_msg;

endmodule


// PyMTL Component NormalQueueRTL Definition
// Full name: NormalQueueRTL__EntryType_CGRAData_1_1__payload_1__predicate_1__num_entries_2
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueRTL__d3f62ca56ef20036
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input CGRAData_1_1__payload_1__predicate_1 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output CGRAData_1_1__payload_1__predicate_1 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__recv_rdy;
  logic [0:0] ctrl__recv_val;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__send_rdy;
  logic [0:0] ctrl__send_val;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .raddr( ctrl__raddr ),
    .recv_rdy( ctrl__recv_rdy ),
    .recv_val( ctrl__recv_val ),
    .reset( ctrl__reset ),
    .send_rdy( ctrl__send_rdy ),
    .send_val( ctrl__send_val ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  logic [0:0] dpath__raddr;
  CGRAData_1_1__payload_1__predicate_1 dpath__recv_msg;
  logic [0:0] dpath__reset;
  CGRAData_1_1__payload_1__predicate_1 dpath__send_msg;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueueDpathRTL__d3f62ca56ef20036 dpath
  (
    .clk( dpath__clk ),
    .raddr( dpath__raddr ),
    .recv_msg( dpath__recv_msg ),
    .reset( dpath__reset ),
    .send_msg( dpath__send_msg ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__recv_val = recv__val;
  assign recv__rdy = ctrl__recv_rdy;
  assign dpath__recv_msg = recv__msg;
  assign send__val = ctrl__send_val;
  assign ctrl__send_rdy = send__rdy;
  assign send__msg = dpath__send_msg;
  assign count = ctrl__count;

endmodule


// PyMTL Component RegisterRTL Definition
// Full name: RegisterRTL__DataType_CGRAData_1_1__payload_1__predicate_1__latency_1
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/rf/RegisterRTL.py

module RegisterRTL__e306da7100516ae4
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input CGRAData_1_1__payload_1__predicate_1 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output CGRAData_1_1__payload_1__predicate_1 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component queues[0:0]
  //-------------------------------------------------------------

  logic [0:0] queues__clk [0:0];
  logic [1:0] queues__count [0:0];
  logic [0:0] queues__reset [0:0];
  CGRAData_1_1__payload_1__predicate_1 queues__recv__msg [0:0];
  logic [0:0] queues__recv__rdy [0:0];
  logic [0:0] queues__recv__val [0:0];
  CGRAData_1_1__payload_1__predicate_1 queues__send__msg [0:0];
  logic [0:0] queues__send__rdy [0:0];
  logic [0:0] queues__send__val [0:0];

  NormalQueueRTL__d3f62ca56ef20036 queues__0
  (
    .clk( queues__clk[0] ),
    .count( queues__count[0] ),
    .reset( queues__reset[0] ),
    .recv__msg( queues__recv__msg[0] ),
    .recv__rdy( queues__recv__rdy[0] ),
    .recv__val( queues__recv__val[0] ),
    .send__msg( queues__send__msg[0] ),
    .send__rdy( queues__send__rdy[0] ),
    .send__val( queues__send__val[0] )
  );

  //-------------------------------------------------------------
  // End of component queues[0:0]
  //-------------------------------------------------------------

  assign queues__clk[0] = clk;
  assign queues__reset[0] = reset;
  assign queues__recv__msg[0] = recv__msg;
  assign recv__rdy = queues__recv__rdy[0];
  assign queues__recv__val[0] = recv__val;
  assign send__msg = queues__send__msg[0];
  assign queues__send__rdy[0] = send__rdy;
  assign send__val = queues__send__val[0];

endmodule


// PyMTL Component RegisterBankRTL Definition
// Full name: RegisterBankRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__reg_bank_id_0__num_registers_16
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/register_cluster/RegisterBankRTL.py

module RegisterBankRTL__d262f1a30f98eca9
(
  input  logic [0:0] clk ,
  input  CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf inport_opt ,
  input  logic [0:0] inport_valid [0:2],
  input  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 inport_wdata [0:2],
  input  logic [0:0] reset ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_data_to_fu__msg  ,
  input logic [0:0] send_data_to_fu__rdy  ,
  output logic [0:0] send_data_to_fu__val  
);
  localparam logic [0:0] __const__reg_bank_id_at_access_registers  = 1'd0;
  localparam logic [0:0] __const__reg_bank_id_at_update_send_val  = 1'd0;
  //-------------------------------------------------------------
  // Component reg_file
  //-------------------------------------------------------------

  logic [0:0] reg_file__clk;
  logic [3:0] reg_file__raddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__rdata [0:0];
  logic [0:0] reg_file__reset;
  logic [3:0] reg_file__waddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__wdata [0:0];
  logic [0:0] reg_file__wen [0:0];

  RegisterFile__84f0703fd9bfd535 reg_file
  (
    .clk( reg_file__clk ),
    .raddr( reg_file__raddr ),
    .rdata( reg_file__rdata ),
    .reset( reg_file__reset ),
    .waddr( reg_file__waddr ),
    .wdata( reg_file__wdata ),
    .wen( reg_file__wen )
  );

  //-------------------------------------------------------------
  // End of component reg_file
  //-------------------------------------------------------------
  logic [1:0] __tmpvar__access_registers_write_reg_from;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/register_cluster/RegisterBankRTL.py:41
  // @update
  // def access_registers():
  //   # Initializes signals.
  //   s.reg_file.raddr[0] @= AddrType()
  //   s.send_data_to_fu.msg @= DataType()
  //   s.reg_file.waddr[0] @= AddrType()
  //   s.reg_file.wdata[0] @= DataType()
  //   s.reg_file.wen[0] @= 0
  // 
  //   if s.inport_opt.read_reg_from[reg_bank_id]:
  //     s.reg_file.raddr[0] @= s.inport_opt.read_reg_idx[reg_bank_id]
  //     s.send_data_to_fu.msg @= s.reg_file.rdata[0]
  // 
  //   write_reg_from = s.inport_opt.write_reg_from[reg_bank_id]
  //   if ~s.reset & (write_reg_from > 0):
  //     if s.inport_valid[write_reg_from - 1]:
  //       s.reg_file.waddr[0] @= s.inport_opt.write_reg_idx[reg_bank_id]
  //       s.reg_file.wdata[0] @= s.inport_wdata[write_reg_from - 1]
  //       s.reg_file.wen[0] @= 1
  
  always_comb begin : access_registers
    reg_file__raddr[1'd0] = 4'd0;
    send_data_to_fu__msg = { 32'd0, 1'd0, 1'd0, 1'd0 };
    reg_file__waddr[1'd0] = 4'd0;
    reg_file__wdata[1'd0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    reg_file__wen[1'd0] = 1'd0;
    if ( inport_opt.read_reg_from[2'( __const__reg_bank_id_at_access_registers )] ) begin
      reg_file__raddr[1'd0] = inport_opt.read_reg_idx[2'( __const__reg_bank_id_at_access_registers )];
      send_data_to_fu__msg = reg_file__rdata[1'd0];
    end
    __tmpvar__access_registers_write_reg_from = inport_opt.write_reg_from[2'( __const__reg_bank_id_at_access_registers )];
    if ( ( ~reset ) & ( __tmpvar__access_registers_write_reg_from > 2'd0 ) ) begin
      if ( inport_valid[__tmpvar__access_registers_write_reg_from - 2'd1] ) begin
        reg_file__waddr[1'd0] = inport_opt.write_reg_idx[2'( __const__reg_bank_id_at_access_registers )];
        reg_file__wdata[1'd0] = inport_wdata[__tmpvar__access_registers_write_reg_from - 2'd1];
        reg_file__wen[1'd0] = 1'd1;
      end
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/register_cluster/RegisterBankRTL.py:61
  // @update
  // def update_send_val():
  //   s.send_data_to_fu.val @= 0
  //   if ~s.reset & s.inport_opt.read_reg_from[reg_bank_id]:
  //     s.send_data_to_fu.val @= 1
  
  always_comb begin : update_send_val
    send_data_to_fu__val = 1'd0;
    if ( ( ~reset ) & inport_opt.read_reg_from[2'( __const__reg_bank_id_at_update_send_val )] ) begin
      send_data_to_fu__val = 1'd1;
    end
  end

  assign reg_file__clk = clk;
  assign reg_file__reset = reset;

endmodule


// PyMTL Component RegisterBankRTL Definition
// Full name: RegisterBankRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__reg_bank_id_1__num_registers_16
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/register_cluster/RegisterBankRTL.py

module RegisterBankRTL__6d50ebe3bc9ca807
(
  input  logic [0:0] clk ,
  input  CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf inport_opt ,
  input  logic [0:0] inport_valid [0:2],
  input  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 inport_wdata [0:2],
  input  logic [0:0] reset ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_data_to_fu__msg  ,
  input logic [0:0] send_data_to_fu__rdy  ,
  output logic [0:0] send_data_to_fu__val  
);
  localparam logic [0:0] __const__reg_bank_id_at_access_registers  = 1'd1;
  localparam logic [0:0] __const__reg_bank_id_at_update_send_val  = 1'd1;
  //-------------------------------------------------------------
  // Component reg_file
  //-------------------------------------------------------------

  logic [0:0] reg_file__clk;
  logic [3:0] reg_file__raddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__rdata [0:0];
  logic [0:0] reg_file__reset;
  logic [3:0] reg_file__waddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__wdata [0:0];
  logic [0:0] reg_file__wen [0:0];

  RegisterFile__84f0703fd9bfd535 reg_file
  (
    .clk( reg_file__clk ),
    .raddr( reg_file__raddr ),
    .rdata( reg_file__rdata ),
    .reset( reg_file__reset ),
    .waddr( reg_file__waddr ),
    .wdata( reg_file__wdata ),
    .wen( reg_file__wen )
  );

  //-------------------------------------------------------------
  // End of component reg_file
  //-------------------------------------------------------------
  logic [1:0] __tmpvar__access_registers_write_reg_from;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/register_cluster/RegisterBankRTL.py:41
  // @update
  // def access_registers():
  //   # Initializes signals.
  //   s.reg_file.raddr[0] @= AddrType()
  //   s.send_data_to_fu.msg @= DataType()
  //   s.reg_file.waddr[0] @= AddrType()
  //   s.reg_file.wdata[0] @= DataType()
  //   s.reg_file.wen[0] @= 0
  // 
  //   if s.inport_opt.read_reg_from[reg_bank_id]:
  //     s.reg_file.raddr[0] @= s.inport_opt.read_reg_idx[reg_bank_id]
  //     s.send_data_to_fu.msg @= s.reg_file.rdata[0]
  // 
  //   write_reg_from = s.inport_opt.write_reg_from[reg_bank_id]
  //   if ~s.reset & (write_reg_from > 0):
  //     if s.inport_valid[write_reg_from - 1]:
  //       s.reg_file.waddr[0] @= s.inport_opt.write_reg_idx[reg_bank_id]
  //       s.reg_file.wdata[0] @= s.inport_wdata[write_reg_from - 1]
  //       s.reg_file.wen[0] @= 1
  
  always_comb begin : access_registers
    reg_file__raddr[1'd0] = 4'd0;
    send_data_to_fu__msg = { 32'd0, 1'd0, 1'd0, 1'd0 };
    reg_file__waddr[1'd0] = 4'd0;
    reg_file__wdata[1'd0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    reg_file__wen[1'd0] = 1'd0;
    if ( inport_opt.read_reg_from[2'( __const__reg_bank_id_at_access_registers )] ) begin
      reg_file__raddr[1'd0] = inport_opt.read_reg_idx[2'( __const__reg_bank_id_at_access_registers )];
      send_data_to_fu__msg = reg_file__rdata[1'd0];
    end
    __tmpvar__access_registers_write_reg_from = inport_opt.write_reg_from[2'( __const__reg_bank_id_at_access_registers )];
    if ( ( ~reset ) & ( __tmpvar__access_registers_write_reg_from > 2'd0 ) ) begin
      if ( inport_valid[__tmpvar__access_registers_write_reg_from - 2'd1] ) begin
        reg_file__waddr[1'd0] = inport_opt.write_reg_idx[2'( __const__reg_bank_id_at_access_registers )];
        reg_file__wdata[1'd0] = inport_wdata[__tmpvar__access_registers_write_reg_from - 2'd1];
        reg_file__wen[1'd0] = 1'd1;
      end
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/register_cluster/RegisterBankRTL.py:61
  // @update
  // def update_send_val():
  //   s.send_data_to_fu.val @= 0
  //   if ~s.reset & s.inport_opt.read_reg_from[reg_bank_id]:
  //     s.send_data_to_fu.val @= 1
  
  always_comb begin : update_send_val
    send_data_to_fu__val = 1'd0;
    if ( ( ~reset ) & inport_opt.read_reg_from[2'( __const__reg_bank_id_at_update_send_val )] ) begin
      send_data_to_fu__val = 1'd1;
    end
  end

  assign reg_file__clk = clk;
  assign reg_file__reset = reset;

endmodule


// PyMTL Component RegisterBankRTL Definition
// Full name: RegisterBankRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__reg_bank_id_2__num_registers_16
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/register_cluster/RegisterBankRTL.py

module RegisterBankRTL__b33f1b7623d60923
(
  input  logic [0:0] clk ,
  input  CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf inport_opt ,
  input  logic [0:0] inport_valid [0:2],
  input  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 inport_wdata [0:2],
  input  logic [0:0] reset ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_data_to_fu__msg  ,
  input logic [0:0] send_data_to_fu__rdy  ,
  output logic [0:0] send_data_to_fu__val  
);
  localparam logic [1:0] __const__reg_bank_id_at_access_registers  = 2'd2;
  localparam logic [1:0] __const__reg_bank_id_at_update_send_val  = 2'd2;
  //-------------------------------------------------------------
  // Component reg_file
  //-------------------------------------------------------------

  logic [0:0] reg_file__clk;
  logic [3:0] reg_file__raddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__rdata [0:0];
  logic [0:0] reg_file__reset;
  logic [3:0] reg_file__waddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__wdata [0:0];
  logic [0:0] reg_file__wen [0:0];

  RegisterFile__84f0703fd9bfd535 reg_file
  (
    .clk( reg_file__clk ),
    .raddr( reg_file__raddr ),
    .rdata( reg_file__rdata ),
    .reset( reg_file__reset ),
    .waddr( reg_file__waddr ),
    .wdata( reg_file__wdata ),
    .wen( reg_file__wen )
  );

  //-------------------------------------------------------------
  // End of component reg_file
  //-------------------------------------------------------------
  logic [1:0] __tmpvar__access_registers_write_reg_from;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/register_cluster/RegisterBankRTL.py:41
  // @update
  // def access_registers():
  //   # Initializes signals.
  //   s.reg_file.raddr[0] @= AddrType()
  //   s.send_data_to_fu.msg @= DataType()
  //   s.reg_file.waddr[0] @= AddrType()
  //   s.reg_file.wdata[0] @= DataType()
  //   s.reg_file.wen[0] @= 0
  // 
  //   if s.inport_opt.read_reg_from[reg_bank_id]:
  //     s.reg_file.raddr[0] @= s.inport_opt.read_reg_idx[reg_bank_id]
  //     s.send_data_to_fu.msg @= s.reg_file.rdata[0]
  // 
  //   write_reg_from = s.inport_opt.write_reg_from[reg_bank_id]
  //   if ~s.reset & (write_reg_from > 0):
  //     if s.inport_valid[write_reg_from - 1]:
  //       s.reg_file.waddr[0] @= s.inport_opt.write_reg_idx[reg_bank_id]
  //       s.reg_file.wdata[0] @= s.inport_wdata[write_reg_from - 1]
  //       s.reg_file.wen[0] @= 1
  
  always_comb begin : access_registers
    reg_file__raddr[1'd0] = 4'd0;
    send_data_to_fu__msg = { 32'd0, 1'd0, 1'd0, 1'd0 };
    reg_file__waddr[1'd0] = 4'd0;
    reg_file__wdata[1'd0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    reg_file__wen[1'd0] = 1'd0;
    if ( inport_opt.read_reg_from[2'( __const__reg_bank_id_at_access_registers )] ) begin
      reg_file__raddr[1'd0] = inport_opt.read_reg_idx[2'( __const__reg_bank_id_at_access_registers )];
      send_data_to_fu__msg = reg_file__rdata[1'd0];
    end
    __tmpvar__access_registers_write_reg_from = inport_opt.write_reg_from[2'( __const__reg_bank_id_at_access_registers )];
    if ( ( ~reset ) & ( __tmpvar__access_registers_write_reg_from > 2'd0 ) ) begin
      if ( inport_valid[__tmpvar__access_registers_write_reg_from - 2'd1] ) begin
        reg_file__waddr[1'd0] = inport_opt.write_reg_idx[2'( __const__reg_bank_id_at_access_registers )];
        reg_file__wdata[1'd0] = inport_wdata[__tmpvar__access_registers_write_reg_from - 2'd1];
        reg_file__wen[1'd0] = 1'd1;
      end
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/register_cluster/RegisterBankRTL.py:61
  // @update
  // def update_send_val():
  //   s.send_data_to_fu.val @= 0
  //   if ~s.reset & s.inport_opt.read_reg_from[reg_bank_id]:
  //     s.send_data_to_fu.val @= 1
  
  always_comb begin : update_send_val
    send_data_to_fu__val = 1'd0;
    if ( ( ~reset ) & inport_opt.read_reg_from[2'( __const__reg_bank_id_at_update_send_val )] ) begin
      send_data_to_fu__val = 1'd1;
    end
  end

  assign reg_file__clk = clk;
  assign reg_file__reset = reset;

endmodule


// PyMTL Component RegisterBankRTL Definition
// Full name: RegisterBankRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__reg_bank_id_3__num_registers_16
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/register_cluster/RegisterBankRTL.py

module RegisterBankRTL__5e3db135d3eb26bd
(
  input  logic [0:0] clk ,
  input  CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf inport_opt ,
  input  logic [0:0] inport_valid [0:2],
  input  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 inport_wdata [0:2],
  input  logic [0:0] reset ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_data_to_fu__msg  ,
  input logic [0:0] send_data_to_fu__rdy  ,
  output logic [0:0] send_data_to_fu__val  
);
  localparam logic [1:0] __const__reg_bank_id_at_access_registers  = 2'd3;
  localparam logic [1:0] __const__reg_bank_id_at_update_send_val  = 2'd3;
  //-------------------------------------------------------------
  // Component reg_file
  //-------------------------------------------------------------

  logic [0:0] reg_file__clk;
  logic [3:0] reg_file__raddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__rdata [0:0];
  logic [0:0] reg_file__reset;
  logic [3:0] reg_file__waddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_file__wdata [0:0];
  logic [0:0] reg_file__wen [0:0];

  RegisterFile__84f0703fd9bfd535 reg_file
  (
    .clk( reg_file__clk ),
    .raddr( reg_file__raddr ),
    .rdata( reg_file__rdata ),
    .reset( reg_file__reset ),
    .waddr( reg_file__waddr ),
    .wdata( reg_file__wdata ),
    .wen( reg_file__wen )
  );

  //-------------------------------------------------------------
  // End of component reg_file
  //-------------------------------------------------------------
  logic [1:0] __tmpvar__access_registers_write_reg_from;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/register_cluster/RegisterBankRTL.py:41
  // @update
  // def access_registers():
  //   # Initializes signals.
  //   s.reg_file.raddr[0] @= AddrType()
  //   s.send_data_to_fu.msg @= DataType()
  //   s.reg_file.waddr[0] @= AddrType()
  //   s.reg_file.wdata[0] @= DataType()
  //   s.reg_file.wen[0] @= 0
  // 
  //   if s.inport_opt.read_reg_from[reg_bank_id]:
  //     s.reg_file.raddr[0] @= s.inport_opt.read_reg_idx[reg_bank_id]
  //     s.send_data_to_fu.msg @= s.reg_file.rdata[0]
  // 
  //   write_reg_from = s.inport_opt.write_reg_from[reg_bank_id]
  //   if ~s.reset & (write_reg_from > 0):
  //     if s.inport_valid[write_reg_from - 1]:
  //       s.reg_file.waddr[0] @= s.inport_opt.write_reg_idx[reg_bank_id]
  //       s.reg_file.wdata[0] @= s.inport_wdata[write_reg_from - 1]
  //       s.reg_file.wen[0] @= 1
  
  always_comb begin : access_registers
    reg_file__raddr[1'd0] = 4'd0;
    send_data_to_fu__msg = { 32'd0, 1'd0, 1'd0, 1'd0 };
    reg_file__waddr[1'd0] = 4'd0;
    reg_file__wdata[1'd0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    reg_file__wen[1'd0] = 1'd0;
    if ( inport_opt.read_reg_from[2'( __const__reg_bank_id_at_access_registers )] ) begin
      reg_file__raddr[1'd0] = inport_opt.read_reg_idx[2'( __const__reg_bank_id_at_access_registers )];
      send_data_to_fu__msg = reg_file__rdata[1'd0];
    end
    __tmpvar__access_registers_write_reg_from = inport_opt.write_reg_from[2'( __const__reg_bank_id_at_access_registers )];
    if ( ( ~reset ) & ( __tmpvar__access_registers_write_reg_from > 2'd0 ) ) begin
      if ( inport_valid[__tmpvar__access_registers_write_reg_from - 2'd1] ) begin
        reg_file__waddr[1'd0] = inport_opt.write_reg_idx[2'( __const__reg_bank_id_at_access_registers )];
        reg_file__wdata[1'd0] = inport_wdata[__tmpvar__access_registers_write_reg_from - 2'd1];
        reg_file__wen[1'd0] = 1'd1;
      end
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/register_cluster/RegisterBankRTL.py:61
  // @update
  // def update_send_val():
  //   s.send_data_to_fu.val @= 0
  //   if ~s.reset & s.inport_opt.read_reg_from[reg_bank_id]:
  //     s.send_data_to_fu.val @= 1
  
  always_comb begin : update_send_val
    send_data_to_fu__val = 1'd0;
    if ( ( ~reset ) & inport_opt.read_reg_from[2'( __const__reg_bank_id_at_update_send_val )] ) begin
      send_data_to_fu__val = 1'd1;
    end
  end

  assign reg_file__clk = clk;
  assign reg_file__reset = reset;

endmodule


// PyMTL Component RegisterClusterRTL Definition
// Full name: RegisterClusterRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__num_reg_banks_4__num_registers_per_reg_bank_16
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/register_cluster/RegisterClusterRTL.py

module RegisterClusterRTL__c0c508814bde6822
(
  input  logic [0:0] clk ,
  input  CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf inport_opt ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_data_from_const__msg [0:3] ,
  output logic [0:0] recv_data_from_const__rdy [0:3] ,
  input logic [0:0] recv_data_from_const__val [0:3] ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_data_from_fu_crossbar__msg [0:3] ,
  output logic [0:0] recv_data_from_fu_crossbar__rdy [0:3] ,
  input logic [0:0] recv_data_from_fu_crossbar__val [0:3] ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_data_from_routing_crossbar__msg [0:3] ,
  output logic [0:0] recv_data_from_routing_crossbar__rdy [0:3] ,
  input logic [0:0] recv_data_from_routing_crossbar__val [0:3] ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_data_to_fu__msg [0:3] ,
  input logic [0:0] send_data_to_fu__rdy [0:3] ,
  output logic [0:0] send_data_to_fu__val [0:3] 
);
  localparam logic [2:0] __const__num_reg_banks_at_update_msgs_signals  = 3'd4;
  //-------------------------------------------------------------
  // Component reg_bank[0:3]
  //-------------------------------------------------------------

  logic [0:0] reg_bank__clk [0:3];
  CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf reg_bank__inport_opt [0:3];
  logic [0:0] reg_bank__inport_valid [0:3][0:2];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_bank__inport_wdata [0:3][0:2];
  logic [0:0] reg_bank__reset [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 reg_bank__send_data_to_fu__msg [0:3];
  logic [0:0] reg_bank__send_data_to_fu__rdy [0:3];
  logic [0:0] reg_bank__send_data_to_fu__val [0:3];

  RegisterBankRTL__d262f1a30f98eca9 reg_bank__0
  (
    .clk( reg_bank__clk[0] ),
    .inport_opt( reg_bank__inport_opt[0] ),
    .inport_valid( reg_bank__inport_valid[0] ),
    .inport_wdata( reg_bank__inport_wdata[0] ),
    .reset( reg_bank__reset[0] ),
    .send_data_to_fu__msg( reg_bank__send_data_to_fu__msg[0] ),
    .send_data_to_fu__rdy( reg_bank__send_data_to_fu__rdy[0] ),
    .send_data_to_fu__val( reg_bank__send_data_to_fu__val[0] )
  );

  RegisterBankRTL__6d50ebe3bc9ca807 reg_bank__1
  (
    .clk( reg_bank__clk[1] ),
    .inport_opt( reg_bank__inport_opt[1] ),
    .inport_valid( reg_bank__inport_valid[1] ),
    .inport_wdata( reg_bank__inport_wdata[1] ),
    .reset( reg_bank__reset[1] ),
    .send_data_to_fu__msg( reg_bank__send_data_to_fu__msg[1] ),
    .send_data_to_fu__rdy( reg_bank__send_data_to_fu__rdy[1] ),
    .send_data_to_fu__val( reg_bank__send_data_to_fu__val[1] )
  );

  RegisterBankRTL__b33f1b7623d60923 reg_bank__2
  (
    .clk( reg_bank__clk[2] ),
    .inport_opt( reg_bank__inport_opt[2] ),
    .inport_valid( reg_bank__inport_valid[2] ),
    .inport_wdata( reg_bank__inport_wdata[2] ),
    .reset( reg_bank__reset[2] ),
    .send_data_to_fu__msg( reg_bank__send_data_to_fu__msg[2] ),
    .send_data_to_fu__rdy( reg_bank__send_data_to_fu__rdy[2] ),
    .send_data_to_fu__val( reg_bank__send_data_to_fu__val[2] )
  );

  RegisterBankRTL__5e3db135d3eb26bd reg_bank__3
  (
    .clk( reg_bank__clk[3] ),
    .inport_opt( reg_bank__inport_opt[3] ),
    .inport_valid( reg_bank__inport_valid[3] ),
    .inport_wdata( reg_bank__inport_wdata[3] ),
    .reset( reg_bank__reset[3] ),
    .send_data_to_fu__msg( reg_bank__send_data_to_fu__msg[3] ),
    .send_data_to_fu__rdy( reg_bank__send_data_to_fu__rdy[3] ),
    .send_data_to_fu__val( reg_bank__send_data_to_fu__val[3] )
  );

  //-------------------------------------------------------------
  // End of component reg_bank[0:3]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/mem/register_cluster/RegisterClusterRTL.py:45
  // @update
  // def update_msgs_signals():
  //   # Initializes signals.
  //   for i in range(num_reg_banks):
  //     s.send_data_to_fu[i].msg @= DataType()
  //     s.recv_data_from_routing_crossbar[i].rdy @= 0
  //     s.recv_data_from_fu_crossbar[i].rdy @= 0
  //     s.recv_data_from_const[i].rdy @= 0
  //     s.send_data_to_fu[i].val @= 0
  // 
  //   for i in range(num_reg_banks):
  //     if s.recv_data_from_routing_crossbar[i].val:
  //       s.send_data_to_fu[i].msg @= \
  //         s.recv_data_from_routing_crossbar[i].msg
  //     else:
  //       s.send_data_to_fu[i].msg @= \
  //         s.reg_bank[i].send_data_to_fu.msg
  // 
  //     s.send_data_to_fu[i].val @= \
  //         s.recv_data_from_routing_crossbar[i].val | \
  //         s.reg_bank[i].send_data_to_fu.val
  //     s.reg_bank[i].send_data_to_fu.rdy @= s.send_data_to_fu[i].rdy
  // 
  //     s.recv_data_from_routing_crossbar[i].rdy @= s.send_data_to_fu[i].rdy
  //     s.recv_data_from_fu_crossbar[i].rdy @= 1
  //     s.recv_data_from_const[i].rdy @= 1
  
  always_comb begin : update_msgs_signals
    for ( int unsigned i = 1'd0; i < 3'( __const__num_reg_banks_at_update_msgs_signals ); i += 1'd1 ) begin
      send_data_to_fu__msg[2'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
      recv_data_from_routing_crossbar__rdy[2'(i)] = 1'd0;
      recv_data_from_fu_crossbar__rdy[2'(i)] = 1'd0;
      recv_data_from_const__rdy[2'(i)] = 1'd0;
      send_data_to_fu__val[2'(i)] = 1'd0;
    end
    for ( int unsigned i = 1'd0; i < 3'( __const__num_reg_banks_at_update_msgs_signals ); i += 1'd1 ) begin
      if ( recv_data_from_routing_crossbar__val[2'(i)] ) begin
        send_data_to_fu__msg[2'(i)] = recv_data_from_routing_crossbar__msg[2'(i)];
      end
      else
        send_data_to_fu__msg[2'(i)] = reg_bank__send_data_to_fu__msg[2'(i)];
      send_data_to_fu__val[2'(i)] = recv_data_from_routing_crossbar__val[2'(i)] | reg_bank__send_data_to_fu__val[2'(i)];
      reg_bank__send_data_to_fu__rdy[2'(i)] = send_data_to_fu__rdy[2'(i)];
      recv_data_from_routing_crossbar__rdy[2'(i)] = send_data_to_fu__rdy[2'(i)];
      recv_data_from_fu_crossbar__rdy[2'(i)] = 1'd1;
      recv_data_from_const__rdy[2'(i)] = 1'd1;
    end
  end

  assign reg_bank__clk[0] = clk;
  assign reg_bank__reset[0] = reset;
  assign reg_bank__clk[1] = clk;
  assign reg_bank__reset[1] = reset;
  assign reg_bank__clk[2] = clk;
  assign reg_bank__reset[2] = reset;
  assign reg_bank__clk[3] = clk;
  assign reg_bank__reset[3] = reset;
  assign reg_bank__inport_opt[0] = inport_opt;
  assign reg_bank__inport_wdata[0][0] = recv_data_from_routing_crossbar__msg[0];
  assign reg_bank__inport_wdata[0][1] = recv_data_from_fu_crossbar__msg[0];
  assign reg_bank__inport_wdata[0][2] = recv_data_from_const__msg[0];
  assign reg_bank__inport_valid[0][0] = recv_data_from_routing_crossbar__val[0];
  assign reg_bank__inport_valid[0][1] = recv_data_from_fu_crossbar__val[0];
  assign reg_bank__inport_valid[0][2] = recv_data_from_const__val[0];
  assign reg_bank__inport_opt[1] = inport_opt;
  assign reg_bank__inport_wdata[1][0] = recv_data_from_routing_crossbar__msg[1];
  assign reg_bank__inport_wdata[1][1] = recv_data_from_fu_crossbar__msg[1];
  assign reg_bank__inport_wdata[1][2] = recv_data_from_const__msg[1];
  assign reg_bank__inport_valid[1][0] = recv_data_from_routing_crossbar__val[1];
  assign reg_bank__inport_valid[1][1] = recv_data_from_fu_crossbar__val[1];
  assign reg_bank__inport_valid[1][2] = recv_data_from_const__val[1];
  assign reg_bank__inport_opt[2] = inport_opt;
  assign reg_bank__inport_wdata[2][0] = recv_data_from_routing_crossbar__msg[2];
  assign reg_bank__inport_wdata[2][1] = recv_data_from_fu_crossbar__msg[2];
  assign reg_bank__inport_wdata[2][2] = recv_data_from_const__msg[2];
  assign reg_bank__inport_valid[2][0] = recv_data_from_routing_crossbar__val[2];
  assign reg_bank__inport_valid[2][1] = recv_data_from_fu_crossbar__val[2];
  assign reg_bank__inport_valid[2][2] = recv_data_from_const__val[2];
  assign reg_bank__inport_opt[3] = inport_opt;
  assign reg_bank__inport_wdata[3][0] = recv_data_from_routing_crossbar__msg[3];
  assign reg_bank__inport_wdata[3][1] = recv_data_from_fu_crossbar__msg[3];
  assign reg_bank__inport_wdata[3][2] = recv_data_from_const__msg[3];
  assign reg_bank__inport_valid[3][0] = recv_data_from_routing_crossbar__val[3];
  assign reg_bank__inport_valid[3][1] = recv_data_from_fu_crossbar__val[3];
  assign reg_bank__inport_valid[3][2] = recv_data_from_const__val[3];

endmodule


// PyMTL Component CrossbarRTL Definition
// Full name: CrossbarRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__PredicateType_CGRAData_1_1__payload_1__predicate_1__CtrlType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__num_inports_4__num_outports_8__num_tiles_4
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/CrossbarRTL.py

module CrossbarRTL__5490bda7b6002819
(
  input  logic [0:0] clk ,
  input  logic [0:0] compute_done ,
  input  logic [0:0] crossbar_id ,
  input  logic [2:0] crossbar_outport [0:7],
  input  logic [2:0] prologue_count_inport [0:3],
  input  logic [0:0] reset ,
  input  logic [2:0] tile_id ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_data__msg [0:3] ,
  output logic [0:0] recv_data__rdy [0:3] ,
  input logic [0:0] recv_data__val [0:3] ,
  input CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf recv_opt__msg  ,
  output logic [0:0] recv_opt__rdy  ,
  input logic [0:0] recv_opt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_data__msg [0:7] ,
  input logic [0:0] send_data__rdy [0:7] ,
  output logic [0:0] send_data__val [0:7] ,
  output CGRAData_1_1__payload_1__predicate_1 send_predicate__msg  ,
  input logic [0:0] send_predicate__rdy  ,
  output logic [0:0] send_predicate__val  
);
  localparam logic [2:0] __const__num_inports_at_update_signal  = 3'd4;
  localparam logic [3:0] __const__num_outports_at_update_signal  = 4'd8;
  localparam logic [5:0] __const__OPT_START  = 6'd0;
  localparam logic [2:0] __const__num_inports_at_update_prologue_counter  = 3'd4;
  localparam logic [3:0] __const__num_outports_at_update_prologue_counter  = 4'd8;
  localparam logic [3:0] __const__num_outports_at_update_prologue_allowing_vector  = 4'd8;
  localparam logic [3:0] __const__num_outports_at_update_prologue_or_valid_vector  = 4'd8;
  localparam logic [3:0] __const__num_outports_at_update_in_dir_vector  = 4'd8;
  localparam logic [3:0] __const__num_outports_at_update_rdy_vector  = 4'd8;
  localparam logic [2:0] __const__num_inports_at_update_rdy_vector  = 3'd4;
  localparam logic [3:0] __const__num_outports_at_update_valid_vector  = 4'd8;
  localparam logic [2:0] __const__num_inports_at_update_recv_required_vector  = 3'd4;
  localparam logic [3:0] __const__num_outports_at_update_recv_required_vector  = 4'd8;
  localparam logic [3:0] __const__num_outports_at_update_send_required_vector  = 4'd8;
  logic [2:0] in_dir [0:7];
  logic [1:0] in_dir_local [0:7];
  logic [7:0] prologue_allowing_vector;
  logic [2:0] prologue_count_wire [0:3];
  logic [2:0] prologue_counter [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_data_msg [0:3];
  logic [0:0] recv_data_val [0:3];
  logic [3:0] recv_predicate_vector;
  logic [3:0] recv_required_vector;
  logic [7:0] recv_valid_or_prologue_allowing_vector;
  logic [7:0] recv_valid_vector;
  logic [7:0] send_rdy_vector;
  logic [7:0] send_required_vector;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/CrossbarRTL.py:144
  // @update
  // def update_in_dir_vector():
  // 
  //   for i in range(num_outports):
  //     s.in_dir[i] @= 0
  //     s.in_dir_local[i] @= 0
  // 
  //   for i in range(num_outports):
  //     s.in_dir[i] @= s.crossbar_outport[i]
  //     if s.in_dir[i] > 0:
  //       s.in_dir_local[i] @= trunc(s.in_dir[i] - 1, NumInportType)
  
  always_comb begin : update_in_dir_vector
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_in_dir_vector ); i += 1'd1 ) begin
      in_dir[3'(i)] = 3'd0;
      in_dir_local[3'(i)] = 2'd0;
    end
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_in_dir_vector ); i += 1'd1 ) begin
      in_dir[3'(i)] = crossbar_outport[3'(i)];
      if ( in_dir[3'(i)] > 3'd0 ) begin
        in_dir_local[3'(i)] = 2'(in_dir[3'(i)] - 3'd1);
      end
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/CrossbarRTL.py:125
  // @update
  // def update_prologue_allowing_vector():
  //   s.prologue_allowing_vector @= 0
  //   for i in range(num_outports):
  //     if s.in_dir[i] > 0:
  //       # Records whether the prologue steps have already been satisfied.
  //       s.prologue_allowing_vector[i] @= \
  //         (s.prologue_counter[s.in_dir_local[i]] < \
  //          s.prologue_count_wire[s.in_dir_local[i]])
  //     else:
  //       s.prologue_allowing_vector[i] @= 1
  
  always_comb begin : update_prologue_allowing_vector
    prologue_allowing_vector = 8'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_prologue_allowing_vector ); i += 1'd1 )
      if ( in_dir[3'(i)] > 3'd0 ) begin
        prologue_allowing_vector[3'(i)] = prologue_counter[in_dir_local[3'(i)]] < prologue_count_wire[in_dir_local[3'(i)]];
      end
      else
        prologue_allowing_vector[3'(i)] = 1'd1;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/CrossbarRTL.py:137
  // @update
  // def update_prologue_or_valid_vector():
  //   s.recv_valid_or_prologue_allowing_vector @= 0
  //   for i in range(num_outports):
  //     s.recv_valid_or_prologue_allowing_vector[i] @= \
  //         s.recv_valid_vector[i] | s.prologue_allowing_vector[i]
  
  always_comb begin : update_prologue_or_valid_vector
    recv_valid_or_prologue_allowing_vector = 8'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_prologue_or_valid_vector ); i += 1'd1 )
      recv_valid_or_prologue_allowing_vector[3'(i)] = recv_valid_vector[3'(i)] | prologue_allowing_vector[3'(i)];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/CrossbarRTL.py:156
  // @update
  // def update_rdy_vector():
  //   s.send_rdy_vector @= 0
  //   for i in range(num_outports):
  //     # The `num_inports` indicates the number of outports that go to other tiles.
  //     # Specifically, if the compute already done, we shouldn't care the ones
  //     # (i.e., i >= num_inports) go to the FU's inports. In other words, we skip
  //     # the rdy checking on the FU's inports (connecting from crossbar_outport) if
  //     # the compute is already completed.
  //     if (s.in_dir[i] > 0) & (~s.compute_done | (i < num_inports)):
  //       s.send_rdy_vector[i] @= s.send_data[i].rdy
  //     else:
  //       s.send_rdy_vector[i] @= 1
  
  always_comb begin : update_rdy_vector
    send_rdy_vector = 8'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_rdy_vector ); i += 1'd1 )
      if ( ( in_dir[3'(i)] > 3'd0 ) & ( ( ~compute_done ) | ( 3'(i) < 3'( __const__num_inports_at_update_rdy_vector ) ) ) ) begin
        send_rdy_vector[3'(i)] = send_data__rdy[3'(i)];
      end
      else
        send_rdy_vector[3'(i)] = 1'd1;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/CrossbarRTL.py:179
  // @update
  // def update_recv_required_vector():
  //   for i in range(num_inports):
  //     s.recv_required_vector[i] @= 0
  // 
  //   for i in range(num_outports):
  //     if s.in_dir[i] > 0:
  //       s.recv_required_vector[s.in_dir_local[i]] @= 1
  
  always_comb begin : update_recv_required_vector
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_update_recv_required_vector ); i += 1'd1 )
      recv_required_vector[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_recv_required_vector ); i += 1'd1 )
      if ( in_dir[3'(i)] > 3'd0 ) begin
        recv_required_vector[in_dir_local[3'(i)]] = 1'd1;
      end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/CrossbarRTL.py:188
  // @update
  // def update_send_required_vector():
  // 
  //   for i in range(num_outports):
  //     s.send_required_vector[i] @= 0
  // 
  //   for i in range(num_outports):
  //     if s.in_dir[i] > 0:
  //       s.send_required_vector[i] @= 1
  
  always_comb begin : update_send_required_vector
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_send_required_vector ); i += 1'd1 )
      send_required_vector[3'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_send_required_vector ); i += 1'd1 )
      if ( in_dir[3'(i)] > 3'd0 ) begin
        send_required_vector[3'(i)] = 1'd1;
      end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/CrossbarRTL.py:68
  // @update
  // def update_signal():
  //   s.recv_predicate_vector @= 0
  //   s.send_predicate.val @= 0
  //   s.send_predicate.msg @= PredicateType()
  //   for i in range(num_inports):
  //     s.recv_data[i].rdy @= 0
  //   for i in range(num_outports):
  //     s.send_data[i].val @= 0
  //     s.send_data[i].msg @= DataType()
  //   s.recv_opt.rdy @= 0
  // 
  //   # For predication register update. 'predicate' and 'predicate_in' no need
  //   # to be active at the same time. Specifically, the 'predicate' is for
  //   # the operation at the current cycle while the 'predicate_in' accumulates
  //   # the predicate and pushes into the predicate register that will be used
  //   # in the future.
  //   if s.recv_opt.msg.predicate:
  //     s.send_predicate.msg @= PredicateType(b1(0), b1(0))
  // 
  //   if s.recv_opt.val & (s.recv_opt.msg.operation != OPT_START):
  //     for i in range(num_inports):
  //       # Set predicate once the recv_data is stable (i.e., en == true).
  //       # FIXME: Let's re-think the predicate support in next PR.
  //       if s.recv_opt.msg.routing_predicate_in[i]:
  //         s.send_predicate.val @= b1(1)
  //         s.send_predicate.msg.payload @= b1(1)
  //         s.recv_predicate_vector[i] @= s.recv_data[i].msg.predicate
  // 
  //     for i in range(num_inports):
  //       s.recv_data[i].rdy @= reduce_and(s.recv_valid_vector) & \
  //                             reduce_and(s.send_rdy_vector) & \
  //                             s.recv_required_vector[i]
  // 
  //     for i in range(num_outports):
  //       s.send_data[i].val @= reduce_and(s.recv_valid_vector) & \
  //                             s.send_required_vector[i]
  //       if reduce_and(s.recv_valid_vector) & \
  //          s.send_required_vector[i]:
  //         s.send_data[i].msg.payload @= s.recv_data_msg[s.in_dir_local[i]].payload
  //         s.send_data[i].msg.predicate @= s.recv_data_msg[s.in_dir_local[i]].predicate
  // 
  //     s.send_predicate.msg.predicate @= reduce_or(s.recv_predicate_vector)
  //     s.recv_opt.rdy @= reduce_and(s.send_rdy_vector) & \
  //                       reduce_and(s.recv_valid_or_prologue_allowing_vector)
  
  always_comb begin : update_signal
    recv_predicate_vector = 4'd0;
    send_predicate__val = 1'd0;
    send_predicate__msg = { 1'd0, 1'd0 };
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_update_signal ); i += 1'd1 )
      recv_data__rdy[2'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_signal ); i += 1'd1 ) begin
      send_data__val[3'(i)] = 1'd0;
      send_data__msg[3'(i)] = { 32'd0, 1'd0, 1'd0, 1'd0 };
    end
    recv_opt__rdy = 1'd0;
    if ( recv_opt__msg.predicate ) begin
      send_predicate__msg = { 1'd0, 1'd0 };
    end
    if ( recv_opt__val & ( recv_opt__msg.operation != 6'( __const__OPT_START ) ) ) begin
      for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_update_signal ); i += 1'd1 )
        if ( recv_opt__msg.routing_predicate_in[2'(i)] ) begin
          send_predicate__val = 1'd1;
          send_predicate__msg.payload = 1'd1;
          recv_predicate_vector[2'(i)] = recv_data__msg[2'(i)].predicate;
        end
      for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_update_signal ); i += 1'd1 )
        recv_data__rdy[2'(i)] = ( ( & recv_valid_vector ) & ( & send_rdy_vector ) ) & recv_required_vector[2'(i)];
      for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_signal ); i += 1'd1 ) begin
        send_data__val[3'(i)] = ( & recv_valid_vector ) & send_required_vector[3'(i)];
        if ( ( & recv_valid_vector ) & send_required_vector[3'(i)] ) begin
          send_data__msg[3'(i)].payload = recv_data_msg[in_dir_local[3'(i)]].payload;
          send_data__msg[3'(i)].predicate = recv_data_msg[in_dir_local[3'(i)]].predicate;
        end
      end
      send_predicate__msg.predicate = ( | recv_predicate_vector );
      recv_opt__rdy = ( & send_rdy_vector ) & ( & recv_valid_or_prologue_allowing_vector );
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/CrossbarRTL.py:170
  // @update
  // def update_valid_vector():
  //   s.recv_valid_vector @= 0
  //   for i in range(num_outports):
  //     if s.in_dir[i] > 0:
  //       s.recv_valid_vector[i] @= s.recv_data_val[s.in_dir_local[i]]
  //     else:
  //       s.recv_valid_vector[i] @= 1
  
  always_comb begin : update_valid_vector
    recv_valid_vector = 8'd0;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_valid_vector ); i += 1'd1 )
      if ( in_dir[3'(i)] > 3'd0 ) begin
        recv_valid_vector[3'(i)] = recv_data_val[in_dir_local[3'(i)]];
      end
      else
        recv_valid_vector[3'(i)] = 1'd1;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/CrossbarRTL.py:114
  // @update_ff
  // def update_prologue_counter():
  //   if s.reset:
  //     for i in range(num_inports):
  //       s.prologue_counter[i] <<= 0
  //   elif s.recv_opt.rdy:
  //     for i in range(num_outports):
  //       if (s.in_dir[i] > 0) & \
  //          (s.prologue_counter[s.in_dir_local[i]] < s.prologue_count_wire[s.in_dir_local[i]]):
  //         s.prologue_counter[s.in_dir_local[i]] <<= s.prologue_counter[s.in_dir_local[i]] + 1
  
  always_ff @(posedge clk) begin : update_prologue_counter
    if ( reset ) begin
      for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_update_prologue_counter ); i += 1'd1 )
        prologue_counter[2'(i)] <= 3'd0;
    end
    else if ( recv_opt__rdy ) begin
      for ( int unsigned i = 1'd0; i < 4'( __const__num_outports_at_update_prologue_counter ); i += 1'd1 )
        if ( ( in_dir[3'(i)] > 3'd0 ) & ( prologue_counter[in_dir_local[3'(i)]] < prologue_count_wire[in_dir_local[3'(i)]] ) ) begin
          prologue_counter[in_dir_local[3'(i)]] <= prologue_counter[in_dir_local[3'(i)]] + 3'd1;
        end
    end
  end

  assign recv_data_msg[0] = recv_data__msg[0];
  assign recv_data_val[0] = recv_data__val[0];
  assign recv_data_msg[1] = recv_data__msg[1];
  assign recv_data_val[1] = recv_data__val[1];
  assign recv_data_msg[2] = recv_data__msg[2];
  assign recv_data_val[2] = recv_data__val[2];
  assign recv_data_msg[3] = recv_data__msg[3];
  assign recv_data_val[3] = recv_data__val[3];
  assign prologue_count_wire[0] = prologue_count_inport[0];
  assign prologue_count_wire[1] = prologue_count_inport[1];
  assign prologue_count_wire[2] = prologue_count_inport[2];
  assign prologue_count_wire[3] = prologue_count_inport[3];

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py

module RegisterFile__da749a1852bb59a5
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 regs [0:1];

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueueDpathRTL Definition
// Full name: NormalQueueDpathRTL__EntryType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__num_entries_2
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueDpathRTL__e10c2d77bcb9538e
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr ,
  input  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_msg ,
  input  logic [0:0] reset ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_msg ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component rf
  //-------------------------------------------------------------

  logic [0:0] rf__clk;
  logic [0:0] rf__raddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 rf__rdata [0:0];
  logic [0:0] rf__reset;
  logic [0:0] rf__waddr [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 rf__wdata [0:0];
  logic [0:0] rf__wen [0:0];

  RegisterFile__da749a1852bb59a5 rf
  (
    .clk( rf__clk ),
    .raddr( rf__raddr ),
    .rdata( rf__rdata ),
    .reset( rf__reset ),
    .waddr( rf__waddr ),
    .wdata( rf__wdata ),
    .wen( rf__wen )
  );

  //-------------------------------------------------------------
  // End of component rf
  //-------------------------------------------------------------

  assign rf__clk = clk;
  assign rf__reset = reset;
  assign rf__raddr[0] = raddr;
  assign send_msg = rf__rdata[0];
  assign rf__wen[0] = wen;
  assign rf__waddr[0] = waddr;
  assign rf__wdata[0] = recv_msg;

endmodule


// PyMTL Component NormalQueueRTL Definition
// Full name: NormalQueueRTL__EntryType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__num_entries_2
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/lib/basic/val_rdy/queues.py

module NormalQueueRTL__e10c2d77bcb9538e
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__recv_rdy;
  logic [0:0] ctrl__recv_val;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__send_rdy;
  logic [0:0] ctrl__send_val;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .raddr( ctrl__raddr ),
    .recv_rdy( ctrl__recv_rdy ),
    .recv_val( ctrl__recv_val ),
    .reset( ctrl__reset ),
    .send_rdy( ctrl__send_rdy ),
    .send_val( ctrl__send_val ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  logic [0:0] dpath__raddr;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 dpath__recv_msg;
  logic [0:0] dpath__reset;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 dpath__send_msg;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueueDpathRTL__e10c2d77bcb9538e dpath
  (
    .clk( dpath__clk ),
    .raddr( dpath__raddr ),
    .recv_msg( dpath__recv_msg ),
    .reset( dpath__reset ),
    .send_msg( dpath__send_msg ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__recv_val = recv__val;
  assign recv__rdy = ctrl__recv_rdy;
  assign dpath__recv_msg = recv__msg;
  assign send__val = ctrl__send_val;
  assign ctrl__send_rdy = send__rdy;
  assign send__msg = dpath__send_msg;
  assign count = ctrl__count;

endmodule


// PyMTL Component ChannelRTL Definition
// Full name: ChannelRTL__PacketType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__QueueType_NormalQueueRTL__latency_1
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/channel/ChannelRTL.py

module ChannelRTL__d316842813c529a6
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component queues[0:0]
  //-------------------------------------------------------------

  logic [0:0] queues__clk [0:0];
  logic [1:0] queues__count [0:0];
  logic [0:0] queues__reset [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 queues__recv__msg [0:0];
  logic [0:0] queues__recv__rdy [0:0];
  logic [0:0] queues__recv__val [0:0];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 queues__send__msg [0:0];
  logic [0:0] queues__send__rdy [0:0];
  logic [0:0] queues__send__val [0:0];

  NormalQueueRTL__e10c2d77bcb9538e queues__0
  (
    .clk( queues__clk[0] ),
    .count( queues__count[0] ),
    .reset( queues__reset[0] ),
    .recv__msg( queues__recv__msg[0] ),
    .recv__rdy( queues__recv__rdy[0] ),
    .recv__val( queues__recv__val[0] ),
    .send__msg( queues__send__msg[0] ),
    .send__rdy( queues__send__rdy[0] ),
    .send__val( queues__send__val[0] )
  );

  //-------------------------------------------------------------
  // End of component queues[0:0]
  //-------------------------------------------------------------

  assign queues__clk[0] = clk;
  assign queues__reset[0] = reset;
  assign queues__recv__msg[0] = recv__msg;
  assign recv__rdy = queues__recv__rdy[0];
  assign queues__recv__val[0] = recv__val;
  assign send__msg = queues__send__msg[0];
  assign queues__send__rdy[0] = send__rdy;
  assign send__val = queues__send__val[0];

endmodule


// PyMTL Component LinkOrRTL Definition
// Full name: LinkOrRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/LinkOrRTL.py

module LinkOrRTL__a54ca58e7852ace8
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_fu__msg  ,
  output logic [0:0] recv_fu__rdy  ,
  input logic [0:0] recv_fu__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_xbar__msg  ,
  output logic [0:0] recv_xbar__rdy  ,
  input logic [0:0] recv_xbar__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/LinkOrRTL.py:28
  // @update
  // def process():
  //   # Initializes the delivered message.
  //   s.send.msg @= DataType()
  // 
  //   # The messages from two sources (i.e., xbar and FU) won't be valid
  //   # simultaneously (confliction would be caused if they both are valid),
  //   # which is guaranteed by the compiler/software.
  //   s.send.msg.predicate @= s.recv_fu.msg.predicate | s.recv_xbar.msg.predicate
  //   s.send.msg.payload @= s.recv_xbar.msg.payload | s.recv_fu.msg.payload
  // 
  //   # FIXME: bypass won't be necessary any more with separate xbar design.
  //   # s.send.msg.bypass @= 0
  //   # s.send.msg.delay @= s.recv_fu.msg.delay | s.recv_xbar.msg.delay
  // 
  //   # s.send.val @= s.send.rdy & (s.recv_fu.val | s.recv_xbar.val)
  //   s.send.val @= s.recv_fu.val | s.recv_xbar.val
  //   s.recv_fu.rdy @= s.send.rdy
  //   s.recv_xbar.rdy @= s.send.rdy
  
  always_comb begin : process
    send__msg = { 32'd0, 1'd0, 1'd0, 1'd0 };
    send__msg.predicate = recv_fu__msg.predicate | recv_xbar__msg.predicate;
    send__msg.payload = recv_xbar__msg.payload | recv_fu__msg.payload;
    send__val = recv_fu__val | recv_xbar__val;
    recv_fu__rdy = send__rdy;
    recv_xbar__rdy = send__rdy;
  end

endmodule


// PyMTL Component TileRTL Definition
// Full name: TileRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__PredicateType_CGRAData_1_1__payload_1__predicate_1__CtrlPktType_IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74__CgraPayloadType_MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__cc89ed621b71ae36__CtrlSignalType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__ctrl_mem_size_16__data_mem_size_288__num_ctrl_2__total_steps_2__num_fu_inports_4__num_fu_outports_2__num_tile_inports_4__num_tile_outports_4__num_cgras_9__num_tiles_4__num_registers_per_reg_bank_16__Fu_FlexibleFuRTL__FuList_[<class 'VectorCGRA.fu.single.AdderRTL.AdderRTL'>, <class 'VectorCGRA.fu.single.MulRTL.MulRTL'>, <class 'VectorCGRA.fu.single.LogicRTL.LogicRTL'>, <class 'VectorCGRA.fu.single.ShifterRTL.ShifterRTL'>, <class 'VectorCGRA.fu.single.PhiRTL.PhiRTL'>, <class 'VectorCGRA.fu.single.CompRTL.CompRTL'>, <class 'VectorCGRA.fu.single.BranchRTL.BranchRTL'>, <class 'VectorCGRA.fu.single.MemUnitRTL.MemUnitRTL'>, <class 'VectorCGRA.fu.single.SelRTL.SelRTL'>, <class 'VectorCGRA.fu.float.FpAddRTL.FpAddRTL'>, <class 'VectorCGRA.fu.float.FpMulRTL.FpMulRTL'>, <class 'VectorCGRA.fu.double.SeqMulAdderRTL.SeqMulAdderRTL'>, <class 'VectorCGRA.fu.vector.VectorMulComboRTL.VectorMulComboRTL'>, <class 'VectorCGRA.fu.vector.VectorAdderComboRTL.VectorAdderComboRTL'>, <class 'VectorCGRA.fu.single.NahRTL.NahRTL'>]
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/tile/TileRTL.py

module TileRTL__2a4c76f35d70369f
(
  input  logic [3:0] cgra_id ,
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input  logic [2:0] tile_id ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 from_mem_rdata__msg  ,
  output logic [0:0] from_mem_rdata__rdy  ,
  input logic [0:0] from_mem_rdata__val  ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_data__msg [0:3] ,
  output logic [0:0] recv_data__rdy [0:3] ,
  input logic [0:0] recv_data__val [0:3] ,
  input IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv_from_controller_pkt__msg  ,
  output logic [0:0] recv_from_controller_pkt__rdy  ,
  input logic [0:0] recv_from_controller_pkt__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_data__msg [0:3] ,
  input logic [0:0] send_data__rdy [0:3] ,
  output logic [0:0] send_data__val [0:3] ,
  output IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send_to_controller_pkt__msg  ,
  input logic [0:0] send_to_controller_pkt__rdy  ,
  output logic [0:0] send_to_controller_pkt__val  ,
  output logic [8:0] to_mem_raddr__msg  ,
  input logic [0:0] to_mem_raddr__rdy  ,
  output logic [0:0] to_mem_raddr__val  ,
  output logic [8:0] to_mem_waddr__msg  ,
  input logic [0:0] to_mem_waddr__rdy  ,
  output logic [0:0] to_mem_waddr__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 to_mem_wdata__msg  ,
  input logic [0:0] to_mem_wdata__rdy  ,
  output logic [0:0] to_mem_wdata__val  
);
  localparam logic [1:0] __const__CMD_CONFIG  = 2'd3;
  localparam logic [2:0] __const__CMD_CONFIG_PROLOGUE_FU  = 3'd4;
  localparam logic [2:0] __const__CMD_CONFIG_PROLOGUE_FU_CROSSBAR  = 3'd5;
  localparam logic [2:0] __const__CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR  = 3'd6;
  localparam logic [2:0] __const__CMD_CONFIG_TOTAL_CTRL_COUNT  = 3'd7;
  localparam logic [3:0] __const__CMD_CONFIG_COUNT_PER_ITER  = 4'd8;
  localparam logic [0:0] __const__CMD_LAUNCH  = 1'd0;
  localparam logic [3:0] __const__CMD_CONST  = 4'd12;
  logic [0:0] element_done;
  logic [0:0] fu_crossbar_done;
  logic [0:0] routing_crossbar_done;
  //-------------------------------------------------------------
  // Component const_mem
  //-------------------------------------------------------------

  logic [0:0] const_mem__clk;
  logic [0:0] const_mem__ctrl_proceed;
  logic [0:0] const_mem__reset;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_mem__recv_const__msg;
  logic [0:0] const_mem__recv_const__rdy;
  logic [0:0] const_mem__recv_const__val;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 const_mem__send_const__msg;
  logic [0:0] const_mem__send_const__rdy;
  logic [0:0] const_mem__send_const__val;

  ConstQueueDynamicRTL__88a7029ff4fc07c5 const_mem
  (
    .clk( const_mem__clk ),
    .ctrl_proceed( const_mem__ctrl_proceed ),
    .reset( const_mem__reset ),
    .recv_const__msg( const_mem__recv_const__msg ),
    .recv_const__rdy( const_mem__recv_const__rdy ),
    .recv_const__val( const_mem__recv_const__val ),
    .send_const__msg( const_mem__send_const__msg ),
    .send_const__rdy( const_mem__send_const__rdy ),
    .send_const__val( const_mem__send_const__val )
  );

  //-------------------------------------------------------------
  // End of component const_mem
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component ctrl_mem
  //-------------------------------------------------------------

  logic [3:0] ctrl_mem__cgra_id;
  logic [0:0] ctrl_mem__clk;
  logic [2:0] ctrl_mem__prologue_count_outport_fu;
  logic [2:0] ctrl_mem__prologue_count_outport_fu_crossbar [0:1];
  logic [2:0] ctrl_mem__prologue_count_outport_routing_crossbar [0:3];
  logic [0:0] ctrl_mem__reset;
  logic [2:0] ctrl_mem__tile_id;
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 ctrl_mem__recv_pkt_from_controller__msg;
  logic [0:0] ctrl_mem__recv_pkt_from_controller__rdy;
  logic [0:0] ctrl_mem__recv_pkt_from_controller__val;
  CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf ctrl_mem__send_ctrl__msg;
  logic [0:0] ctrl_mem__send_ctrl__rdy;
  logic [0:0] ctrl_mem__send_ctrl__val;
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 ctrl_mem__send_pkt_to_controller__msg;
  logic [0:0] ctrl_mem__send_pkt_to_controller__rdy;
  logic [0:0] ctrl_mem__send_pkt_to_controller__val;

  CtrlMemDynamicRTL__49719e7312efa92b ctrl_mem
  (
    .cgra_id( ctrl_mem__cgra_id ),
    .clk( ctrl_mem__clk ),
    .prologue_count_outport_fu( ctrl_mem__prologue_count_outport_fu ),
    .prologue_count_outport_fu_crossbar( ctrl_mem__prologue_count_outport_fu_crossbar ),
    .prologue_count_outport_routing_crossbar( ctrl_mem__prologue_count_outport_routing_crossbar ),
    .reset( ctrl_mem__reset ),
    .tile_id( ctrl_mem__tile_id ),
    .recv_pkt_from_controller__msg( ctrl_mem__recv_pkt_from_controller__msg ),
    .recv_pkt_from_controller__rdy( ctrl_mem__recv_pkt_from_controller__rdy ),
    .recv_pkt_from_controller__val( ctrl_mem__recv_pkt_from_controller__val ),
    .send_ctrl__msg( ctrl_mem__send_ctrl__msg ),
    .send_ctrl__rdy( ctrl_mem__send_ctrl__rdy ),
    .send_ctrl__val( ctrl_mem__send_ctrl__val ),
    .send_pkt_to_controller__msg( ctrl_mem__send_pkt_to_controller__msg ),
    .send_pkt_to_controller__rdy( ctrl_mem__send_pkt_to_controller__rdy ),
    .send_pkt_to_controller__val( ctrl_mem__send_pkt_to_controller__val )
  );

  //-------------------------------------------------------------
  // End of component ctrl_mem
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component element
  //-------------------------------------------------------------

  logic [0:0] element__clk;
  logic [2:0] element__prologue_count_inport;
  logic [0:0] element__reset;
  logic [2:0] element__tile_id;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 element__from_mem_rdata__msg [0:14];
  logic [0:0] element__from_mem_rdata__rdy [0:14];
  logic [0:0] element__from_mem_rdata__val [0:14];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 element__recv_const__msg;
  logic [0:0] element__recv_const__rdy;
  logic [0:0] element__recv_const__val;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 element__recv_in__msg [0:3];
  logic [0:0] element__recv_in__rdy [0:3];
  logic [0:0] element__recv_in__val [0:3];
  CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf element__recv_opt__msg;
  logic [0:0] element__recv_opt__rdy;
  logic [0:0] element__recv_opt__val;
  CGRAData_1_1__payload_1__predicate_1 element__recv_predicate__msg;
  logic [0:0] element__recv_predicate__rdy;
  logic [0:0] element__recv_predicate__val;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 element__send_out__msg [0:1];
  logic [0:0] element__send_out__rdy [0:1];
  logic [0:0] element__send_out__val [0:1];
  logic [8:0] element__to_mem_raddr__msg [0:14];
  logic [0:0] element__to_mem_raddr__rdy [0:14];
  logic [0:0] element__to_mem_raddr__val [0:14];
  logic [8:0] element__to_mem_waddr__msg [0:14];
  logic [0:0] element__to_mem_waddr__rdy [0:14];
  logic [0:0] element__to_mem_waddr__val [0:14];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 element__to_mem_wdata__msg [0:14];
  logic [0:0] element__to_mem_wdata__rdy [0:14];
  logic [0:0] element__to_mem_wdata__val [0:14];

  FlexibleFuRTL__87f5ec13648cf169 element
  (
    .clk( element__clk ),
    .prologue_count_inport( element__prologue_count_inport ),
    .reset( element__reset ),
    .tile_id( element__tile_id ),
    .from_mem_rdata__msg( element__from_mem_rdata__msg ),
    .from_mem_rdata__rdy( element__from_mem_rdata__rdy ),
    .from_mem_rdata__val( element__from_mem_rdata__val ),
    .recv_const__msg( element__recv_const__msg ),
    .recv_const__rdy( element__recv_const__rdy ),
    .recv_const__val( element__recv_const__val ),
    .recv_in__msg( element__recv_in__msg ),
    .recv_in__rdy( element__recv_in__rdy ),
    .recv_in__val( element__recv_in__val ),
    .recv_opt__msg( element__recv_opt__msg ),
    .recv_opt__rdy( element__recv_opt__rdy ),
    .recv_opt__val( element__recv_opt__val ),
    .recv_predicate__msg( element__recv_predicate__msg ),
    .recv_predicate__rdy( element__recv_predicate__rdy ),
    .recv_predicate__val( element__recv_predicate__val ),
    .send_out__msg( element__send_out__msg ),
    .send_out__rdy( element__send_out__rdy ),
    .send_out__val( element__send_out__val ),
    .to_mem_raddr__msg( element__to_mem_raddr__msg ),
    .to_mem_raddr__rdy( element__to_mem_raddr__rdy ),
    .to_mem_raddr__val( element__to_mem_raddr__val ),
    .to_mem_waddr__msg( element__to_mem_waddr__msg ),
    .to_mem_waddr__rdy( element__to_mem_waddr__rdy ),
    .to_mem_waddr__val( element__to_mem_waddr__val ),
    .to_mem_wdata__msg( element__to_mem_wdata__msg ),
    .to_mem_wdata__rdy( element__to_mem_wdata__rdy ),
    .to_mem_wdata__val( element__to_mem_wdata__val )
  );

  //-------------------------------------------------------------
  // End of component element
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component fu_crossbar
  //-------------------------------------------------------------

  logic [0:0] fu_crossbar__clk;
  logic [0:0] fu_crossbar__compute_done;
  logic [0:0] fu_crossbar__crossbar_id;
  logic [1:0] fu_crossbar__crossbar_outport [0:7];
  logic [2:0] fu_crossbar__prologue_count_inport [0:1];
  logic [0:0] fu_crossbar__reset;
  logic [2:0] fu_crossbar__tile_id;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 fu_crossbar__recv_data__msg [0:1];
  logic [0:0] fu_crossbar__recv_data__rdy [0:1];
  logic [0:0] fu_crossbar__recv_data__val [0:1];
  CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf fu_crossbar__recv_opt__msg;
  logic [0:0] fu_crossbar__recv_opt__rdy;
  logic [0:0] fu_crossbar__recv_opt__val;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 fu_crossbar__send_data__msg [0:7];
  logic [0:0] fu_crossbar__send_data__rdy [0:7];
  logic [0:0] fu_crossbar__send_data__val [0:7];
  CGRAData_1_1__payload_1__predicate_1 fu_crossbar__send_predicate__msg;
  logic [0:0] fu_crossbar__send_predicate__rdy;
  logic [0:0] fu_crossbar__send_predicate__val;

  CrossbarRTL__51a4a9c5505a1f59 fu_crossbar
  (
    .clk( fu_crossbar__clk ),
    .compute_done( fu_crossbar__compute_done ),
    .crossbar_id( fu_crossbar__crossbar_id ),
    .crossbar_outport( fu_crossbar__crossbar_outport ),
    .prologue_count_inport( fu_crossbar__prologue_count_inport ),
    .reset( fu_crossbar__reset ),
    .tile_id( fu_crossbar__tile_id ),
    .recv_data__msg( fu_crossbar__recv_data__msg ),
    .recv_data__rdy( fu_crossbar__recv_data__rdy ),
    .recv_data__val( fu_crossbar__recv_data__val ),
    .recv_opt__msg( fu_crossbar__recv_opt__msg ),
    .recv_opt__rdy( fu_crossbar__recv_opt__rdy ),
    .recv_opt__val( fu_crossbar__recv_opt__val ),
    .send_data__msg( fu_crossbar__send_data__msg ),
    .send_data__rdy( fu_crossbar__send_data__rdy ),
    .send_data__val( fu_crossbar__send_data__val ),
    .send_predicate__msg( fu_crossbar__send_predicate__msg ),
    .send_predicate__rdy( fu_crossbar__send_predicate__rdy ),
    .send_predicate__val( fu_crossbar__send_predicate__val )
  );

  //-------------------------------------------------------------
  // End of component fu_crossbar
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component reg_predicate
  //-------------------------------------------------------------

  logic [0:0] reg_predicate__clk;
  logic [0:0] reg_predicate__reset;
  CGRAData_1_1__payload_1__predicate_1 reg_predicate__recv__msg;
  logic [0:0] reg_predicate__recv__rdy;
  logic [0:0] reg_predicate__recv__val;
  CGRAData_1_1__payload_1__predicate_1 reg_predicate__send__msg;
  logic [0:0] reg_predicate__send__rdy;
  logic [0:0] reg_predicate__send__val;

  RegisterRTL__e306da7100516ae4 reg_predicate
  (
    .clk( reg_predicate__clk ),
    .reset( reg_predicate__reset ),
    .recv__msg( reg_predicate__recv__msg ),
    .recv__rdy( reg_predicate__recv__rdy ),
    .recv__val( reg_predicate__recv__val ),
    .send__msg( reg_predicate__send__msg ),
    .send__rdy( reg_predicate__send__rdy ),
    .send__val( reg_predicate__send__val )
  );

  //-------------------------------------------------------------
  // End of component reg_predicate
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component register_cluster
  //-------------------------------------------------------------

  logic [0:0] register_cluster__clk;
  CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf register_cluster__inport_opt;
  logic [0:0] register_cluster__reset;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 register_cluster__recv_data_from_const__msg [0:3];
  logic [0:0] register_cluster__recv_data_from_const__rdy [0:3];
  logic [0:0] register_cluster__recv_data_from_const__val [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 register_cluster__recv_data_from_fu_crossbar__msg [0:3];
  logic [0:0] register_cluster__recv_data_from_fu_crossbar__rdy [0:3];
  logic [0:0] register_cluster__recv_data_from_fu_crossbar__val [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 register_cluster__recv_data_from_routing_crossbar__msg [0:3];
  logic [0:0] register_cluster__recv_data_from_routing_crossbar__rdy [0:3];
  logic [0:0] register_cluster__recv_data_from_routing_crossbar__val [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 register_cluster__send_data_to_fu__msg [0:3];
  logic [0:0] register_cluster__send_data_to_fu__rdy [0:3];
  logic [0:0] register_cluster__send_data_to_fu__val [0:3];

  RegisterClusterRTL__c0c508814bde6822 register_cluster
  (
    .clk( register_cluster__clk ),
    .inport_opt( register_cluster__inport_opt ),
    .reset( register_cluster__reset ),
    .recv_data_from_const__msg( register_cluster__recv_data_from_const__msg ),
    .recv_data_from_const__rdy( register_cluster__recv_data_from_const__rdy ),
    .recv_data_from_const__val( register_cluster__recv_data_from_const__val ),
    .recv_data_from_fu_crossbar__msg( register_cluster__recv_data_from_fu_crossbar__msg ),
    .recv_data_from_fu_crossbar__rdy( register_cluster__recv_data_from_fu_crossbar__rdy ),
    .recv_data_from_fu_crossbar__val( register_cluster__recv_data_from_fu_crossbar__val ),
    .recv_data_from_routing_crossbar__msg( register_cluster__recv_data_from_routing_crossbar__msg ),
    .recv_data_from_routing_crossbar__rdy( register_cluster__recv_data_from_routing_crossbar__rdy ),
    .recv_data_from_routing_crossbar__val( register_cluster__recv_data_from_routing_crossbar__val ),
    .send_data_to_fu__msg( register_cluster__send_data_to_fu__msg ),
    .send_data_to_fu__rdy( register_cluster__send_data_to_fu__rdy ),
    .send_data_to_fu__val( register_cluster__send_data_to_fu__val )
  );

  //-------------------------------------------------------------
  // End of component register_cluster
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component routing_crossbar
  //-------------------------------------------------------------

  logic [0:0] routing_crossbar__clk;
  logic [0:0] routing_crossbar__compute_done;
  logic [0:0] routing_crossbar__crossbar_id;
  logic [2:0] routing_crossbar__crossbar_outport [0:7];
  logic [2:0] routing_crossbar__prologue_count_inport [0:3];
  logic [0:0] routing_crossbar__reset;
  logic [2:0] routing_crossbar__tile_id;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 routing_crossbar__recv_data__msg [0:3];
  logic [0:0] routing_crossbar__recv_data__rdy [0:3];
  logic [0:0] routing_crossbar__recv_data__val [0:3];
  CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf routing_crossbar__recv_opt__msg;
  logic [0:0] routing_crossbar__recv_opt__rdy;
  logic [0:0] routing_crossbar__recv_opt__val;
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 routing_crossbar__send_data__msg [0:7];
  logic [0:0] routing_crossbar__send_data__rdy [0:7];
  logic [0:0] routing_crossbar__send_data__val [0:7];
  CGRAData_1_1__payload_1__predicate_1 routing_crossbar__send_predicate__msg;
  logic [0:0] routing_crossbar__send_predicate__rdy;
  logic [0:0] routing_crossbar__send_predicate__val;

  CrossbarRTL__5490bda7b6002819 routing_crossbar
  (
    .clk( routing_crossbar__clk ),
    .compute_done( routing_crossbar__compute_done ),
    .crossbar_id( routing_crossbar__crossbar_id ),
    .crossbar_outport( routing_crossbar__crossbar_outport ),
    .prologue_count_inport( routing_crossbar__prologue_count_inport ),
    .reset( routing_crossbar__reset ),
    .tile_id( routing_crossbar__tile_id ),
    .recv_data__msg( routing_crossbar__recv_data__msg ),
    .recv_data__rdy( routing_crossbar__recv_data__rdy ),
    .recv_data__val( routing_crossbar__recv_data__val ),
    .recv_opt__msg( routing_crossbar__recv_opt__msg ),
    .recv_opt__rdy( routing_crossbar__recv_opt__rdy ),
    .recv_opt__val( routing_crossbar__recv_opt__val ),
    .send_data__msg( routing_crossbar__send_data__msg ),
    .send_data__rdy( routing_crossbar__send_data__rdy ),
    .send_data__val( routing_crossbar__send_data__val ),
    .send_predicate__msg( routing_crossbar__send_predicate__msg ),
    .send_predicate__rdy( routing_crossbar__send_predicate__rdy ),
    .send_predicate__val( routing_crossbar__send_predicate__val )
  );

  //-------------------------------------------------------------
  // End of component routing_crossbar
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component tile_in_channel[0:3]
  //-------------------------------------------------------------

  logic [0:0] tile_in_channel__clk [0:3];
  logic [0:0] tile_in_channel__reset [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 tile_in_channel__recv__msg [0:3];
  logic [0:0] tile_in_channel__recv__rdy [0:3];
  logic [0:0] tile_in_channel__recv__val [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 tile_in_channel__send__msg [0:3];
  logic [0:0] tile_in_channel__send__rdy [0:3];
  logic [0:0] tile_in_channel__send__val [0:3];

  ChannelRTL__d316842813c529a6 tile_in_channel__0
  (
    .clk( tile_in_channel__clk[0] ),
    .reset( tile_in_channel__reset[0] ),
    .recv__msg( tile_in_channel__recv__msg[0] ),
    .recv__rdy( tile_in_channel__recv__rdy[0] ),
    .recv__val( tile_in_channel__recv__val[0] ),
    .send__msg( tile_in_channel__send__msg[0] ),
    .send__rdy( tile_in_channel__send__rdy[0] ),
    .send__val( tile_in_channel__send__val[0] )
  );

  ChannelRTL__d316842813c529a6 tile_in_channel__1
  (
    .clk( tile_in_channel__clk[1] ),
    .reset( tile_in_channel__reset[1] ),
    .recv__msg( tile_in_channel__recv__msg[1] ),
    .recv__rdy( tile_in_channel__recv__rdy[1] ),
    .recv__val( tile_in_channel__recv__val[1] ),
    .send__msg( tile_in_channel__send__msg[1] ),
    .send__rdy( tile_in_channel__send__rdy[1] ),
    .send__val( tile_in_channel__send__val[1] )
  );

  ChannelRTL__d316842813c529a6 tile_in_channel__2
  (
    .clk( tile_in_channel__clk[2] ),
    .reset( tile_in_channel__reset[2] ),
    .recv__msg( tile_in_channel__recv__msg[2] ),
    .recv__rdy( tile_in_channel__recv__rdy[2] ),
    .recv__val( tile_in_channel__recv__val[2] ),
    .send__msg( tile_in_channel__send__msg[2] ),
    .send__rdy( tile_in_channel__send__rdy[2] ),
    .send__val( tile_in_channel__send__val[2] )
  );

  ChannelRTL__d316842813c529a6 tile_in_channel__3
  (
    .clk( tile_in_channel__clk[3] ),
    .reset( tile_in_channel__reset[3] ),
    .recv__msg( tile_in_channel__recv__msg[3] ),
    .recv__rdy( tile_in_channel__recv__rdy[3] ),
    .recv__val( tile_in_channel__recv__val[3] ),
    .send__msg( tile_in_channel__send__msg[3] ),
    .send__rdy( tile_in_channel__send__rdy[3] ),
    .send__val( tile_in_channel__send__val[3] )
  );

  //-------------------------------------------------------------
  // End of component tile_in_channel[0:3]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component tile_out_or_link[0:3]
  //-------------------------------------------------------------

  logic [0:0] tile_out_or_link__clk [0:3];
  logic [0:0] tile_out_or_link__reset [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 tile_out_or_link__recv_fu__msg [0:3];
  logic [0:0] tile_out_or_link__recv_fu__rdy [0:3];
  logic [0:0] tile_out_or_link__recv_fu__val [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 tile_out_or_link__recv_xbar__msg [0:3];
  logic [0:0] tile_out_or_link__recv_xbar__rdy [0:3];
  logic [0:0] tile_out_or_link__recv_xbar__val [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 tile_out_or_link__send__msg [0:3];
  logic [0:0] tile_out_or_link__send__rdy [0:3];
  logic [0:0] tile_out_or_link__send__val [0:3];

  LinkOrRTL__a54ca58e7852ace8 tile_out_or_link__0
  (
    .clk( tile_out_or_link__clk[0] ),
    .reset( tile_out_or_link__reset[0] ),
    .recv_fu__msg( tile_out_or_link__recv_fu__msg[0] ),
    .recv_fu__rdy( tile_out_or_link__recv_fu__rdy[0] ),
    .recv_fu__val( tile_out_or_link__recv_fu__val[0] ),
    .recv_xbar__msg( tile_out_or_link__recv_xbar__msg[0] ),
    .recv_xbar__rdy( tile_out_or_link__recv_xbar__rdy[0] ),
    .recv_xbar__val( tile_out_or_link__recv_xbar__val[0] ),
    .send__msg( tile_out_or_link__send__msg[0] ),
    .send__rdy( tile_out_or_link__send__rdy[0] ),
    .send__val( tile_out_or_link__send__val[0] )
  );

  LinkOrRTL__a54ca58e7852ace8 tile_out_or_link__1
  (
    .clk( tile_out_or_link__clk[1] ),
    .reset( tile_out_or_link__reset[1] ),
    .recv_fu__msg( tile_out_or_link__recv_fu__msg[1] ),
    .recv_fu__rdy( tile_out_or_link__recv_fu__rdy[1] ),
    .recv_fu__val( tile_out_or_link__recv_fu__val[1] ),
    .recv_xbar__msg( tile_out_or_link__recv_xbar__msg[1] ),
    .recv_xbar__rdy( tile_out_or_link__recv_xbar__rdy[1] ),
    .recv_xbar__val( tile_out_or_link__recv_xbar__val[1] ),
    .send__msg( tile_out_or_link__send__msg[1] ),
    .send__rdy( tile_out_or_link__send__rdy[1] ),
    .send__val( tile_out_or_link__send__val[1] )
  );

  LinkOrRTL__a54ca58e7852ace8 tile_out_or_link__2
  (
    .clk( tile_out_or_link__clk[2] ),
    .reset( tile_out_or_link__reset[2] ),
    .recv_fu__msg( tile_out_or_link__recv_fu__msg[2] ),
    .recv_fu__rdy( tile_out_or_link__recv_fu__rdy[2] ),
    .recv_fu__val( tile_out_or_link__recv_fu__val[2] ),
    .recv_xbar__msg( tile_out_or_link__recv_xbar__msg[2] ),
    .recv_xbar__rdy( tile_out_or_link__recv_xbar__rdy[2] ),
    .recv_xbar__val( tile_out_or_link__recv_xbar__val[2] ),
    .send__msg( tile_out_or_link__send__msg[2] ),
    .send__rdy( tile_out_or_link__send__rdy[2] ),
    .send__val( tile_out_or_link__send__val[2] )
  );

  LinkOrRTL__a54ca58e7852ace8 tile_out_or_link__3
  (
    .clk( tile_out_or_link__clk[3] ),
    .reset( tile_out_or_link__reset[3] ),
    .recv_fu__msg( tile_out_or_link__recv_fu__msg[3] ),
    .recv_fu__rdy( tile_out_or_link__recv_fu__rdy[3] ),
    .recv_fu__val( tile_out_or_link__recv_fu__val[3] ),
    .recv_xbar__msg( tile_out_or_link__recv_xbar__msg[3] ),
    .recv_xbar__rdy( tile_out_or_link__recv_xbar__rdy[3] ),
    .recv_xbar__val( tile_out_or_link__recv_xbar__val[3] ),
    .send__msg( tile_out_or_link__send__msg[3] ),
    .send__rdy( tile_out_or_link__send__rdy[3] ),
    .send__val( tile_out_or_link__send__val[3] )
  );

  //-------------------------------------------------------------
  // End of component tile_out_or_link[0:3]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/tile/TileRTL.py:211
  // @update
  // def feed_pkt():
  //     s.ctrl_mem.recv_pkt_from_controller.msg @= CtrlPktType(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) # , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  //     s.const_mem.recv_const.msg @= DataType(0, 0, 0, 0)
  //     s.ctrl_mem.recv_pkt_from_controller.val @= 0
  //     s.const_mem.recv_const.val @= 0
  //     s.recv_from_controller_pkt.rdy @= 0
  // 
  //     if s.recv_from_controller_pkt.val & \
  //        ((s.recv_from_controller_pkt.msg.payload.cmd == CMD_CONFIG) | \
  //         (s.recv_from_controller_pkt.msg.payload.cmd == CMD_CONFIG_PROLOGUE_FU) | \
  //         (s.recv_from_controller_pkt.msg.payload.cmd == CMD_CONFIG_PROLOGUE_FU_CROSSBAR) | \
  //         (s.recv_from_controller_pkt.msg.payload.cmd == CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR) | \
  //         (s.recv_from_controller_pkt.msg.payload.cmd == CMD_CONFIG_TOTAL_CTRL_COUNT) | \
  //         (s.recv_from_controller_pkt.msg.payload.cmd == CMD_CONFIG_COUNT_PER_ITER) | \
  //         (s.recv_from_controller_pkt.msg.payload.cmd == CMD_LAUNCH)):
  //         s.ctrl_mem.recv_pkt_from_controller.val @= 1
  //         s.ctrl_mem.recv_pkt_from_controller.msg @= s.recv_from_controller_pkt.msg
  //         s.recv_from_controller_pkt.rdy @= s.ctrl_mem.recv_pkt_from_controller.rdy
  //     elif s.recv_from_controller_pkt.val & (s.recv_from_controller_pkt.msg.payload.cmd == CMD_CONST):
  //         s.const_mem.recv_const.val @= 1
  //         s.const_mem.recv_const.msg @= s.recv_from_controller_pkt.msg.payload.data
  //         # s.const_mem.recv_const.msg.predicate @= 1
  //         s.recv_from_controller_pkt.rdy @= s.const_mem.recv_const.rdy
  
  always_comb begin : feed_pkt
    ctrl_mem__recv_pkt_from_controller__msg = { 3'd0, 3'd0, 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 8'd0, 1'd0, 163'd0 };
    const_mem__recv_const__msg = { 32'd0, 1'd0, 1'd0, 1'd0 };
    ctrl_mem__recv_pkt_from_controller__val = 1'd0;
    const_mem__recv_const__val = 1'd0;
    recv_from_controller_pkt__rdy = 1'd0;
    if ( recv_from_controller_pkt__val & ( ( ( ( ( ( ( recv_from_controller_pkt__msg.payload.cmd == 4'( __const__CMD_CONFIG ) ) | ( recv_from_controller_pkt__msg.payload.cmd == 4'( __const__CMD_CONFIG_PROLOGUE_FU ) ) ) | ( recv_from_controller_pkt__msg.payload.cmd == 4'( __const__CMD_CONFIG_PROLOGUE_FU_CROSSBAR ) ) ) | ( recv_from_controller_pkt__msg.payload.cmd == 4'( __const__CMD_CONFIG_PROLOGUE_ROUTING_CROSSBAR ) ) ) | ( recv_from_controller_pkt__msg.payload.cmd == 4'( __const__CMD_CONFIG_TOTAL_CTRL_COUNT ) ) ) | ( recv_from_controller_pkt__msg.payload.cmd == 4'( __const__CMD_CONFIG_COUNT_PER_ITER ) ) ) | ( recv_from_controller_pkt__msg.payload.cmd == 4'( __const__CMD_LAUNCH ) ) ) ) begin
      ctrl_mem__recv_pkt_from_controller__val = 1'd1;
      ctrl_mem__recv_pkt_from_controller__msg = recv_from_controller_pkt__msg;
      recv_from_controller_pkt__rdy = ctrl_mem__recv_pkt_from_controller__rdy;
    end
    else if ( recv_from_controller_pkt__val & ( recv_from_controller_pkt__msg.payload.cmd == 4'( __const__CMD_CONST ) ) ) begin
      const_mem__recv_const__val = 1'd1;
      const_mem__recv_const__msg = recv_from_controller_pkt__msg.payload.data;
      recv_from_controller_pkt__rdy = const_mem__recv_const__rdy;
    end
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/tile/TileRTL.py:266
  // @update
  // def notify_const_mem():
  //   s.const_mem.ctrl_proceed @= s.ctrl_mem.send_ctrl.rdy & s.ctrl_mem.send_ctrl.val
  
  always_comb begin : notify_const_mem
    const_mem__ctrl_proceed = ctrl_mem__send_ctrl__rdy & ctrl_mem__send_ctrl__val;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/tile/TileRTL.py:285
  // @update
  // def notify_crossbars_compute_status():
  //   s.routing_crossbar.compute_done @= s.element_done
  //   s.fu_crossbar.compute_done @= s.element_done
  
  always_comb begin : notify_crossbars_compute_status
    routing_crossbar__compute_done = element_done;
    fu_crossbar__compute_done = element_done;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/tile/TileRTL.py:246
  // @update
  // def update_opt():
  //   s.element.recv_opt.msg @= s.ctrl_mem.send_ctrl.msg
  //   s.routing_crossbar.recv_opt.msg @= s.ctrl_mem.send_ctrl.msg
  //   s.fu_crossbar.recv_opt.msg @= s.ctrl_mem.send_ctrl.msg
  // 
  //   # FIXME: Do we still need separate element and routing_xbar?
  //   # FIXME: Do we need to consider reg bank here?
  //   s.element.recv_opt.val @= s.ctrl_mem.send_ctrl.val & ~s.element_done
  //   s.routing_crossbar.recv_opt.val @= s.ctrl_mem.send_ctrl.val & ~s.routing_crossbar_done
  //   s.fu_crossbar.recv_opt.val @= s.ctrl_mem.send_ctrl.val & ~s.fu_crossbar_done
  // 
  //   # FIXME: yo96, rename ctrl.rdy to ctrl.proceed or sth similar.
  //   # Allows either the FU-related go out first or routing-xbar go out first. And only
  //   # allows the ctrl signal proceed till all the sub-modules done their own job (once).
  //   s.ctrl_mem.send_ctrl.rdy @= (s.element.recv_opt.rdy | s.element_done) & \
  //                               (s.routing_crossbar.recv_opt.rdy | s.routing_crossbar_done) & \
  //                               (s.fu_crossbar.recv_opt.rdy | s.fu_crossbar_done)
  
  always_comb begin : update_opt
    element__recv_opt__msg = ctrl_mem__send_ctrl__msg;
    routing_crossbar__recv_opt__msg = ctrl_mem__send_ctrl__msg;
    fu_crossbar__recv_opt__msg = ctrl_mem__send_ctrl__msg;
    element__recv_opt__val = ctrl_mem__send_ctrl__val & ( ~element_done );
    routing_crossbar__recv_opt__val = ctrl_mem__send_ctrl__val & ( ~routing_crossbar_done );
    fu_crossbar__recv_opt__val = ctrl_mem__send_ctrl__val & ( ~fu_crossbar_done );
    ctrl_mem__send_ctrl__rdy = ( ( element__recv_opt__rdy | element_done ) & ( routing_crossbar__recv_opt__rdy | routing_crossbar_done ) ) & ( fu_crossbar__recv_opt__rdy | fu_crossbar_done );
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/tile/TileRTL.py:236
  // @update
  // def update_send_out_signal():
  //     s.send_to_controller_pkt.val @= 0
  //     s.send_to_controller_pkt.msg @= CtrlPktType(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) # , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  //     if s.ctrl_mem.send_pkt_to_controller.val:
  //         s.send_to_controller_pkt.val @= 1
  //         s.send_to_controller_pkt.msg @= s.ctrl_mem.send_pkt_to_controller.msg
  //     s.ctrl_mem.send_pkt_to_controller.rdy @= s.send_to_controller_pkt.rdy
  
  always_comb begin : update_send_out_signal
    send_to_controller_pkt__val = 1'd0;
    send_to_controller_pkt__msg = { 3'd0, 3'd0, 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 8'd0, 1'd0, 163'd0 };
    if ( ctrl_mem__send_pkt_to_controller__val ) begin
      send_to_controller_pkt__val = 1'd1;
      send_to_controller_pkt__msg = ctrl_mem__send_pkt_to_controller__msg;
    end
    ctrl_mem__send_pkt_to_controller__rdy = send_to_controller_pkt__rdy;
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/tile/TileRTL.py:271
  // @update_ff
  // def already_done():
  //   if s.reset | s.ctrl_mem.send_ctrl.rdy:
  //     s.element_done <<= 0
  //     s.fu_crossbar_done <<= 0
  //     s.routing_crossbar_done <<= 0
  //   else:
  //     if s.element.recv_opt.rdy:
  //       s.element_done <<= 1
  //     if s.fu_crossbar.recv_opt.rdy:
  //       s.fu_crossbar_done <<= 1
  //     if s.routing_crossbar.recv_opt.rdy:
  //       s.routing_crossbar_done <<= 1
  
  always_ff @(posedge clk) begin : already_done
    if ( reset | ctrl_mem__send_ctrl__rdy ) begin
      element_done <= 1'd0;
      fu_crossbar_done <= 1'd0;
      routing_crossbar_done <= 1'd0;
    end
    else begin
      if ( element__recv_opt__rdy ) begin
        element_done <= 1'd1;
      end
      if ( fu_crossbar__recv_opt__rdy ) begin
        fu_crossbar_done <= 1'd1;
      end
      if ( routing_crossbar__recv_opt__rdy ) begin
        routing_crossbar_done <= 1'd1;
      end
    end
  end

  assign element__clk = clk;
  assign element__reset = reset;
  assign const_mem__clk = clk;
  assign const_mem__reset = reset;
  assign routing_crossbar__clk = clk;
  assign routing_crossbar__reset = reset;
  assign fu_crossbar__clk = clk;
  assign fu_crossbar__reset = reset;
  assign register_cluster__clk = clk;
  assign register_cluster__reset = reset;
  assign ctrl_mem__clk = clk;
  assign ctrl_mem__reset = reset;
  assign tile_in_channel__clk[0] = clk;
  assign tile_in_channel__reset[0] = reset;
  assign tile_in_channel__clk[1] = clk;
  assign tile_in_channel__reset[1] = reset;
  assign tile_in_channel__clk[2] = clk;
  assign tile_in_channel__reset[2] = reset;
  assign tile_in_channel__clk[3] = clk;
  assign tile_in_channel__reset[3] = reset;
  assign tile_out_or_link__clk[0] = clk;
  assign tile_out_or_link__reset[0] = reset;
  assign tile_out_or_link__clk[1] = clk;
  assign tile_out_or_link__reset[1] = reset;
  assign tile_out_or_link__clk[2] = clk;
  assign tile_out_or_link__reset[2] = reset;
  assign tile_out_or_link__clk[3] = clk;
  assign tile_out_or_link__reset[3] = reset;
  assign reg_predicate__clk = clk;
  assign reg_predicate__reset = reset;
  assign element__tile_id = tile_id;
  assign ctrl_mem__cgra_id = cgra_id;
  assign ctrl_mem__tile_id = tile_id;
  assign fu_crossbar__tile_id = tile_id;
  assign routing_crossbar__tile_id = tile_id;
  assign routing_crossbar__crossbar_id = 1'd0;
  assign fu_crossbar__crossbar_id = 1'd1;
  assign element__recv_const__msg = const_mem__send_const__msg;
  assign const_mem__send_const__rdy = element__recv_const__rdy;
  assign element__recv_const__val = const_mem__send_const__val;
  assign element__prologue_count_inport = ctrl_mem__prologue_count_outport_fu;
  assign routing_crossbar__prologue_count_inport[0] = ctrl_mem__prologue_count_outport_routing_crossbar[0];
  assign routing_crossbar__prologue_count_inport[1] = ctrl_mem__prologue_count_outport_routing_crossbar[1];
  assign routing_crossbar__prologue_count_inport[2] = ctrl_mem__prologue_count_outport_routing_crossbar[2];
  assign routing_crossbar__prologue_count_inport[3] = ctrl_mem__prologue_count_outport_routing_crossbar[3];
  assign fu_crossbar__prologue_count_inport[0] = ctrl_mem__prologue_count_outport_fu_crossbar[0];
  assign fu_crossbar__prologue_count_inport[1] = ctrl_mem__prologue_count_outport_fu_crossbar[1];
  assign element__to_mem_raddr__rdy[0] = 1'd0;
  assign element__from_mem_rdata__val[0] = 1'd0;
  assign element__from_mem_rdata__msg[0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[0] = 1'd0;
  assign element__to_mem_wdata__rdy[0] = 1'd0;
  assign element__to_mem_raddr__rdy[1] = 1'd0;
  assign element__from_mem_rdata__val[1] = 1'd0;
  assign element__from_mem_rdata__msg[1] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[1] = 1'd0;
  assign element__to_mem_wdata__rdy[1] = 1'd0;
  assign element__to_mem_raddr__rdy[2] = 1'd0;
  assign element__from_mem_rdata__val[2] = 1'd0;
  assign element__from_mem_rdata__msg[2] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[2] = 1'd0;
  assign element__to_mem_wdata__rdy[2] = 1'd0;
  assign element__to_mem_raddr__rdy[3] = 1'd0;
  assign element__from_mem_rdata__val[3] = 1'd0;
  assign element__from_mem_rdata__msg[3] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[3] = 1'd0;
  assign element__to_mem_wdata__rdy[3] = 1'd0;
  assign element__to_mem_raddr__rdy[4] = 1'd0;
  assign element__from_mem_rdata__val[4] = 1'd0;
  assign element__from_mem_rdata__msg[4] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[4] = 1'd0;
  assign element__to_mem_wdata__rdy[4] = 1'd0;
  assign element__to_mem_raddr__rdy[5] = 1'd0;
  assign element__from_mem_rdata__val[5] = 1'd0;
  assign element__from_mem_rdata__msg[5] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[5] = 1'd0;
  assign element__to_mem_wdata__rdy[5] = 1'd0;
  assign element__to_mem_raddr__rdy[6] = 1'd0;
  assign element__from_mem_rdata__val[6] = 1'd0;
  assign element__from_mem_rdata__msg[6] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[6] = 1'd0;
  assign element__to_mem_wdata__rdy[6] = 1'd0;
  assign to_mem_raddr__msg = element__to_mem_raddr__msg[7];
  assign element__to_mem_raddr__rdy[7] = to_mem_raddr__rdy;
  assign to_mem_raddr__val = element__to_mem_raddr__val[7];
  assign element__from_mem_rdata__msg[7] = from_mem_rdata__msg;
  assign from_mem_rdata__rdy = element__from_mem_rdata__rdy[7];
  assign element__from_mem_rdata__val[7] = from_mem_rdata__val;
  assign to_mem_waddr__msg = element__to_mem_waddr__msg[7];
  assign element__to_mem_waddr__rdy[7] = to_mem_waddr__rdy;
  assign to_mem_waddr__val = element__to_mem_waddr__val[7];
  assign to_mem_wdata__msg = element__to_mem_wdata__msg[7];
  assign element__to_mem_wdata__rdy[7] = to_mem_wdata__rdy;
  assign to_mem_wdata__val = element__to_mem_wdata__val[7];
  assign element__to_mem_raddr__rdy[8] = 1'd0;
  assign element__from_mem_rdata__val[8] = 1'd0;
  assign element__from_mem_rdata__msg[8] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[8] = 1'd0;
  assign element__to_mem_wdata__rdy[8] = 1'd0;
  assign element__to_mem_raddr__rdy[9] = 1'd0;
  assign element__from_mem_rdata__val[9] = 1'd0;
  assign element__from_mem_rdata__msg[9] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[9] = 1'd0;
  assign element__to_mem_wdata__rdy[9] = 1'd0;
  assign element__to_mem_raddr__rdy[10] = 1'd0;
  assign element__from_mem_rdata__val[10] = 1'd0;
  assign element__from_mem_rdata__msg[10] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[10] = 1'd0;
  assign element__to_mem_wdata__rdy[10] = 1'd0;
  assign element__to_mem_raddr__rdy[11] = 1'd0;
  assign element__from_mem_rdata__val[11] = 1'd0;
  assign element__from_mem_rdata__msg[11] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[11] = 1'd0;
  assign element__to_mem_wdata__rdy[11] = 1'd0;
  assign element__to_mem_raddr__rdy[12] = 1'd0;
  assign element__from_mem_rdata__val[12] = 1'd0;
  assign element__from_mem_rdata__msg[12] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[12] = 1'd0;
  assign element__to_mem_wdata__rdy[12] = 1'd0;
  assign element__to_mem_raddr__rdy[13] = 1'd0;
  assign element__from_mem_rdata__val[13] = 1'd0;
  assign element__from_mem_rdata__msg[13] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[13] = 1'd0;
  assign element__to_mem_wdata__rdy[13] = 1'd0;
  assign element__to_mem_raddr__rdy[14] = 1'd0;
  assign element__from_mem_rdata__val[14] = 1'd0;
  assign element__from_mem_rdata__msg[14] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[14] = 1'd0;
  assign element__to_mem_wdata__rdy[14] = 1'd0;
  assign tile_in_channel__recv__msg[0] = recv_data__msg[0];
  assign recv_data__rdy[0] = tile_in_channel__recv__rdy[0];
  assign tile_in_channel__recv__val[0] = recv_data__val[0];
  assign routing_crossbar__recv_data__msg[0] = tile_in_channel__send__msg[0];
  assign tile_in_channel__send__rdy[0] = routing_crossbar__recv_data__rdy[0];
  assign routing_crossbar__recv_data__val[0] = tile_in_channel__send__val[0];
  assign tile_in_channel__recv__msg[1] = recv_data__msg[1];
  assign recv_data__rdy[1] = tile_in_channel__recv__rdy[1];
  assign tile_in_channel__recv__val[1] = recv_data__val[1];
  assign routing_crossbar__recv_data__msg[1] = tile_in_channel__send__msg[1];
  assign tile_in_channel__send__rdy[1] = routing_crossbar__recv_data__rdy[1];
  assign routing_crossbar__recv_data__val[1] = tile_in_channel__send__val[1];
  assign tile_in_channel__recv__msg[2] = recv_data__msg[2];
  assign recv_data__rdy[2] = tile_in_channel__recv__rdy[2];
  assign tile_in_channel__recv__val[2] = recv_data__val[2];
  assign routing_crossbar__recv_data__msg[2] = tile_in_channel__send__msg[2];
  assign tile_in_channel__send__rdy[2] = routing_crossbar__recv_data__rdy[2];
  assign routing_crossbar__recv_data__val[2] = tile_in_channel__send__val[2];
  assign tile_in_channel__recv__msg[3] = recv_data__msg[3];
  assign recv_data__rdy[3] = tile_in_channel__recv__rdy[3];
  assign tile_in_channel__recv__val[3] = recv_data__val[3];
  assign routing_crossbar__recv_data__msg[3] = tile_in_channel__send__msg[3];
  assign tile_in_channel__send__rdy[3] = routing_crossbar__recv_data__rdy[3];
  assign routing_crossbar__recv_data__val[3] = tile_in_channel__send__val[3];
  assign routing_crossbar__crossbar_outport[0] = ctrl_mem__send_ctrl__msg.routing_xbar_outport[0];
  assign fu_crossbar__crossbar_outport[0] = ctrl_mem__send_ctrl__msg.fu_xbar_outport[0];
  assign routing_crossbar__crossbar_outport[1] = ctrl_mem__send_ctrl__msg.routing_xbar_outport[1];
  assign fu_crossbar__crossbar_outport[1] = ctrl_mem__send_ctrl__msg.fu_xbar_outport[1];
  assign routing_crossbar__crossbar_outport[2] = ctrl_mem__send_ctrl__msg.routing_xbar_outport[2];
  assign fu_crossbar__crossbar_outport[2] = ctrl_mem__send_ctrl__msg.fu_xbar_outport[2];
  assign routing_crossbar__crossbar_outport[3] = ctrl_mem__send_ctrl__msg.routing_xbar_outport[3];
  assign fu_crossbar__crossbar_outport[3] = ctrl_mem__send_ctrl__msg.fu_xbar_outport[3];
  assign routing_crossbar__crossbar_outport[4] = ctrl_mem__send_ctrl__msg.routing_xbar_outport[4];
  assign fu_crossbar__crossbar_outport[4] = ctrl_mem__send_ctrl__msg.fu_xbar_outport[4];
  assign routing_crossbar__crossbar_outport[5] = ctrl_mem__send_ctrl__msg.routing_xbar_outport[5];
  assign fu_crossbar__crossbar_outport[5] = ctrl_mem__send_ctrl__msg.fu_xbar_outport[5];
  assign routing_crossbar__crossbar_outport[6] = ctrl_mem__send_ctrl__msg.routing_xbar_outport[6];
  assign fu_crossbar__crossbar_outport[6] = ctrl_mem__send_ctrl__msg.fu_xbar_outport[6];
  assign routing_crossbar__crossbar_outport[7] = ctrl_mem__send_ctrl__msg.routing_xbar_outport[7];
  assign fu_crossbar__crossbar_outport[7] = ctrl_mem__send_ctrl__msg.fu_xbar_outport[7];
  assign reg_predicate__recv__msg = routing_crossbar__send_predicate__msg;
  assign routing_crossbar__send_predicate__rdy = reg_predicate__recv__rdy;
  assign reg_predicate__recv__val = routing_crossbar__send_predicate__val;
  assign element__recv_predicate__msg = reg_predicate__send__msg;
  assign reg_predicate__send__rdy = element__recv_predicate__rdy;
  assign element__recv_predicate__val = reg_predicate__send__val;
  assign fu_crossbar__recv_data__msg[0] = element__send_out__msg[0];
  assign element__send_out__rdy[0] = fu_crossbar__recv_data__rdy[0];
  assign fu_crossbar__recv_data__val[0] = element__send_out__val[0];
  assign fu_crossbar__recv_data__msg[1] = element__send_out__msg[1];
  assign element__send_out__rdy[1] = fu_crossbar__recv_data__rdy[1];
  assign fu_crossbar__recv_data__val[1] = element__send_out__val[1];
  assign tile_out_or_link__recv_fu__msg[0] = fu_crossbar__send_data__msg[0];
  assign fu_crossbar__send_data__rdy[0] = tile_out_or_link__recv_fu__rdy[0];
  assign tile_out_or_link__recv_fu__val[0] = fu_crossbar__send_data__val[0];
  assign tile_out_or_link__recv_xbar__msg[0] = routing_crossbar__send_data__msg[0];
  assign routing_crossbar__send_data__rdy[0] = tile_out_or_link__recv_xbar__rdy[0];
  assign tile_out_or_link__recv_xbar__val[0] = routing_crossbar__send_data__val[0];
  assign send_data__msg[0] = tile_out_or_link__send__msg[0];
  assign tile_out_or_link__send__rdy[0] = send_data__rdy[0];
  assign send_data__val[0] = tile_out_or_link__send__val[0];
  assign tile_out_or_link__recv_fu__msg[1] = fu_crossbar__send_data__msg[1];
  assign fu_crossbar__send_data__rdy[1] = tile_out_or_link__recv_fu__rdy[1];
  assign tile_out_or_link__recv_fu__val[1] = fu_crossbar__send_data__val[1];
  assign tile_out_or_link__recv_xbar__msg[1] = routing_crossbar__send_data__msg[1];
  assign routing_crossbar__send_data__rdy[1] = tile_out_or_link__recv_xbar__rdy[1];
  assign tile_out_or_link__recv_xbar__val[1] = routing_crossbar__send_data__val[1];
  assign send_data__msg[1] = tile_out_or_link__send__msg[1];
  assign tile_out_or_link__send__rdy[1] = send_data__rdy[1];
  assign send_data__val[1] = tile_out_or_link__send__val[1];
  assign tile_out_or_link__recv_fu__msg[2] = fu_crossbar__send_data__msg[2];
  assign fu_crossbar__send_data__rdy[2] = tile_out_or_link__recv_fu__rdy[2];
  assign tile_out_or_link__recv_fu__val[2] = fu_crossbar__send_data__val[2];
  assign tile_out_or_link__recv_xbar__msg[2] = routing_crossbar__send_data__msg[2];
  assign routing_crossbar__send_data__rdy[2] = tile_out_or_link__recv_xbar__rdy[2];
  assign tile_out_or_link__recv_xbar__val[2] = routing_crossbar__send_data__val[2];
  assign send_data__msg[2] = tile_out_or_link__send__msg[2];
  assign tile_out_or_link__send__rdy[2] = send_data__rdy[2];
  assign send_data__val[2] = tile_out_or_link__send__val[2];
  assign tile_out_or_link__recv_fu__msg[3] = fu_crossbar__send_data__msg[3];
  assign fu_crossbar__send_data__rdy[3] = tile_out_or_link__recv_fu__rdy[3];
  assign tile_out_or_link__recv_fu__val[3] = fu_crossbar__send_data__val[3];
  assign tile_out_or_link__recv_xbar__msg[3] = routing_crossbar__send_data__msg[3];
  assign routing_crossbar__send_data__rdy[3] = tile_out_or_link__recv_xbar__rdy[3];
  assign tile_out_or_link__recv_xbar__val[3] = routing_crossbar__send_data__val[3];
  assign send_data__msg[3] = tile_out_or_link__send__msg[3];
  assign tile_out_or_link__send__rdy[3] = send_data__rdy[3];
  assign send_data__val[3] = tile_out_or_link__send__val[3];
  assign register_cluster__recv_data_from_routing_crossbar__msg[0] = routing_crossbar__send_data__msg[4];
  assign routing_crossbar__send_data__rdy[4] = register_cluster__recv_data_from_routing_crossbar__rdy[0];
  assign register_cluster__recv_data_from_routing_crossbar__val[0] = routing_crossbar__send_data__val[4];
  assign register_cluster__recv_data_from_fu_crossbar__msg[0] = fu_crossbar__send_data__msg[4];
  assign fu_crossbar__send_data__rdy[4] = register_cluster__recv_data_from_fu_crossbar__rdy[0];
  assign register_cluster__recv_data_from_fu_crossbar__val[0] = fu_crossbar__send_data__val[4];
  assign register_cluster__recv_data_from_const__msg[0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign register_cluster__recv_data_from_const__val[0] = 1'd0;
  assign element__recv_in__msg[0] = register_cluster__send_data_to_fu__msg[0];
  assign register_cluster__send_data_to_fu__rdy[0] = element__recv_in__rdy[0];
  assign element__recv_in__val[0] = register_cluster__send_data_to_fu__val[0];
  assign register_cluster__inport_opt = ctrl_mem__send_ctrl__msg;
  assign register_cluster__recv_data_from_routing_crossbar__msg[1] = routing_crossbar__send_data__msg[5];
  assign routing_crossbar__send_data__rdy[5] = register_cluster__recv_data_from_routing_crossbar__rdy[1];
  assign register_cluster__recv_data_from_routing_crossbar__val[1] = routing_crossbar__send_data__val[5];
  assign register_cluster__recv_data_from_fu_crossbar__msg[1] = fu_crossbar__send_data__msg[5];
  assign fu_crossbar__send_data__rdy[5] = register_cluster__recv_data_from_fu_crossbar__rdy[1];
  assign register_cluster__recv_data_from_fu_crossbar__val[1] = fu_crossbar__send_data__val[5];
  assign register_cluster__recv_data_from_const__msg[1] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign register_cluster__recv_data_from_const__val[1] = 1'd0;
  assign element__recv_in__msg[1] = register_cluster__send_data_to_fu__msg[1];
  assign register_cluster__send_data_to_fu__rdy[1] = element__recv_in__rdy[1];
  assign element__recv_in__val[1] = register_cluster__send_data_to_fu__val[1];
  assign register_cluster__recv_data_from_routing_crossbar__msg[2] = routing_crossbar__send_data__msg[6];
  assign routing_crossbar__send_data__rdy[6] = register_cluster__recv_data_from_routing_crossbar__rdy[2];
  assign register_cluster__recv_data_from_routing_crossbar__val[2] = routing_crossbar__send_data__val[6];
  assign register_cluster__recv_data_from_fu_crossbar__msg[2] = fu_crossbar__send_data__msg[6];
  assign fu_crossbar__send_data__rdy[6] = register_cluster__recv_data_from_fu_crossbar__rdy[2];
  assign register_cluster__recv_data_from_fu_crossbar__val[2] = fu_crossbar__send_data__val[6];
  assign register_cluster__recv_data_from_const__msg[2] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign register_cluster__recv_data_from_const__val[2] = 1'd0;
  assign element__recv_in__msg[2] = register_cluster__send_data_to_fu__msg[2];
  assign register_cluster__send_data_to_fu__rdy[2] = element__recv_in__rdy[2];
  assign element__recv_in__val[2] = register_cluster__send_data_to_fu__val[2];
  assign register_cluster__recv_data_from_routing_crossbar__msg[3] = routing_crossbar__send_data__msg[7];
  assign routing_crossbar__send_data__rdy[7] = register_cluster__recv_data_from_routing_crossbar__rdy[3];
  assign register_cluster__recv_data_from_routing_crossbar__val[3] = routing_crossbar__send_data__val[7];
  assign register_cluster__recv_data_from_fu_crossbar__msg[3] = fu_crossbar__send_data__msg[7];
  assign fu_crossbar__send_data__rdy[7] = register_cluster__recv_data_from_fu_crossbar__rdy[3];
  assign register_cluster__recv_data_from_fu_crossbar__val[3] = fu_crossbar__send_data__val[7];
  assign register_cluster__recv_data_from_const__msg[3] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign register_cluster__recv_data_from_const__val[3] = 1'd0;
  assign element__recv_in__msg[3] = register_cluster__send_data_to_fu__msg[3];
  assign register_cluster__send_data_to_fu__rdy[3] = element__recv_in__rdy[3];
  assign element__recv_in__val[3] = register_cluster__send_data_to_fu__val[3];

endmodule


// PyMTL Component CgraRTL Definition
// Full name: CgraRTL__DataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__PredicateType_CGRAData_1_1__payload_1__predicate_1__CtrlPktType_IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74__CgraPayloadType_MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__cc89ed621b71ae36__CtrlSignalType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__NocPktType_InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d__CgraIdType_Bits4__multi_cgra_rows_3__multi_cgra_columns_3__width_2__height_2__ctrl_mem_size_16__data_mem_size_global_288__data_mem_size_per_bank_16__num_banks_per_cgra_2__num_registers_per_reg_bank_16__num_ctrl_2__total_steps_2__FunctionUnit_FlexibleFuRTL__FuList_[<class 'VectorCGRA.fu.single.AdderRTL.AdderRTL'>, <class 'VectorCGRA.fu.single.MulRTL.MulRTL'>, <class 'VectorCGRA.fu.single.LogicRTL.LogicRTL'>, <class 'VectorCGRA.fu.single.ShifterRTL.ShifterRTL'>, <class 'VectorCGRA.fu.single.PhiRTL.PhiRTL'>, <class 'VectorCGRA.fu.single.CompRTL.CompRTL'>, <class 'VectorCGRA.fu.single.BranchRTL.BranchRTL'>, <class 'VectorCGRA.fu.single.MemUnitRTL.MemUnitRTL'>, <class 'VectorCGRA.fu.single.SelRTL.SelRTL'>, <class 'VectorCGRA.fu.float.FpAddRTL.FpAddRTL'>, <class 'VectorCGRA.fu.float.FpMulRTL.FpMulRTL'>, <class 'VectorCGRA.fu.double.SeqMulAdderRTL.SeqMulAdderRTL'>, <class 'VectorCGRA.fu.vector.VectorMulComboRTL.VectorMulComboRTL'>, <class 'VectorCGRA.fu.vector.VectorAdderComboRTL.VectorAdderComboRTL'>, <class 'VectorCGRA.fu.single.NahRTL.NahRTL'>]__cgra_topology_Mesh__controller2addr_map_{0: [0, 31], 1: [32, 63], 2: [64, 95], 3: [96, 127], 4: [128, 159], 5: [160, 191], 6: [192, 223], 7: [224, 255], 8: [256, 287]}__idTo2d_map_{0: (0, 0), 1: (1, 0), 2: (2, 0), 3: (0, 1), 4: (1, 1), 5: (2, 1), 6: (0, 2), 7: (1, 2), 8: (2, 2)}__preload_data_None__is_multi_cgra_True
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/cgra/CgraRTL.py

module CgraRTL__f1d9d60478fa8731
(
  input  logic [8:0] address_lower ,
  input  logic [8:0] address_upper ,
  input  logic [3:0] cgra_id ,
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_data_on_boundary_east__msg [0:1] ,
  output logic [0:0] recv_data_on_boundary_east__rdy [0:1] ,
  input logic [0:0] recv_data_on_boundary_east__val [0:1] ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_data_on_boundary_north__msg [0:1] ,
  output logic [0:0] recv_data_on_boundary_north__rdy [0:1] ,
  input logic [0:0] recv_data_on_boundary_north__val [0:1] ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_data_on_boundary_south__msg [0:1] ,
  output logic [0:0] recv_data_on_boundary_south__rdy [0:1] ,
  input logic [0:0] recv_data_on_boundary_south__val [0:1] ,
  input CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 recv_data_on_boundary_west__msg [0:1] ,
  output logic [0:0] recv_data_on_boundary_west__rdy [0:1] ,
  input logic [0:0] recv_data_on_boundary_west__val [0:1] ,
  input IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv_from_cpu_pkt__msg  ,
  output logic [0:0] recv_from_cpu_pkt__rdy  ,
  input logic [0:0] recv_from_cpu_pkt__val  ,
  input InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv_from_inter_cgra_noc__msg  ,
  output logic [0:0] recv_from_inter_cgra_noc__rdy  ,
  input logic [0:0] recv_from_inter_cgra_noc__val  ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_data_on_boundary_east__msg [0:1] ,
  input logic [0:0] send_data_on_boundary_east__rdy [0:1] ,
  output logic [0:0] send_data_on_boundary_east__val [0:1] ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_data_on_boundary_north__msg [0:1] ,
  input logic [0:0] send_data_on_boundary_north__rdy [0:1] ,
  output logic [0:0] send_data_on_boundary_north__val [0:1] ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_data_on_boundary_south__msg [0:1] ,
  input logic [0:0] send_data_on_boundary_south__rdy [0:1] ,
  output logic [0:0] send_data_on_boundary_south__val [0:1] ,
  output CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 send_data_on_boundary_west__msg [0:1] ,
  input logic [0:0] send_data_on_boundary_west__rdy [0:1] ,
  output logic [0:0] send_data_on_boundary_west__val [0:1] ,
  output IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send_to_cpu_pkt__msg  ,
  input logic [0:0] send_to_cpu_pkt__rdy  ,
  output logic [0:0] send_to_cpu_pkt__val  ,
  output InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send_to_inter_cgra_noc__msg  ,
  input logic [0:0] send_to_inter_cgra_noc__rdy  ,
  output logic [0:0] send_to_inter_cgra_noc__val  
);
  //-------------------------------------------------------------
  // Component controller
  //-------------------------------------------------------------

  logic [3:0] controller__cgra_id;
  logic [0:0] controller__clk;
  logic [0:0] controller__reset;
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 controller__recv_from_cpu_pkt__msg;
  logic [0:0] controller__recv_from_cpu_pkt__rdy;
  logic [0:0] controller__recv_from_cpu_pkt__val;
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 controller__recv_from_ctrl_ring_pkt__msg;
  logic [0:0] controller__recv_from_ctrl_ring_pkt__rdy;
  logic [0:0] controller__recv_from_ctrl_ring_pkt__val;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d controller__recv_from_inter_cgra_noc__msg;
  logic [0:0] controller__recv_from_inter_cgra_noc__rdy;
  logic [0:0] controller__recv_from_inter_cgra_noc__val;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d controller__recv_from_tile_load_request_pkt__msg;
  logic [0:0] controller__recv_from_tile_load_request_pkt__rdy;
  logic [0:0] controller__recv_from_tile_load_request_pkt__val;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d controller__recv_from_tile_load_response_pkt__msg;
  logic [0:0] controller__recv_from_tile_load_response_pkt__rdy;
  logic [0:0] controller__recv_from_tile_load_response_pkt__val;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d controller__recv_from_tile_store_request_pkt__msg;
  logic [0:0] controller__recv_from_tile_store_request_pkt__rdy;
  logic [0:0] controller__recv_from_tile_store_request_pkt__val;
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 controller__send_to_cpu_pkt__msg;
  logic [0:0] controller__send_to_cpu_pkt__rdy;
  logic [0:0] controller__send_to_cpu_pkt__val;
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 controller__send_to_ctrl_ring_pkt__msg;
  logic [0:0] controller__send_to_ctrl_ring_pkt__rdy;
  logic [0:0] controller__send_to_ctrl_ring_pkt__val;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d controller__send_to_inter_cgra_noc__msg;
  logic [0:0] controller__send_to_inter_cgra_noc__rdy;
  logic [0:0] controller__send_to_inter_cgra_noc__val;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d controller__send_to_mem_load_request__msg;
  logic [0:0] controller__send_to_mem_load_request__rdy;
  logic [0:0] controller__send_to_mem_load_request__val;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d controller__send_to_mem_store_request__msg;
  logic [0:0] controller__send_to_mem_store_request__rdy;
  logic [0:0] controller__send_to_mem_store_request__val;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d controller__send_to_tile_load_response__msg;
  logic [0:0] controller__send_to_tile_load_response__rdy;
  logic [0:0] controller__send_to_tile_load_response__val;

  ControllerRTL__78e9e7a7dc10be49 controller
  (
    .cgra_id( controller__cgra_id ),
    .clk( controller__clk ),
    .reset( controller__reset ),
    .recv_from_cpu_pkt__msg( controller__recv_from_cpu_pkt__msg ),
    .recv_from_cpu_pkt__rdy( controller__recv_from_cpu_pkt__rdy ),
    .recv_from_cpu_pkt__val( controller__recv_from_cpu_pkt__val ),
    .recv_from_ctrl_ring_pkt__msg( controller__recv_from_ctrl_ring_pkt__msg ),
    .recv_from_ctrl_ring_pkt__rdy( controller__recv_from_ctrl_ring_pkt__rdy ),
    .recv_from_ctrl_ring_pkt__val( controller__recv_from_ctrl_ring_pkt__val ),
    .recv_from_inter_cgra_noc__msg( controller__recv_from_inter_cgra_noc__msg ),
    .recv_from_inter_cgra_noc__rdy( controller__recv_from_inter_cgra_noc__rdy ),
    .recv_from_inter_cgra_noc__val( controller__recv_from_inter_cgra_noc__val ),
    .recv_from_tile_load_request_pkt__msg( controller__recv_from_tile_load_request_pkt__msg ),
    .recv_from_tile_load_request_pkt__rdy( controller__recv_from_tile_load_request_pkt__rdy ),
    .recv_from_tile_load_request_pkt__val( controller__recv_from_tile_load_request_pkt__val ),
    .recv_from_tile_load_response_pkt__msg( controller__recv_from_tile_load_response_pkt__msg ),
    .recv_from_tile_load_response_pkt__rdy( controller__recv_from_tile_load_response_pkt__rdy ),
    .recv_from_tile_load_response_pkt__val( controller__recv_from_tile_load_response_pkt__val ),
    .recv_from_tile_store_request_pkt__msg( controller__recv_from_tile_store_request_pkt__msg ),
    .recv_from_tile_store_request_pkt__rdy( controller__recv_from_tile_store_request_pkt__rdy ),
    .recv_from_tile_store_request_pkt__val( controller__recv_from_tile_store_request_pkt__val ),
    .send_to_cpu_pkt__msg( controller__send_to_cpu_pkt__msg ),
    .send_to_cpu_pkt__rdy( controller__send_to_cpu_pkt__rdy ),
    .send_to_cpu_pkt__val( controller__send_to_cpu_pkt__val ),
    .send_to_ctrl_ring_pkt__msg( controller__send_to_ctrl_ring_pkt__msg ),
    .send_to_ctrl_ring_pkt__rdy( controller__send_to_ctrl_ring_pkt__rdy ),
    .send_to_ctrl_ring_pkt__val( controller__send_to_ctrl_ring_pkt__val ),
    .send_to_inter_cgra_noc__msg( controller__send_to_inter_cgra_noc__msg ),
    .send_to_inter_cgra_noc__rdy( controller__send_to_inter_cgra_noc__rdy ),
    .send_to_inter_cgra_noc__val( controller__send_to_inter_cgra_noc__val ),
    .send_to_mem_load_request__msg( controller__send_to_mem_load_request__msg ),
    .send_to_mem_load_request__rdy( controller__send_to_mem_load_request__rdy ),
    .send_to_mem_load_request__val( controller__send_to_mem_load_request__val ),
    .send_to_mem_store_request__msg( controller__send_to_mem_store_request__msg ),
    .send_to_mem_store_request__rdy( controller__send_to_mem_store_request__rdy ),
    .send_to_mem_store_request__val( controller__send_to_mem_store_request__val ),
    .send_to_tile_load_response__msg( controller__send_to_tile_load_response__msg ),
    .send_to_tile_load_response__rdy( controller__send_to_tile_load_response__rdy ),
    .send_to_tile_load_response__val( controller__send_to_tile_load_response__val )
  );

  //-------------------------------------------------------------
  // End of component controller
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component ctrl_ring
  //-------------------------------------------------------------

  logic [0:0] ctrl_ring__clk;
  logic [0:0] ctrl_ring__reset;
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 ctrl_ring__recv__msg [0:4];
  logic [0:0] ctrl_ring__recv__rdy [0:4];
  logic [0:0] ctrl_ring__recv__val [0:4];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 ctrl_ring__send__msg [0:4];
  logic [0:0] ctrl_ring__send__rdy [0:4];
  logic [0:0] ctrl_ring__send__val [0:4];

  RingNetworkRTL__b40416c8553f9b4d ctrl_ring
  (
    .clk( ctrl_ring__clk ),
    .reset( ctrl_ring__reset ),
    .recv__msg( ctrl_ring__recv__msg ),
    .recv__rdy( ctrl_ring__recv__rdy ),
    .recv__val( ctrl_ring__recv__val ),
    .send__msg( ctrl_ring__send__msg ),
    .send__rdy( ctrl_ring__send__rdy ),
    .send__val( ctrl_ring__send__val )
  );

  //-------------------------------------------------------------
  // End of component ctrl_ring
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component data_mem
  //-------------------------------------------------------------

  logic [8:0] data_mem__address_lower;
  logic [8:0] data_mem__address_upper;
  logic [3:0] data_mem__cgra_id;
  logic [0:0] data_mem__clk;
  logic [0:0] data_mem__reset;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d data_mem__recv_from_noc_load_request__msg;
  logic [0:0] data_mem__recv_from_noc_load_request__rdy;
  logic [0:0] data_mem__recv_from_noc_load_request__val;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d data_mem__recv_from_noc_load_response_pkt__msg;
  logic [0:0] data_mem__recv_from_noc_load_response_pkt__rdy;
  logic [0:0] data_mem__recv_from_noc_load_response_pkt__val;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d data_mem__recv_from_noc_store_request__msg;
  logic [0:0] data_mem__recv_from_noc_store_request__rdy;
  logic [0:0] data_mem__recv_from_noc_store_request__val;
  logic [8:0] data_mem__recv_raddr__msg [0:2];
  logic [0:0] data_mem__recv_raddr__rdy [0:2];
  logic [0:0] data_mem__recv_raddr__val [0:2];
  logic [8:0] data_mem__recv_waddr__msg [0:2];
  logic [0:0] data_mem__recv_waddr__rdy [0:2];
  logic [0:0] data_mem__recv_waddr__val [0:2];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 data_mem__recv_wdata__msg [0:2];
  logic [0:0] data_mem__recv_wdata__rdy [0:2];
  logic [0:0] data_mem__recv_wdata__val [0:2];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 data_mem__send_rdata__msg [0:2];
  logic [0:0] data_mem__send_rdata__rdy [0:2];
  logic [0:0] data_mem__send_rdata__val [0:2];
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d data_mem__send_to_noc_load_request_pkt__msg;
  logic [0:0] data_mem__send_to_noc_load_request_pkt__rdy;
  logic [0:0] data_mem__send_to_noc_load_request_pkt__val;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d data_mem__send_to_noc_load_response_pkt__msg;
  logic [0:0] data_mem__send_to_noc_load_response_pkt__rdy;
  logic [0:0] data_mem__send_to_noc_load_response_pkt__val;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d data_mem__send_to_noc_store_pkt__msg;
  logic [0:0] data_mem__send_to_noc_store_pkt__rdy;
  logic [0:0] data_mem__send_to_noc_store_pkt__val;

  DataMemWithCrossbarRTL__419c8a366359e511 data_mem
  (
    .address_lower( data_mem__address_lower ),
    .address_upper( data_mem__address_upper ),
    .cgra_id( data_mem__cgra_id ),
    .clk( data_mem__clk ),
    .reset( data_mem__reset ),
    .recv_from_noc_load_request__msg( data_mem__recv_from_noc_load_request__msg ),
    .recv_from_noc_load_request__rdy( data_mem__recv_from_noc_load_request__rdy ),
    .recv_from_noc_load_request__val( data_mem__recv_from_noc_load_request__val ),
    .recv_from_noc_load_response_pkt__msg( data_mem__recv_from_noc_load_response_pkt__msg ),
    .recv_from_noc_load_response_pkt__rdy( data_mem__recv_from_noc_load_response_pkt__rdy ),
    .recv_from_noc_load_response_pkt__val( data_mem__recv_from_noc_load_response_pkt__val ),
    .recv_from_noc_store_request__msg( data_mem__recv_from_noc_store_request__msg ),
    .recv_from_noc_store_request__rdy( data_mem__recv_from_noc_store_request__rdy ),
    .recv_from_noc_store_request__val( data_mem__recv_from_noc_store_request__val ),
    .recv_raddr__msg( data_mem__recv_raddr__msg ),
    .recv_raddr__rdy( data_mem__recv_raddr__rdy ),
    .recv_raddr__val( data_mem__recv_raddr__val ),
    .recv_waddr__msg( data_mem__recv_waddr__msg ),
    .recv_waddr__rdy( data_mem__recv_waddr__rdy ),
    .recv_waddr__val( data_mem__recv_waddr__val ),
    .recv_wdata__msg( data_mem__recv_wdata__msg ),
    .recv_wdata__rdy( data_mem__recv_wdata__rdy ),
    .recv_wdata__val( data_mem__recv_wdata__val ),
    .send_rdata__msg( data_mem__send_rdata__msg ),
    .send_rdata__rdy( data_mem__send_rdata__rdy ),
    .send_rdata__val( data_mem__send_rdata__val ),
    .send_to_noc_load_request_pkt__msg( data_mem__send_to_noc_load_request_pkt__msg ),
    .send_to_noc_load_request_pkt__rdy( data_mem__send_to_noc_load_request_pkt__rdy ),
    .send_to_noc_load_request_pkt__val( data_mem__send_to_noc_load_request_pkt__val ),
    .send_to_noc_load_response_pkt__msg( data_mem__send_to_noc_load_response_pkt__msg ),
    .send_to_noc_load_response_pkt__rdy( data_mem__send_to_noc_load_response_pkt__rdy ),
    .send_to_noc_load_response_pkt__val( data_mem__send_to_noc_load_response_pkt__val ),
    .send_to_noc_store_pkt__msg( data_mem__send_to_noc_store_pkt__msg ),
    .send_to_noc_store_pkt__rdy( data_mem__send_to_noc_store_pkt__rdy ),
    .send_to_noc_store_pkt__val( data_mem__send_to_noc_store_pkt__val )
  );

  //-------------------------------------------------------------
  // End of component data_mem
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component tile[0:3]
  //-------------------------------------------------------------

  logic [3:0] tile__cgra_id [0:3];
  logic [0:0] tile__clk [0:3];
  logic [0:0] tile__reset [0:3];
  logic [2:0] tile__tile_id [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 tile__from_mem_rdata__msg [0:3];
  logic [0:0] tile__from_mem_rdata__rdy [0:3];
  logic [0:0] tile__from_mem_rdata__val [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 tile__recv_data__msg [0:3][0:3];
  logic [0:0] tile__recv_data__rdy [0:3][0:3];
  logic [0:0] tile__recv_data__val [0:3][0:3];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 tile__recv_from_controller_pkt__msg [0:3];
  logic [0:0] tile__recv_from_controller_pkt__rdy [0:3];
  logic [0:0] tile__recv_from_controller_pkt__val [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 tile__send_data__msg [0:3][0:3];
  logic [0:0] tile__send_data__rdy [0:3][0:3];
  logic [0:0] tile__send_data__val [0:3][0:3];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 tile__send_to_controller_pkt__msg [0:3];
  logic [0:0] tile__send_to_controller_pkt__rdy [0:3];
  logic [0:0] tile__send_to_controller_pkt__val [0:3];
  logic [8:0] tile__to_mem_raddr__msg [0:3];
  logic [0:0] tile__to_mem_raddr__rdy [0:3];
  logic [0:0] tile__to_mem_raddr__val [0:3];
  logic [8:0] tile__to_mem_waddr__msg [0:3];
  logic [0:0] tile__to_mem_waddr__rdy [0:3];
  logic [0:0] tile__to_mem_waddr__val [0:3];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 tile__to_mem_wdata__msg [0:3];
  logic [0:0] tile__to_mem_wdata__rdy [0:3];
  logic [0:0] tile__to_mem_wdata__val [0:3];

  TileRTL__2a4c76f35d70369f tile__0
  (
    .cgra_id( tile__cgra_id[0] ),
    .clk( tile__clk[0] ),
    .reset( tile__reset[0] ),
    .tile_id( tile__tile_id[0] ),
    .from_mem_rdata__msg( tile__from_mem_rdata__msg[0] ),
    .from_mem_rdata__rdy( tile__from_mem_rdata__rdy[0] ),
    .from_mem_rdata__val( tile__from_mem_rdata__val[0] ),
    .recv_data__msg( tile__recv_data__msg[0] ),
    .recv_data__rdy( tile__recv_data__rdy[0] ),
    .recv_data__val( tile__recv_data__val[0] ),
    .recv_from_controller_pkt__msg( tile__recv_from_controller_pkt__msg[0] ),
    .recv_from_controller_pkt__rdy( tile__recv_from_controller_pkt__rdy[0] ),
    .recv_from_controller_pkt__val( tile__recv_from_controller_pkt__val[0] ),
    .send_data__msg( tile__send_data__msg[0] ),
    .send_data__rdy( tile__send_data__rdy[0] ),
    .send_data__val( tile__send_data__val[0] ),
    .send_to_controller_pkt__msg( tile__send_to_controller_pkt__msg[0] ),
    .send_to_controller_pkt__rdy( tile__send_to_controller_pkt__rdy[0] ),
    .send_to_controller_pkt__val( tile__send_to_controller_pkt__val[0] ),
    .to_mem_raddr__msg( tile__to_mem_raddr__msg[0] ),
    .to_mem_raddr__rdy( tile__to_mem_raddr__rdy[0] ),
    .to_mem_raddr__val( tile__to_mem_raddr__val[0] ),
    .to_mem_waddr__msg( tile__to_mem_waddr__msg[0] ),
    .to_mem_waddr__rdy( tile__to_mem_waddr__rdy[0] ),
    .to_mem_waddr__val( tile__to_mem_waddr__val[0] ),
    .to_mem_wdata__msg( tile__to_mem_wdata__msg[0] ),
    .to_mem_wdata__rdy( tile__to_mem_wdata__rdy[0] ),
    .to_mem_wdata__val( tile__to_mem_wdata__val[0] )
  );

  TileRTL__2a4c76f35d70369f tile__1
  (
    .cgra_id( tile__cgra_id[1] ),
    .clk( tile__clk[1] ),
    .reset( tile__reset[1] ),
    .tile_id( tile__tile_id[1] ),
    .from_mem_rdata__msg( tile__from_mem_rdata__msg[1] ),
    .from_mem_rdata__rdy( tile__from_mem_rdata__rdy[1] ),
    .from_mem_rdata__val( tile__from_mem_rdata__val[1] ),
    .recv_data__msg( tile__recv_data__msg[1] ),
    .recv_data__rdy( tile__recv_data__rdy[1] ),
    .recv_data__val( tile__recv_data__val[1] ),
    .recv_from_controller_pkt__msg( tile__recv_from_controller_pkt__msg[1] ),
    .recv_from_controller_pkt__rdy( tile__recv_from_controller_pkt__rdy[1] ),
    .recv_from_controller_pkt__val( tile__recv_from_controller_pkt__val[1] ),
    .send_data__msg( tile__send_data__msg[1] ),
    .send_data__rdy( tile__send_data__rdy[1] ),
    .send_data__val( tile__send_data__val[1] ),
    .send_to_controller_pkt__msg( tile__send_to_controller_pkt__msg[1] ),
    .send_to_controller_pkt__rdy( tile__send_to_controller_pkt__rdy[1] ),
    .send_to_controller_pkt__val( tile__send_to_controller_pkt__val[1] ),
    .to_mem_raddr__msg( tile__to_mem_raddr__msg[1] ),
    .to_mem_raddr__rdy( tile__to_mem_raddr__rdy[1] ),
    .to_mem_raddr__val( tile__to_mem_raddr__val[1] ),
    .to_mem_waddr__msg( tile__to_mem_waddr__msg[1] ),
    .to_mem_waddr__rdy( tile__to_mem_waddr__rdy[1] ),
    .to_mem_waddr__val( tile__to_mem_waddr__val[1] ),
    .to_mem_wdata__msg( tile__to_mem_wdata__msg[1] ),
    .to_mem_wdata__rdy( tile__to_mem_wdata__rdy[1] ),
    .to_mem_wdata__val( tile__to_mem_wdata__val[1] )
  );

  TileRTL__2a4c76f35d70369f tile__2
  (
    .cgra_id( tile__cgra_id[2] ),
    .clk( tile__clk[2] ),
    .reset( tile__reset[2] ),
    .tile_id( tile__tile_id[2] ),
    .from_mem_rdata__msg( tile__from_mem_rdata__msg[2] ),
    .from_mem_rdata__rdy( tile__from_mem_rdata__rdy[2] ),
    .from_mem_rdata__val( tile__from_mem_rdata__val[2] ),
    .recv_data__msg( tile__recv_data__msg[2] ),
    .recv_data__rdy( tile__recv_data__rdy[2] ),
    .recv_data__val( tile__recv_data__val[2] ),
    .recv_from_controller_pkt__msg( tile__recv_from_controller_pkt__msg[2] ),
    .recv_from_controller_pkt__rdy( tile__recv_from_controller_pkt__rdy[2] ),
    .recv_from_controller_pkt__val( tile__recv_from_controller_pkt__val[2] ),
    .send_data__msg( tile__send_data__msg[2] ),
    .send_data__rdy( tile__send_data__rdy[2] ),
    .send_data__val( tile__send_data__val[2] ),
    .send_to_controller_pkt__msg( tile__send_to_controller_pkt__msg[2] ),
    .send_to_controller_pkt__rdy( tile__send_to_controller_pkt__rdy[2] ),
    .send_to_controller_pkt__val( tile__send_to_controller_pkt__val[2] ),
    .to_mem_raddr__msg( tile__to_mem_raddr__msg[2] ),
    .to_mem_raddr__rdy( tile__to_mem_raddr__rdy[2] ),
    .to_mem_raddr__val( tile__to_mem_raddr__val[2] ),
    .to_mem_waddr__msg( tile__to_mem_waddr__msg[2] ),
    .to_mem_waddr__rdy( tile__to_mem_waddr__rdy[2] ),
    .to_mem_waddr__val( tile__to_mem_waddr__val[2] ),
    .to_mem_wdata__msg( tile__to_mem_wdata__msg[2] ),
    .to_mem_wdata__rdy( tile__to_mem_wdata__rdy[2] ),
    .to_mem_wdata__val( tile__to_mem_wdata__val[2] )
  );

  TileRTL__2a4c76f35d70369f tile__3
  (
    .cgra_id( tile__cgra_id[3] ),
    .clk( tile__clk[3] ),
    .reset( tile__reset[3] ),
    .tile_id( tile__tile_id[3] ),
    .from_mem_rdata__msg( tile__from_mem_rdata__msg[3] ),
    .from_mem_rdata__rdy( tile__from_mem_rdata__rdy[3] ),
    .from_mem_rdata__val( tile__from_mem_rdata__val[3] ),
    .recv_data__msg( tile__recv_data__msg[3] ),
    .recv_data__rdy( tile__recv_data__rdy[3] ),
    .recv_data__val( tile__recv_data__val[3] ),
    .recv_from_controller_pkt__msg( tile__recv_from_controller_pkt__msg[3] ),
    .recv_from_controller_pkt__rdy( tile__recv_from_controller_pkt__rdy[3] ),
    .recv_from_controller_pkt__val( tile__recv_from_controller_pkt__val[3] ),
    .send_data__msg( tile__send_data__msg[3] ),
    .send_data__rdy( tile__send_data__rdy[3] ),
    .send_data__val( tile__send_data__val[3] ),
    .send_to_controller_pkt__msg( tile__send_to_controller_pkt__msg[3] ),
    .send_to_controller_pkt__rdy( tile__send_to_controller_pkt__rdy[3] ),
    .send_to_controller_pkt__val( tile__send_to_controller_pkt__val[3] ),
    .to_mem_raddr__msg( tile__to_mem_raddr__msg[3] ),
    .to_mem_raddr__rdy( tile__to_mem_raddr__rdy[3] ),
    .to_mem_raddr__val( tile__to_mem_raddr__val[3] ),
    .to_mem_waddr__msg( tile__to_mem_waddr__msg[3] ),
    .to_mem_waddr__rdy( tile__to_mem_waddr__rdy[3] ),
    .to_mem_waddr__val( tile__to_mem_waddr__val[3] ),
    .to_mem_wdata__msg( tile__to_mem_wdata__msg[3] ),
    .to_mem_wdata__rdy( tile__to_mem_wdata__rdy[3] ),
    .to_mem_wdata__val( tile__to_mem_wdata__val[3] )
  );

  //-------------------------------------------------------------
  // End of component tile[0:3]
  //-------------------------------------------------------------

  assign tile__clk[0] = clk;
  assign tile__reset[0] = reset;
  assign tile__clk[1] = clk;
  assign tile__reset[1] = reset;
  assign tile__clk[2] = clk;
  assign tile__reset[2] = reset;
  assign tile__clk[3] = clk;
  assign tile__reset[3] = reset;
  assign data_mem__clk = clk;
  assign data_mem__reset = reset;
  assign controller__clk = clk;
  assign controller__reset = reset;
  assign ctrl_ring__clk = clk;
  assign ctrl_ring__reset = reset;
  assign controller__cgra_id = cgra_id;
  assign data_mem__cgra_id = cgra_id;
  assign data_mem__address_lower = address_lower;
  assign data_mem__address_upper = address_upper;
  assign data_mem__recv_from_noc_load_request__msg = controller__send_to_mem_load_request__msg;
  assign controller__send_to_mem_load_request__rdy = data_mem__recv_from_noc_load_request__rdy;
  assign data_mem__recv_from_noc_load_request__val = controller__send_to_mem_load_request__val;
  assign data_mem__recv_from_noc_store_request__msg = controller__send_to_mem_store_request__msg;
  assign controller__send_to_mem_store_request__rdy = data_mem__recv_from_noc_store_request__rdy;
  assign data_mem__recv_from_noc_store_request__val = controller__send_to_mem_store_request__val;
  assign data_mem__recv_from_noc_load_response_pkt__msg = controller__send_to_tile_load_response__msg;
  assign controller__send_to_tile_load_response__rdy = data_mem__recv_from_noc_load_response_pkt__rdy;
  assign data_mem__recv_from_noc_load_response_pkt__val = controller__send_to_tile_load_response__val;
  assign controller__recv_from_tile_load_request_pkt__msg = data_mem__send_to_noc_load_request_pkt__msg;
  assign data_mem__send_to_noc_load_request_pkt__rdy = controller__recv_from_tile_load_request_pkt__rdy;
  assign controller__recv_from_tile_load_request_pkt__val = data_mem__send_to_noc_load_request_pkt__val;
  assign controller__recv_from_tile_load_response_pkt__msg = data_mem__send_to_noc_load_response_pkt__msg;
  assign data_mem__send_to_noc_load_response_pkt__rdy = controller__recv_from_tile_load_response_pkt__rdy;
  assign controller__recv_from_tile_load_response_pkt__val = data_mem__send_to_noc_load_response_pkt__val;
  assign controller__recv_from_tile_store_request_pkt__msg = data_mem__send_to_noc_store_pkt__msg;
  assign data_mem__send_to_noc_store_pkt__rdy = controller__recv_from_tile_store_request_pkt__rdy;
  assign controller__recv_from_tile_store_request_pkt__val = data_mem__send_to_noc_store_pkt__val;
  assign controller__recv_from_inter_cgra_noc__msg = recv_from_inter_cgra_noc__msg;
  assign recv_from_inter_cgra_noc__rdy = controller__recv_from_inter_cgra_noc__rdy;
  assign controller__recv_from_inter_cgra_noc__val = recv_from_inter_cgra_noc__val;
  assign send_to_inter_cgra_noc__msg = controller__send_to_inter_cgra_noc__msg;
  assign controller__send_to_inter_cgra_noc__rdy = send_to_inter_cgra_noc__rdy;
  assign send_to_inter_cgra_noc__val = controller__send_to_inter_cgra_noc__val;
  assign controller__recv_from_cpu_pkt__msg = recv_from_cpu_pkt__msg;
  assign recv_from_cpu_pkt__rdy = controller__recv_from_cpu_pkt__rdy;
  assign controller__recv_from_cpu_pkt__val = recv_from_cpu_pkt__val;
  assign send_to_cpu_pkt__msg = controller__send_to_cpu_pkt__msg;
  assign controller__send_to_cpu_pkt__rdy = send_to_cpu_pkt__rdy;
  assign send_to_cpu_pkt__val = controller__send_to_cpu_pkt__val;
  assign tile__tile_id[0] = 3'd0;
  assign tile__cgra_id[0] = cgra_id;
  assign tile__tile_id[1] = 3'd1;
  assign tile__cgra_id[1] = cgra_id;
  assign tile__tile_id[2] = 3'd2;
  assign tile__cgra_id[2] = cgra_id;
  assign tile__tile_id[3] = 3'd3;
  assign tile__cgra_id[3] = cgra_id;
  assign tile__recv_from_controller_pkt__msg[0] = ctrl_ring__send__msg[0];
  assign ctrl_ring__send__rdy[0] = tile__recv_from_controller_pkt__rdy[0];
  assign tile__recv_from_controller_pkt__val[0] = ctrl_ring__send__val[0];
  assign tile__recv_from_controller_pkt__msg[1] = ctrl_ring__send__msg[1];
  assign ctrl_ring__send__rdy[1] = tile__recv_from_controller_pkt__rdy[1];
  assign tile__recv_from_controller_pkt__val[1] = ctrl_ring__send__val[1];
  assign tile__recv_from_controller_pkt__msg[2] = ctrl_ring__send__msg[2];
  assign ctrl_ring__send__rdy[2] = tile__recv_from_controller_pkt__rdy[2];
  assign tile__recv_from_controller_pkt__val[2] = ctrl_ring__send__val[2];
  assign tile__recv_from_controller_pkt__msg[3] = ctrl_ring__send__msg[3];
  assign ctrl_ring__send__rdy[3] = tile__recv_from_controller_pkt__rdy[3];
  assign tile__recv_from_controller_pkt__val[3] = ctrl_ring__send__val[3];
  assign controller__recv_from_ctrl_ring_pkt__msg = ctrl_ring__send__msg[4];
  assign ctrl_ring__send__rdy[4] = controller__recv_from_ctrl_ring_pkt__rdy;
  assign controller__recv_from_ctrl_ring_pkt__val = ctrl_ring__send__val[4];
  assign ctrl_ring__recv__msg[0] = tile__send_to_controller_pkt__msg[0];
  assign tile__send_to_controller_pkt__rdy[0] = ctrl_ring__recv__rdy[0];
  assign ctrl_ring__recv__val[0] = tile__send_to_controller_pkt__val[0];
  assign ctrl_ring__recv__msg[1] = tile__send_to_controller_pkt__msg[1];
  assign tile__send_to_controller_pkt__rdy[1] = ctrl_ring__recv__rdy[1];
  assign ctrl_ring__recv__val[1] = tile__send_to_controller_pkt__val[1];
  assign ctrl_ring__recv__msg[2] = tile__send_to_controller_pkt__msg[2];
  assign tile__send_to_controller_pkt__rdy[2] = ctrl_ring__recv__rdy[2];
  assign ctrl_ring__recv__val[2] = tile__send_to_controller_pkt__val[2];
  assign ctrl_ring__recv__msg[3] = tile__send_to_controller_pkt__msg[3];
  assign tile__send_to_controller_pkt__rdy[3] = ctrl_ring__recv__rdy[3];
  assign ctrl_ring__recv__val[3] = tile__send_to_controller_pkt__val[3];
  assign ctrl_ring__recv__msg[4] = controller__send_to_ctrl_ring_pkt__msg;
  assign controller__send_to_ctrl_ring_pkt__rdy = ctrl_ring__recv__rdy[4];
  assign ctrl_ring__recv__val[4] = controller__send_to_ctrl_ring_pkt__val;
  assign tile__recv_data__msg[2][1] = tile__send_data__msg[0][0];
  assign tile__send_data__rdy[0][0] = tile__recv_data__rdy[2][1];
  assign tile__recv_data__val[2][1] = tile__send_data__val[0][0];
  assign tile__recv_data__msg[1][2] = tile__send_data__msg[0][3];
  assign tile__send_data__rdy[0][3] = tile__recv_data__rdy[1][2];
  assign tile__recv_data__val[1][2] = tile__send_data__val[0][3];
  assign send_data_on_boundary_south__msg[0] = tile__send_data__msg[0][1];
  assign tile__send_data__rdy[0][1] = send_data_on_boundary_south__rdy[0];
  assign send_data_on_boundary_south__val[0] = tile__send_data__val[0][1];
  assign tile__recv_data__msg[0][1] = recv_data_on_boundary_south__msg[0];
  assign recv_data_on_boundary_south__rdy[0] = tile__recv_data__rdy[0][1];
  assign tile__recv_data__val[0][1] = recv_data_on_boundary_south__val[0];
  assign send_data_on_boundary_west__msg[0] = tile__send_data__msg[0][2];
  assign tile__send_data__rdy[0][2] = send_data_on_boundary_west__rdy[0];
  assign send_data_on_boundary_west__val[0] = tile__send_data__val[0][2];
  assign tile__recv_data__msg[0][2] = recv_data_on_boundary_west__msg[0];
  assign recv_data_on_boundary_west__rdy[0] = tile__recv_data__rdy[0][2];
  assign tile__recv_data__val[0][2] = recv_data_on_boundary_west__val[0];
  assign data_mem__recv_raddr__msg[0] = tile__to_mem_raddr__msg[0];
  assign tile__to_mem_raddr__rdy[0] = data_mem__recv_raddr__rdy[0];
  assign data_mem__recv_raddr__val[0] = tile__to_mem_raddr__val[0];
  assign tile__from_mem_rdata__msg[0] = data_mem__send_rdata__msg[0];
  assign data_mem__send_rdata__rdy[0] = tile__from_mem_rdata__rdy[0];
  assign tile__from_mem_rdata__val[0] = data_mem__send_rdata__val[0];
  assign data_mem__recv_waddr__msg[0] = tile__to_mem_waddr__msg[0];
  assign tile__to_mem_waddr__rdy[0] = data_mem__recv_waddr__rdy[0];
  assign data_mem__recv_waddr__val[0] = tile__to_mem_waddr__val[0];
  assign data_mem__recv_wdata__msg[0] = tile__to_mem_wdata__msg[0];
  assign tile__to_mem_wdata__rdy[0] = data_mem__recv_wdata__rdy[0];
  assign data_mem__recv_wdata__val[0] = tile__to_mem_wdata__val[0];
  assign tile__recv_data__msg[3][1] = tile__send_data__msg[1][0];
  assign tile__send_data__rdy[1][0] = tile__recv_data__rdy[3][1];
  assign tile__recv_data__val[3][1] = tile__send_data__val[1][0];
  assign tile__recv_data__msg[0][3] = tile__send_data__msg[1][2];
  assign tile__send_data__rdy[1][2] = tile__recv_data__rdy[0][3];
  assign tile__recv_data__val[0][3] = tile__send_data__val[1][2];
  assign send_data_on_boundary_south__msg[1] = tile__send_data__msg[1][1];
  assign tile__send_data__rdy[1][1] = send_data_on_boundary_south__rdy[1];
  assign send_data_on_boundary_south__val[1] = tile__send_data__val[1][1];
  assign tile__recv_data__msg[1][1] = recv_data_on_boundary_south__msg[1];
  assign recv_data_on_boundary_south__rdy[1] = tile__recv_data__rdy[1][1];
  assign tile__recv_data__val[1][1] = recv_data_on_boundary_south__val[1];
  assign send_data_on_boundary_east__msg[0] = tile__send_data__msg[1][3];
  assign tile__send_data__rdy[1][3] = send_data_on_boundary_east__rdy[0];
  assign send_data_on_boundary_east__val[0] = tile__send_data__val[1][3];
  assign tile__recv_data__msg[1][3] = recv_data_on_boundary_east__msg[0];
  assign recv_data_on_boundary_east__rdy[0] = tile__recv_data__rdy[1][3];
  assign tile__recv_data__val[1][3] = recv_data_on_boundary_east__val[0];
  assign data_mem__recv_raddr__msg[1] = tile__to_mem_raddr__msg[1];
  assign tile__to_mem_raddr__rdy[1] = data_mem__recv_raddr__rdy[1];
  assign data_mem__recv_raddr__val[1] = tile__to_mem_raddr__val[1];
  assign tile__from_mem_rdata__msg[1] = data_mem__send_rdata__msg[1];
  assign data_mem__send_rdata__rdy[1] = tile__from_mem_rdata__rdy[1];
  assign tile__from_mem_rdata__val[1] = data_mem__send_rdata__val[1];
  assign data_mem__recv_waddr__msg[1] = tile__to_mem_waddr__msg[1];
  assign tile__to_mem_waddr__rdy[1] = data_mem__recv_waddr__rdy[1];
  assign data_mem__recv_waddr__val[1] = tile__to_mem_waddr__val[1];
  assign data_mem__recv_wdata__msg[1] = tile__to_mem_wdata__msg[1];
  assign tile__to_mem_wdata__rdy[1] = data_mem__recv_wdata__rdy[1];
  assign data_mem__recv_wdata__val[1] = tile__to_mem_wdata__val[1];
  assign tile__recv_data__msg[0][0] = tile__send_data__msg[2][1];
  assign tile__send_data__rdy[2][1] = tile__recv_data__rdy[0][0];
  assign tile__recv_data__val[0][0] = tile__send_data__val[2][1];
  assign tile__recv_data__msg[3][2] = tile__send_data__msg[2][3];
  assign tile__send_data__rdy[2][3] = tile__recv_data__rdy[3][2];
  assign tile__recv_data__val[3][2] = tile__send_data__val[2][3];
  assign send_data_on_boundary_north__msg[0] = tile__send_data__msg[2][0];
  assign tile__send_data__rdy[2][0] = send_data_on_boundary_north__rdy[0];
  assign send_data_on_boundary_north__val[0] = tile__send_data__val[2][0];
  assign tile__recv_data__msg[2][0] = recv_data_on_boundary_north__msg[0];
  assign recv_data_on_boundary_north__rdy[0] = tile__recv_data__rdy[2][0];
  assign tile__recv_data__val[2][0] = recv_data_on_boundary_north__val[0];
  assign send_data_on_boundary_west__msg[1] = tile__send_data__msg[2][2];
  assign tile__send_data__rdy[2][2] = send_data_on_boundary_west__rdy[1];
  assign send_data_on_boundary_west__val[1] = tile__send_data__val[2][2];
  assign tile__recv_data__msg[2][2] = recv_data_on_boundary_west__msg[1];
  assign recv_data_on_boundary_west__rdy[1] = tile__recv_data__rdy[2][2];
  assign tile__recv_data__val[2][2] = recv_data_on_boundary_west__val[1];
  assign data_mem__recv_raddr__msg[2] = tile__to_mem_raddr__msg[2];
  assign tile__to_mem_raddr__rdy[2] = data_mem__recv_raddr__rdy[2];
  assign data_mem__recv_raddr__val[2] = tile__to_mem_raddr__val[2];
  assign tile__from_mem_rdata__msg[2] = data_mem__send_rdata__msg[2];
  assign data_mem__send_rdata__rdy[2] = tile__from_mem_rdata__rdy[2];
  assign tile__from_mem_rdata__val[2] = data_mem__send_rdata__val[2];
  assign data_mem__recv_waddr__msg[2] = tile__to_mem_waddr__msg[2];
  assign tile__to_mem_waddr__rdy[2] = data_mem__recv_waddr__rdy[2];
  assign data_mem__recv_waddr__val[2] = tile__to_mem_waddr__val[2];
  assign data_mem__recv_wdata__msg[2] = tile__to_mem_wdata__msg[2];
  assign tile__to_mem_wdata__rdy[2] = data_mem__recv_wdata__rdy[2];
  assign data_mem__recv_wdata__val[2] = tile__to_mem_wdata__val[2];
  assign tile__recv_data__msg[1][0] = tile__send_data__msg[3][1];
  assign tile__send_data__rdy[3][1] = tile__recv_data__rdy[1][0];
  assign tile__recv_data__val[1][0] = tile__send_data__val[3][1];
  assign tile__recv_data__msg[2][3] = tile__send_data__msg[3][2];
  assign tile__send_data__rdy[3][2] = tile__recv_data__rdy[2][3];
  assign tile__recv_data__val[2][3] = tile__send_data__val[3][2];
  assign send_data_on_boundary_north__msg[1] = tile__send_data__msg[3][0];
  assign tile__send_data__rdy[3][0] = send_data_on_boundary_north__rdy[1];
  assign send_data_on_boundary_north__val[1] = tile__send_data__val[3][0];
  assign tile__recv_data__msg[3][0] = recv_data_on_boundary_north__msg[1];
  assign recv_data_on_boundary_north__rdy[1] = tile__recv_data__rdy[3][0];
  assign tile__recv_data__val[3][0] = recv_data_on_boundary_north__val[1];
  assign send_data_on_boundary_east__msg[1] = tile__send_data__msg[3][3];
  assign tile__send_data__rdy[3][3] = send_data_on_boundary_east__rdy[1];
  assign send_data_on_boundary_east__val[1] = tile__send_data__val[3][3];
  assign tile__recv_data__msg[3][3] = recv_data_on_boundary_east__msg[1];
  assign recv_data_on_boundary_east__rdy[1] = tile__recv_data__rdy[3][3];
  assign tile__recv_data__val[3][3] = recv_data_on_boundary_east__val[1];
  assign tile__to_mem_raddr__rdy[3] = 1'd0;
  assign tile__from_mem_rdata__val[3] = 1'd0;
  assign tile__from_mem_rdata__msg[3] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign tile__to_mem_waddr__rdy[3] = 1'd0;
  assign tile__to_mem_wdata__rdy[3] = 1'd0;

endmodule


// PyMTL Component InputUnitRTL Definition
// Full name: InputUnitRTL__PacketType_InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d__QueueType_NormalQueueRTL
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/InputUnitRTL.py

module InputUnitRTL__53a3bf15fecaa9e5
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [1:0] queue__count;
  logic [0:0] queue__reset;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d queue__recv__msg;
  logic [0:0] queue__recv__rdy;
  logic [0:0] queue__recv__val;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d queue__send__msg;
  logic [0:0] queue__send__rdy;
  logic [0:0] queue__send__val;

  NormalQueueRTL__434823ce8c67ae61 queue
  (
    .clk( queue__clk ),
    .count( queue__count ),
    .reset( queue__reset ),
    .recv__msg( queue__recv__msg ),
    .recv__rdy( queue__recv__rdy ),
    .recv__val( queue__recv__val ),
    .send__msg( queue__send__msg ),
    .send__rdy( queue__send__rdy ),
    .send__val( queue__send__val )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__recv__msg = recv__msg;
  assign recv__rdy = queue__recv__rdy;
  assign queue__recv__val = recv__val;
  assign send__msg = queue__send__msg;
  assign queue__send__rdy = send__rdy;
  assign send__val = queue__send__val;

endmodule


// PyMTL Component OutputUnitRTL Definition
// Full name: OutputUnitRTL__PacketType_InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d__QueueType_None
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/OutputUnitRTL.py

module OutputUnitRTL__1a67861a3fc29f7f
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);

  assign send__msg = recv__msg;
  assign recv__rdy = send__rdy;
  assign send__val = recv__val;

endmodule


// PyMTL Component DORYMeshRouteUnitRTL Definition
// Full name: DORYMeshRouteUnitRTL__MsgType_InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d__PositionType_MeshPosition_3x3__pos_x_2__pos_y_2__num_outports_5
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/meshnet/DORYMeshRouteUnitRTL.py

module DORYMeshRouteUnitRTL__2004b86ce9e9786e
(
  input  logic [0:0] clk ,
  input  MeshPosition_3x3__pos_x_2__pos_y_2 pos ,
  input  logic [0:0] reset ,
  input InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send__msg [0:4] ,
  input logic [0:0] send__rdy [0:4] ,
  output logic [0:0] send__val [0:4] 
);
  localparam logic [2:0] __const__num_outports_at_up_ru_routing  = 3'd5;
  localparam logic [2:0] __const__SELF  = 3'd4;
  localparam logic [0:0] __const__SOUTH  = 1'd1;
  localparam logic [0:0] __const__NORTH  = 1'd0;
  localparam logic [1:0] __const__WEST  = 2'd2;
  localparam logic [1:0] __const__EAST  = 2'd3;
  logic [2:0] out_dir;
  logic [4:0] send_rdy;

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/meshnet/DORYMeshRouteUnitRTL.py:57
  // @update
  // def up_ru_recv_rdy():
  //   s.recv.rdy @= s.send_rdy[ s.out_dir ]
  
  always_comb begin : up_ru_recv_rdy
    recv__rdy = send_rdy[out_dir];
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/meshnet/DORYMeshRouteUnitRTL.py:38
  // @update
  // def up_ru_routing():
  //   s.out_dir @= Bits3(0)
  //   for i in range( num_outports ):
  //     s.send[i].val @= Bits1(0)
  // 
  //   if s.recv.val:
  //     if (s.pos.pos_x == s.recv.msg.dst_x) & (s.pos.pos_y == s.recv.msg.dst_y):
  //       s.out_dir @= SELF
  //     elif s.recv.msg.dst_y < s.pos.pos_y:
  //       s.out_dir @= SOUTH
  //     elif s.recv.msg.dst_y > s.pos.pos_y:
  //       s.out_dir @= NORTH
  //     elif s.recv.msg.dst_x < s.pos.pos_x:
  //       s.out_dir @= WEST
  //     else:
  //       s.out_dir @= EAST
  //     s.send[ s.out_dir ].val @= Bits1(1)
  
  always_comb begin : up_ru_routing
    out_dir = 3'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_outports_at_up_ru_routing ); i += 1'd1 )
      send__val[3'(i)] = 1'd0;
    if ( recv__val ) begin
      if ( ( pos.pos_x == recv__msg.dst_x ) & ( pos.pos_y == recv__msg.dst_y ) ) begin
        out_dir = 3'( __const__SELF );
      end
      else if ( recv__msg.dst_y < pos.pos_y ) begin
        out_dir = 3'( __const__SOUTH );
      end
      else if ( recv__msg.dst_y > pos.pos_y ) begin
        out_dir = 3'( __const__NORTH );
      end
      else if ( recv__msg.dst_x < pos.pos_x ) begin
        out_dir = 3'( __const__WEST );
      end
      else
        out_dir = 3'( __const__EAST );
      send__val[out_dir] = 1'd1;
    end
  end

  assign send__msg[0] = recv__msg;
  assign send_rdy[0:0] = send__rdy[0];
  assign send__msg[1] = recv__msg;
  assign send_rdy[1:1] = send__rdy[1];
  assign send__msg[2] = recv__msg;
  assign send_rdy[2:2] = send__rdy[2];
  assign send__msg[3] = recv__msg;
  assign send_rdy[3:3] = send__rdy[3];
  assign send__msg[4] = recv__msg;
  assign send_rdy[4:4] = send__rdy[4];

endmodule


// PyMTL Component Mux Definition
// Full name: Mux__Type_InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d__ninputs_5
// At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py

module Mux__2059d549833c6c33
(
  input  logic [0:0] clk ,
  input  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d in_ [0:4],
  output InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d out ,
  input  logic [0:0] reset ,
  input  logic [2:0] sel 
);

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/cgra_venv/lib/python3.12/site-packages/pymtl3/stdlib/primitive/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component SwitchUnitRTL Definition
// Full name: SwitchUnitRTL__PacketType_InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d__num_inports_5
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py

module SwitchUnitRTL__1b55f2b824e197a8
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv__msg [0:4] ,
  output logic [0:0] recv__rdy [0:4] ,
  input logic [0:0] recv__val [0:4] ,
  output InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  localparam logic [2:0] __const__num_inports_at_up_get_en  = 3'd5;
  //-------------------------------------------------------------
  // Component arbiter
  //-------------------------------------------------------------

  logic [0:0] arbiter__clk;
  logic [0:0] arbiter__en;
  logic [4:0] arbiter__grants;
  logic [4:0] arbiter__reqs;
  logic [0:0] arbiter__reset;

  RoundRobinArbiterEn__nreqs_5 arbiter
  (
    .clk( arbiter__clk ),
    .en( arbiter__en ),
    .grants( arbiter__grants ),
    .reqs( arbiter__reqs ),
    .reset( arbiter__reset )
  );

  //-------------------------------------------------------------
  // End of component arbiter
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component encoder
  //-------------------------------------------------------------

  logic [0:0] encoder__clk;
  logic [4:0] encoder__in_;
  logic [2:0] encoder__out;
  logic [0:0] encoder__reset;

  Encoder__in_nbits_5__out_nbits_3 encoder
  (
    .clk( encoder__clk ),
    .in_( encoder__in_ ),
    .out( encoder__out ),
    .reset( encoder__reset )
  );

  //-------------------------------------------------------------
  // End of component encoder
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mux
  //-------------------------------------------------------------

  logic [0:0] mux__clk;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d mux__in_ [0:4];
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d mux__out;
  logic [0:0] mux__reset;
  logic [2:0] mux__sel;

  Mux__2059d549833c6c33 mux
  (
    .clk( mux__clk ),
    .in_( mux__in_ ),
    .out( mux__out ),
    .reset( mux__reset ),
    .sel( mux__sel )
  );

  //-------------------------------------------------------------
  // End of component mux
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py:56
  // @update
  // def up_get_en():
  //   for i in range( num_inports ):
  //     s.recv[i].rdy @= s.send.rdy & ( s.mux.sel == i )
  
  always_comb begin : up_get_en
    for ( int unsigned i = 1'd0; i < 3'( __const__num_inports_at_up_get_en ); i += 1'd1 )
      recv__rdy[3'(i)] = send__rdy & ( mux__sel == 3'(i) );
  end

  // PyMTL Update Block Source
  // At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/router/SwitchUnitRTL.py:51
  // @update
  // def up_send_val():
  //   s.send.val @= s.arbiter.grants > 0
  
  always_comb begin : up_send_val
    send__val = arbiter__grants > 5'd0;
  end

  assign arbiter__clk = clk;
  assign arbiter__reset = reset;
  assign arbiter__en = 1'd1;
  assign mux__clk = clk;
  assign mux__reset = reset;
  assign send__msg = mux__out;
  assign encoder__clk = clk;
  assign encoder__reset = reset;
  assign encoder__in_ = arbiter__grants;
  assign mux__sel = encoder__out;
  assign arbiter__reqs[0:0] = recv__val[0];
  assign mux__in_[0] = recv__msg[0];
  assign arbiter__reqs[1:1] = recv__val[1];
  assign mux__in_[1] = recv__msg[1];
  assign arbiter__reqs[2:2] = recv__val[2];
  assign mux__in_[2] = recv__msg[2];
  assign arbiter__reqs[3:3] = recv__val[3];
  assign mux__in_[3] = recv__msg[3];
  assign arbiter__reqs[4:4] = recv__val[4];
  assign mux__in_[4] = recv__msg[4];

endmodule


// PyMTL Component MeshRouterRTL Definition
// Full name: MeshRouterRTL__PacketType_InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d__PositionType_MeshPosition_3x3__pos_x_2__pos_y_2__InputUnitType_InputUnitRTL__RouteUnitType_DORYMeshRouteUnitRTL__SwitchUnitType_SwitchUnitRTL
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/meshnet/MeshRouterRTL.py

module MeshRouterRTL__01c013da1fe506e7
(
  input  logic [0:0] clk ,
  input  MeshPosition_3x3__pos_x_2__pos_y_2 pos ,
  input  logic [0:0] reset ,
  input InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv__msg [0:4] ,
  output logic [0:0] recv__rdy [0:4] ,
  input logic [0:0] recv__val [0:4] ,
  output InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send__msg [0:4] ,
  input logic [0:0] send__rdy [0:4] ,
  output logic [0:0] send__val [0:4] 
);
  //-------------------------------------------------------------
  // Component input_units[0:4]
  //-------------------------------------------------------------

  logic [0:0] input_units__clk [0:4];
  logic [0:0] input_units__reset [0:4];
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d input_units__recv__msg [0:4];
  logic [0:0] input_units__recv__rdy [0:4];
  logic [0:0] input_units__recv__val [0:4];
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d input_units__send__msg [0:4];
  logic [0:0] input_units__send__rdy [0:4];
  logic [0:0] input_units__send__val [0:4];

  InputUnitRTL__53a3bf15fecaa9e5 input_units__0
  (
    .clk( input_units__clk[0] ),
    .reset( input_units__reset[0] ),
    .recv__msg( input_units__recv__msg[0] ),
    .recv__rdy( input_units__recv__rdy[0] ),
    .recv__val( input_units__recv__val[0] ),
    .send__msg( input_units__send__msg[0] ),
    .send__rdy( input_units__send__rdy[0] ),
    .send__val( input_units__send__val[0] )
  );

  InputUnitRTL__53a3bf15fecaa9e5 input_units__1
  (
    .clk( input_units__clk[1] ),
    .reset( input_units__reset[1] ),
    .recv__msg( input_units__recv__msg[1] ),
    .recv__rdy( input_units__recv__rdy[1] ),
    .recv__val( input_units__recv__val[1] ),
    .send__msg( input_units__send__msg[1] ),
    .send__rdy( input_units__send__rdy[1] ),
    .send__val( input_units__send__val[1] )
  );

  InputUnitRTL__53a3bf15fecaa9e5 input_units__2
  (
    .clk( input_units__clk[2] ),
    .reset( input_units__reset[2] ),
    .recv__msg( input_units__recv__msg[2] ),
    .recv__rdy( input_units__recv__rdy[2] ),
    .recv__val( input_units__recv__val[2] ),
    .send__msg( input_units__send__msg[2] ),
    .send__rdy( input_units__send__rdy[2] ),
    .send__val( input_units__send__val[2] )
  );

  InputUnitRTL__53a3bf15fecaa9e5 input_units__3
  (
    .clk( input_units__clk[3] ),
    .reset( input_units__reset[3] ),
    .recv__msg( input_units__recv__msg[3] ),
    .recv__rdy( input_units__recv__rdy[3] ),
    .recv__val( input_units__recv__val[3] ),
    .send__msg( input_units__send__msg[3] ),
    .send__rdy( input_units__send__rdy[3] ),
    .send__val( input_units__send__val[3] )
  );

  InputUnitRTL__53a3bf15fecaa9e5 input_units__4
  (
    .clk( input_units__clk[4] ),
    .reset( input_units__reset[4] ),
    .recv__msg( input_units__recv__msg[4] ),
    .recv__rdy( input_units__recv__rdy[4] ),
    .recv__val( input_units__recv__val[4] ),
    .send__msg( input_units__send__msg[4] ),
    .send__rdy( input_units__send__rdy[4] ),
    .send__val( input_units__send__val[4] )
  );

  //-------------------------------------------------------------
  // End of component input_units[0:4]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component output_units[0:4]
  //-------------------------------------------------------------

  logic [0:0] output_units__clk [0:4];
  logic [0:0] output_units__reset [0:4];
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d output_units__recv__msg [0:4];
  logic [0:0] output_units__recv__rdy [0:4];
  logic [0:0] output_units__recv__val [0:4];
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d output_units__send__msg [0:4];
  logic [0:0] output_units__send__rdy [0:4];
  logic [0:0] output_units__send__val [0:4];

  OutputUnitRTL__1a67861a3fc29f7f output_units__0
  (
    .clk( output_units__clk[0] ),
    .reset( output_units__reset[0] ),
    .recv__msg( output_units__recv__msg[0] ),
    .recv__rdy( output_units__recv__rdy[0] ),
    .recv__val( output_units__recv__val[0] ),
    .send__msg( output_units__send__msg[0] ),
    .send__rdy( output_units__send__rdy[0] ),
    .send__val( output_units__send__val[0] )
  );

  OutputUnitRTL__1a67861a3fc29f7f output_units__1
  (
    .clk( output_units__clk[1] ),
    .reset( output_units__reset[1] ),
    .recv__msg( output_units__recv__msg[1] ),
    .recv__rdy( output_units__recv__rdy[1] ),
    .recv__val( output_units__recv__val[1] ),
    .send__msg( output_units__send__msg[1] ),
    .send__rdy( output_units__send__rdy[1] ),
    .send__val( output_units__send__val[1] )
  );

  OutputUnitRTL__1a67861a3fc29f7f output_units__2
  (
    .clk( output_units__clk[2] ),
    .reset( output_units__reset[2] ),
    .recv__msg( output_units__recv__msg[2] ),
    .recv__rdy( output_units__recv__rdy[2] ),
    .recv__val( output_units__recv__val[2] ),
    .send__msg( output_units__send__msg[2] ),
    .send__rdy( output_units__send__rdy[2] ),
    .send__val( output_units__send__val[2] )
  );

  OutputUnitRTL__1a67861a3fc29f7f output_units__3
  (
    .clk( output_units__clk[3] ),
    .reset( output_units__reset[3] ),
    .recv__msg( output_units__recv__msg[3] ),
    .recv__rdy( output_units__recv__rdy[3] ),
    .recv__val( output_units__recv__val[3] ),
    .send__msg( output_units__send__msg[3] ),
    .send__rdy( output_units__send__rdy[3] ),
    .send__val( output_units__send__val[3] )
  );

  OutputUnitRTL__1a67861a3fc29f7f output_units__4
  (
    .clk( output_units__clk[4] ),
    .reset( output_units__reset[4] ),
    .recv__msg( output_units__recv__msg[4] ),
    .recv__rdy( output_units__recv__rdy[4] ),
    .recv__val( output_units__recv__val[4] ),
    .send__msg( output_units__send__msg[4] ),
    .send__rdy( output_units__send__rdy[4] ),
    .send__val( output_units__send__val[4] )
  );

  //-------------------------------------------------------------
  // End of component output_units[0:4]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component route_units[0:4]
  //-------------------------------------------------------------

  logic [0:0] route_units__clk [0:4];
  MeshPosition_3x3__pos_x_2__pos_y_2 route_units__pos [0:4];
  logic [0:0] route_units__reset [0:4];
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d route_units__recv__msg [0:4];
  logic [0:0] route_units__recv__rdy [0:4];
  logic [0:0] route_units__recv__val [0:4];
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d route_units__send__msg [0:4][0:4];
  logic [0:0] route_units__send__rdy [0:4][0:4];
  logic [0:0] route_units__send__val [0:4][0:4];

  DORYMeshRouteUnitRTL__2004b86ce9e9786e route_units__0
  (
    .clk( route_units__clk[0] ),
    .pos( route_units__pos[0] ),
    .reset( route_units__reset[0] ),
    .recv__msg( route_units__recv__msg[0] ),
    .recv__rdy( route_units__recv__rdy[0] ),
    .recv__val( route_units__recv__val[0] ),
    .send__msg( route_units__send__msg[0] ),
    .send__rdy( route_units__send__rdy[0] ),
    .send__val( route_units__send__val[0] )
  );

  DORYMeshRouteUnitRTL__2004b86ce9e9786e route_units__1
  (
    .clk( route_units__clk[1] ),
    .pos( route_units__pos[1] ),
    .reset( route_units__reset[1] ),
    .recv__msg( route_units__recv__msg[1] ),
    .recv__rdy( route_units__recv__rdy[1] ),
    .recv__val( route_units__recv__val[1] ),
    .send__msg( route_units__send__msg[1] ),
    .send__rdy( route_units__send__rdy[1] ),
    .send__val( route_units__send__val[1] )
  );

  DORYMeshRouteUnitRTL__2004b86ce9e9786e route_units__2
  (
    .clk( route_units__clk[2] ),
    .pos( route_units__pos[2] ),
    .reset( route_units__reset[2] ),
    .recv__msg( route_units__recv__msg[2] ),
    .recv__rdy( route_units__recv__rdy[2] ),
    .recv__val( route_units__recv__val[2] ),
    .send__msg( route_units__send__msg[2] ),
    .send__rdy( route_units__send__rdy[2] ),
    .send__val( route_units__send__val[2] )
  );

  DORYMeshRouteUnitRTL__2004b86ce9e9786e route_units__3
  (
    .clk( route_units__clk[3] ),
    .pos( route_units__pos[3] ),
    .reset( route_units__reset[3] ),
    .recv__msg( route_units__recv__msg[3] ),
    .recv__rdy( route_units__recv__rdy[3] ),
    .recv__val( route_units__recv__val[3] ),
    .send__msg( route_units__send__msg[3] ),
    .send__rdy( route_units__send__rdy[3] ),
    .send__val( route_units__send__val[3] )
  );

  DORYMeshRouteUnitRTL__2004b86ce9e9786e route_units__4
  (
    .clk( route_units__clk[4] ),
    .pos( route_units__pos[4] ),
    .reset( route_units__reset[4] ),
    .recv__msg( route_units__recv__msg[4] ),
    .recv__rdy( route_units__recv__rdy[4] ),
    .recv__val( route_units__recv__val[4] ),
    .send__msg( route_units__send__msg[4] ),
    .send__rdy( route_units__send__rdy[4] ),
    .send__val( route_units__send__val[4] )
  );

  //-------------------------------------------------------------
  // End of component route_units[0:4]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component switch_units[0:4]
  //-------------------------------------------------------------

  logic [0:0] switch_units__clk [0:4];
  logic [0:0] switch_units__reset [0:4];
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d switch_units__recv__msg [0:4][0:4];
  logic [0:0] switch_units__recv__rdy [0:4][0:4];
  logic [0:0] switch_units__recv__val [0:4][0:4];
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d switch_units__send__msg [0:4];
  logic [0:0] switch_units__send__rdy [0:4];
  logic [0:0] switch_units__send__val [0:4];

  SwitchUnitRTL__1b55f2b824e197a8 switch_units__0
  (
    .clk( switch_units__clk[0] ),
    .reset( switch_units__reset[0] ),
    .recv__msg( switch_units__recv__msg[0] ),
    .recv__rdy( switch_units__recv__rdy[0] ),
    .recv__val( switch_units__recv__val[0] ),
    .send__msg( switch_units__send__msg[0] ),
    .send__rdy( switch_units__send__rdy[0] ),
    .send__val( switch_units__send__val[0] )
  );

  SwitchUnitRTL__1b55f2b824e197a8 switch_units__1
  (
    .clk( switch_units__clk[1] ),
    .reset( switch_units__reset[1] ),
    .recv__msg( switch_units__recv__msg[1] ),
    .recv__rdy( switch_units__recv__rdy[1] ),
    .recv__val( switch_units__recv__val[1] ),
    .send__msg( switch_units__send__msg[1] ),
    .send__rdy( switch_units__send__rdy[1] ),
    .send__val( switch_units__send__val[1] )
  );

  SwitchUnitRTL__1b55f2b824e197a8 switch_units__2
  (
    .clk( switch_units__clk[2] ),
    .reset( switch_units__reset[2] ),
    .recv__msg( switch_units__recv__msg[2] ),
    .recv__rdy( switch_units__recv__rdy[2] ),
    .recv__val( switch_units__recv__val[2] ),
    .send__msg( switch_units__send__msg[2] ),
    .send__rdy( switch_units__send__rdy[2] ),
    .send__val( switch_units__send__val[2] )
  );

  SwitchUnitRTL__1b55f2b824e197a8 switch_units__3
  (
    .clk( switch_units__clk[3] ),
    .reset( switch_units__reset[3] ),
    .recv__msg( switch_units__recv__msg[3] ),
    .recv__rdy( switch_units__recv__rdy[3] ),
    .recv__val( switch_units__recv__val[3] ),
    .send__msg( switch_units__send__msg[3] ),
    .send__rdy( switch_units__send__rdy[3] ),
    .send__val( switch_units__send__val[3] )
  );

  SwitchUnitRTL__1b55f2b824e197a8 switch_units__4
  (
    .clk( switch_units__clk[4] ),
    .reset( switch_units__reset[4] ),
    .recv__msg( switch_units__recv__msg[4] ),
    .recv__rdy( switch_units__recv__rdy[4] ),
    .recv__val( switch_units__recv__val[4] ),
    .send__msg( switch_units__send__msg[4] ),
    .send__rdy( switch_units__send__rdy[4] ),
    .send__val( switch_units__send__val[4] )
  );

  //-------------------------------------------------------------
  // End of component switch_units[0:4]
  //-------------------------------------------------------------

  assign input_units__clk[0] = clk;
  assign input_units__reset[0] = reset;
  assign input_units__clk[1] = clk;
  assign input_units__reset[1] = reset;
  assign input_units__clk[2] = clk;
  assign input_units__reset[2] = reset;
  assign input_units__clk[3] = clk;
  assign input_units__reset[3] = reset;
  assign input_units__clk[4] = clk;
  assign input_units__reset[4] = reset;
  assign route_units__clk[0] = clk;
  assign route_units__reset[0] = reset;
  assign route_units__clk[1] = clk;
  assign route_units__reset[1] = reset;
  assign route_units__clk[2] = clk;
  assign route_units__reset[2] = reset;
  assign route_units__clk[3] = clk;
  assign route_units__reset[3] = reset;
  assign route_units__clk[4] = clk;
  assign route_units__reset[4] = reset;
  assign switch_units__clk[0] = clk;
  assign switch_units__reset[0] = reset;
  assign switch_units__clk[1] = clk;
  assign switch_units__reset[1] = reset;
  assign switch_units__clk[2] = clk;
  assign switch_units__reset[2] = reset;
  assign switch_units__clk[3] = clk;
  assign switch_units__reset[3] = reset;
  assign switch_units__clk[4] = clk;
  assign switch_units__reset[4] = reset;
  assign output_units__clk[0] = clk;
  assign output_units__reset[0] = reset;
  assign output_units__clk[1] = clk;
  assign output_units__reset[1] = reset;
  assign output_units__clk[2] = clk;
  assign output_units__reset[2] = reset;
  assign output_units__clk[3] = clk;
  assign output_units__reset[3] = reset;
  assign output_units__clk[4] = clk;
  assign output_units__reset[4] = reset;
  assign input_units__recv__msg[0] = recv__msg[0];
  assign recv__rdy[0] = input_units__recv__rdy[0];
  assign input_units__recv__val[0] = recv__val[0];
  assign route_units__recv__msg[0] = input_units__send__msg[0];
  assign input_units__send__rdy[0] = route_units__recv__rdy[0];
  assign route_units__recv__val[0] = input_units__send__val[0];
  assign route_units__pos[0] = pos;
  assign input_units__recv__msg[1] = recv__msg[1];
  assign recv__rdy[1] = input_units__recv__rdy[1];
  assign input_units__recv__val[1] = recv__val[1];
  assign route_units__recv__msg[1] = input_units__send__msg[1];
  assign input_units__send__rdy[1] = route_units__recv__rdy[1];
  assign route_units__recv__val[1] = input_units__send__val[1];
  assign route_units__pos[1] = pos;
  assign input_units__recv__msg[2] = recv__msg[2];
  assign recv__rdy[2] = input_units__recv__rdy[2];
  assign input_units__recv__val[2] = recv__val[2];
  assign route_units__recv__msg[2] = input_units__send__msg[2];
  assign input_units__send__rdy[2] = route_units__recv__rdy[2];
  assign route_units__recv__val[2] = input_units__send__val[2];
  assign route_units__pos[2] = pos;
  assign input_units__recv__msg[3] = recv__msg[3];
  assign recv__rdy[3] = input_units__recv__rdy[3];
  assign input_units__recv__val[3] = recv__val[3];
  assign route_units__recv__msg[3] = input_units__send__msg[3];
  assign input_units__send__rdy[3] = route_units__recv__rdy[3];
  assign route_units__recv__val[3] = input_units__send__val[3];
  assign route_units__pos[3] = pos;
  assign input_units__recv__msg[4] = recv__msg[4];
  assign recv__rdy[4] = input_units__recv__rdy[4];
  assign input_units__recv__val[4] = recv__val[4];
  assign route_units__recv__msg[4] = input_units__send__msg[4];
  assign input_units__send__rdy[4] = route_units__recv__rdy[4];
  assign route_units__recv__val[4] = input_units__send__val[4];
  assign route_units__pos[4] = pos;
  assign switch_units__recv__msg[0][0] = route_units__send__msg[0][0];
  assign route_units__send__rdy[0][0] = switch_units__recv__rdy[0][0];
  assign switch_units__recv__val[0][0] = route_units__send__val[0][0];
  assign switch_units__recv__msg[1][0] = route_units__send__msg[0][1];
  assign route_units__send__rdy[0][1] = switch_units__recv__rdy[1][0];
  assign switch_units__recv__val[1][0] = route_units__send__val[0][1];
  assign switch_units__recv__msg[2][0] = route_units__send__msg[0][2];
  assign route_units__send__rdy[0][2] = switch_units__recv__rdy[2][0];
  assign switch_units__recv__val[2][0] = route_units__send__val[0][2];
  assign switch_units__recv__msg[3][0] = route_units__send__msg[0][3];
  assign route_units__send__rdy[0][3] = switch_units__recv__rdy[3][0];
  assign switch_units__recv__val[3][0] = route_units__send__val[0][3];
  assign switch_units__recv__msg[4][0] = route_units__send__msg[0][4];
  assign route_units__send__rdy[0][4] = switch_units__recv__rdy[4][0];
  assign switch_units__recv__val[4][0] = route_units__send__val[0][4];
  assign switch_units__recv__msg[0][1] = route_units__send__msg[1][0];
  assign route_units__send__rdy[1][0] = switch_units__recv__rdy[0][1];
  assign switch_units__recv__val[0][1] = route_units__send__val[1][0];
  assign switch_units__recv__msg[1][1] = route_units__send__msg[1][1];
  assign route_units__send__rdy[1][1] = switch_units__recv__rdy[1][1];
  assign switch_units__recv__val[1][1] = route_units__send__val[1][1];
  assign switch_units__recv__msg[2][1] = route_units__send__msg[1][2];
  assign route_units__send__rdy[1][2] = switch_units__recv__rdy[2][1];
  assign switch_units__recv__val[2][1] = route_units__send__val[1][2];
  assign switch_units__recv__msg[3][1] = route_units__send__msg[1][3];
  assign route_units__send__rdy[1][3] = switch_units__recv__rdy[3][1];
  assign switch_units__recv__val[3][1] = route_units__send__val[1][3];
  assign switch_units__recv__msg[4][1] = route_units__send__msg[1][4];
  assign route_units__send__rdy[1][4] = switch_units__recv__rdy[4][1];
  assign switch_units__recv__val[4][1] = route_units__send__val[1][4];
  assign switch_units__recv__msg[0][2] = route_units__send__msg[2][0];
  assign route_units__send__rdy[2][0] = switch_units__recv__rdy[0][2];
  assign switch_units__recv__val[0][2] = route_units__send__val[2][0];
  assign switch_units__recv__msg[1][2] = route_units__send__msg[2][1];
  assign route_units__send__rdy[2][1] = switch_units__recv__rdy[1][2];
  assign switch_units__recv__val[1][2] = route_units__send__val[2][1];
  assign switch_units__recv__msg[2][2] = route_units__send__msg[2][2];
  assign route_units__send__rdy[2][2] = switch_units__recv__rdy[2][2];
  assign switch_units__recv__val[2][2] = route_units__send__val[2][2];
  assign switch_units__recv__msg[3][2] = route_units__send__msg[2][3];
  assign route_units__send__rdy[2][3] = switch_units__recv__rdy[3][2];
  assign switch_units__recv__val[3][2] = route_units__send__val[2][3];
  assign switch_units__recv__msg[4][2] = route_units__send__msg[2][4];
  assign route_units__send__rdy[2][4] = switch_units__recv__rdy[4][2];
  assign switch_units__recv__val[4][2] = route_units__send__val[2][4];
  assign switch_units__recv__msg[0][3] = route_units__send__msg[3][0];
  assign route_units__send__rdy[3][0] = switch_units__recv__rdy[0][3];
  assign switch_units__recv__val[0][3] = route_units__send__val[3][0];
  assign switch_units__recv__msg[1][3] = route_units__send__msg[3][1];
  assign route_units__send__rdy[3][1] = switch_units__recv__rdy[1][3];
  assign switch_units__recv__val[1][3] = route_units__send__val[3][1];
  assign switch_units__recv__msg[2][3] = route_units__send__msg[3][2];
  assign route_units__send__rdy[3][2] = switch_units__recv__rdy[2][3];
  assign switch_units__recv__val[2][3] = route_units__send__val[3][2];
  assign switch_units__recv__msg[3][3] = route_units__send__msg[3][3];
  assign route_units__send__rdy[3][3] = switch_units__recv__rdy[3][3];
  assign switch_units__recv__val[3][3] = route_units__send__val[3][3];
  assign switch_units__recv__msg[4][3] = route_units__send__msg[3][4];
  assign route_units__send__rdy[3][4] = switch_units__recv__rdy[4][3];
  assign switch_units__recv__val[4][3] = route_units__send__val[3][4];
  assign switch_units__recv__msg[0][4] = route_units__send__msg[4][0];
  assign route_units__send__rdy[4][0] = switch_units__recv__rdy[0][4];
  assign switch_units__recv__val[0][4] = route_units__send__val[4][0];
  assign switch_units__recv__msg[1][4] = route_units__send__msg[4][1];
  assign route_units__send__rdy[4][1] = switch_units__recv__rdy[1][4];
  assign switch_units__recv__val[1][4] = route_units__send__val[4][1];
  assign switch_units__recv__msg[2][4] = route_units__send__msg[4][2];
  assign route_units__send__rdy[4][2] = switch_units__recv__rdy[2][4];
  assign switch_units__recv__val[2][4] = route_units__send__val[4][2];
  assign switch_units__recv__msg[3][4] = route_units__send__msg[4][3];
  assign route_units__send__rdy[4][3] = switch_units__recv__rdy[3][4];
  assign switch_units__recv__val[3][4] = route_units__send__val[4][3];
  assign switch_units__recv__msg[4][4] = route_units__send__msg[4][4];
  assign route_units__send__rdy[4][4] = switch_units__recv__rdy[4][4];
  assign switch_units__recv__val[4][4] = route_units__send__val[4][4];
  assign output_units__recv__msg[0] = switch_units__send__msg[0];
  assign switch_units__send__rdy[0] = output_units__recv__rdy[0];
  assign output_units__recv__val[0] = switch_units__send__val[0];
  assign send__msg[0] = output_units__send__msg[0];
  assign output_units__send__rdy[0] = send__rdy[0];
  assign send__val[0] = output_units__send__val[0];
  assign output_units__recv__msg[1] = switch_units__send__msg[1];
  assign switch_units__send__rdy[1] = output_units__recv__rdy[1];
  assign output_units__recv__val[1] = switch_units__send__val[1];
  assign send__msg[1] = output_units__send__msg[1];
  assign output_units__send__rdy[1] = send__rdy[1];
  assign send__val[1] = output_units__send__val[1];
  assign output_units__recv__msg[2] = switch_units__send__msg[2];
  assign switch_units__send__rdy[2] = output_units__recv__rdy[2];
  assign output_units__recv__val[2] = switch_units__send__val[2];
  assign send__msg[2] = output_units__send__msg[2];
  assign output_units__send__rdy[2] = send__rdy[2];
  assign send__val[2] = output_units__send__val[2];
  assign output_units__recv__msg[3] = switch_units__send__msg[3];
  assign switch_units__send__rdy[3] = output_units__recv__rdy[3];
  assign output_units__recv__val[3] = switch_units__send__val[3];
  assign send__msg[3] = output_units__send__msg[3];
  assign output_units__send__rdy[3] = send__rdy[3];
  assign send__val[3] = output_units__send__val[3];
  assign output_units__recv__msg[4] = switch_units__send__msg[4];
  assign switch_units__send__rdy[4] = output_units__recv__rdy[4];
  assign output_units__recv__val[4] = switch_units__send__val[4];
  assign send__msg[4] = output_units__send__msg[4];
  assign output_units__send__rdy[4] = send__rdy[4];
  assign send__val[4] = output_units__send__val[4];

endmodule


// PyMTL Component MeshNetworkRTL Definition
// Full name: MeshNetworkRTL__PacketType_InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d__PositionType_MeshPosition_3x3__pos_x_2__pos_y_2__ncols_3__nrows_3__chl_lat_1
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/noc/PyOCN/pymtl3_net/meshnet/MeshNetworkRTL.py

module MeshNetworkRTL__b809e6737c6ce9e8
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d recv__msg [0:8] ,
  output logic [0:0] recv__rdy [0:8] ,
  input logic [0:0] recv__val [0:8] ,
  output InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d send__msg [0:8] ,
  input logic [0:0] send__rdy [0:8] ,
  output logic [0:0] send__val [0:8] 
);
  //-------------------------------------------------------------
  // Component channels[0:23]
  //-------------------------------------------------------------

  logic [0:0] channels__clk [0:23];
  logic [0:0] channels__reset [0:23];
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d channels__recv__msg [0:23];
  logic [0:0] channels__recv__rdy [0:23];
  logic [0:0] channels__recv__val [0:23];
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d channels__send__msg [0:23];
  logic [0:0] channels__send__rdy [0:23];
  logic [0:0] channels__send__val [0:23];

  ChannelRTL__fce4be61a0158680 channels__0
  (
    .clk( channels__clk[0] ),
    .reset( channels__reset[0] ),
    .recv__msg( channels__recv__msg[0] ),
    .recv__rdy( channels__recv__rdy[0] ),
    .recv__val( channels__recv__val[0] ),
    .send__msg( channels__send__msg[0] ),
    .send__rdy( channels__send__rdy[0] ),
    .send__val( channels__send__val[0] )
  );

  ChannelRTL__fce4be61a0158680 channels__1
  (
    .clk( channels__clk[1] ),
    .reset( channels__reset[1] ),
    .recv__msg( channels__recv__msg[1] ),
    .recv__rdy( channels__recv__rdy[1] ),
    .recv__val( channels__recv__val[1] ),
    .send__msg( channels__send__msg[1] ),
    .send__rdy( channels__send__rdy[1] ),
    .send__val( channels__send__val[1] )
  );

  ChannelRTL__fce4be61a0158680 channels__2
  (
    .clk( channels__clk[2] ),
    .reset( channels__reset[2] ),
    .recv__msg( channels__recv__msg[2] ),
    .recv__rdy( channels__recv__rdy[2] ),
    .recv__val( channels__recv__val[2] ),
    .send__msg( channels__send__msg[2] ),
    .send__rdy( channels__send__rdy[2] ),
    .send__val( channels__send__val[2] )
  );

  ChannelRTL__fce4be61a0158680 channels__3
  (
    .clk( channels__clk[3] ),
    .reset( channels__reset[3] ),
    .recv__msg( channels__recv__msg[3] ),
    .recv__rdy( channels__recv__rdy[3] ),
    .recv__val( channels__recv__val[3] ),
    .send__msg( channels__send__msg[3] ),
    .send__rdy( channels__send__rdy[3] ),
    .send__val( channels__send__val[3] )
  );

  ChannelRTL__fce4be61a0158680 channels__4
  (
    .clk( channels__clk[4] ),
    .reset( channels__reset[4] ),
    .recv__msg( channels__recv__msg[4] ),
    .recv__rdy( channels__recv__rdy[4] ),
    .recv__val( channels__recv__val[4] ),
    .send__msg( channels__send__msg[4] ),
    .send__rdy( channels__send__rdy[4] ),
    .send__val( channels__send__val[4] )
  );

  ChannelRTL__fce4be61a0158680 channels__5
  (
    .clk( channels__clk[5] ),
    .reset( channels__reset[5] ),
    .recv__msg( channels__recv__msg[5] ),
    .recv__rdy( channels__recv__rdy[5] ),
    .recv__val( channels__recv__val[5] ),
    .send__msg( channels__send__msg[5] ),
    .send__rdy( channels__send__rdy[5] ),
    .send__val( channels__send__val[5] )
  );

  ChannelRTL__fce4be61a0158680 channels__6
  (
    .clk( channels__clk[6] ),
    .reset( channels__reset[6] ),
    .recv__msg( channels__recv__msg[6] ),
    .recv__rdy( channels__recv__rdy[6] ),
    .recv__val( channels__recv__val[6] ),
    .send__msg( channels__send__msg[6] ),
    .send__rdy( channels__send__rdy[6] ),
    .send__val( channels__send__val[6] )
  );

  ChannelRTL__fce4be61a0158680 channels__7
  (
    .clk( channels__clk[7] ),
    .reset( channels__reset[7] ),
    .recv__msg( channels__recv__msg[7] ),
    .recv__rdy( channels__recv__rdy[7] ),
    .recv__val( channels__recv__val[7] ),
    .send__msg( channels__send__msg[7] ),
    .send__rdy( channels__send__rdy[7] ),
    .send__val( channels__send__val[7] )
  );

  ChannelRTL__fce4be61a0158680 channels__8
  (
    .clk( channels__clk[8] ),
    .reset( channels__reset[8] ),
    .recv__msg( channels__recv__msg[8] ),
    .recv__rdy( channels__recv__rdy[8] ),
    .recv__val( channels__recv__val[8] ),
    .send__msg( channels__send__msg[8] ),
    .send__rdy( channels__send__rdy[8] ),
    .send__val( channels__send__val[8] )
  );

  ChannelRTL__fce4be61a0158680 channels__9
  (
    .clk( channels__clk[9] ),
    .reset( channels__reset[9] ),
    .recv__msg( channels__recv__msg[9] ),
    .recv__rdy( channels__recv__rdy[9] ),
    .recv__val( channels__recv__val[9] ),
    .send__msg( channels__send__msg[9] ),
    .send__rdy( channels__send__rdy[9] ),
    .send__val( channels__send__val[9] )
  );

  ChannelRTL__fce4be61a0158680 channels__10
  (
    .clk( channels__clk[10] ),
    .reset( channels__reset[10] ),
    .recv__msg( channels__recv__msg[10] ),
    .recv__rdy( channels__recv__rdy[10] ),
    .recv__val( channels__recv__val[10] ),
    .send__msg( channels__send__msg[10] ),
    .send__rdy( channels__send__rdy[10] ),
    .send__val( channels__send__val[10] )
  );

  ChannelRTL__fce4be61a0158680 channels__11
  (
    .clk( channels__clk[11] ),
    .reset( channels__reset[11] ),
    .recv__msg( channels__recv__msg[11] ),
    .recv__rdy( channels__recv__rdy[11] ),
    .recv__val( channels__recv__val[11] ),
    .send__msg( channels__send__msg[11] ),
    .send__rdy( channels__send__rdy[11] ),
    .send__val( channels__send__val[11] )
  );

  ChannelRTL__fce4be61a0158680 channels__12
  (
    .clk( channels__clk[12] ),
    .reset( channels__reset[12] ),
    .recv__msg( channels__recv__msg[12] ),
    .recv__rdy( channels__recv__rdy[12] ),
    .recv__val( channels__recv__val[12] ),
    .send__msg( channels__send__msg[12] ),
    .send__rdy( channels__send__rdy[12] ),
    .send__val( channels__send__val[12] )
  );

  ChannelRTL__fce4be61a0158680 channels__13
  (
    .clk( channels__clk[13] ),
    .reset( channels__reset[13] ),
    .recv__msg( channels__recv__msg[13] ),
    .recv__rdy( channels__recv__rdy[13] ),
    .recv__val( channels__recv__val[13] ),
    .send__msg( channels__send__msg[13] ),
    .send__rdy( channels__send__rdy[13] ),
    .send__val( channels__send__val[13] )
  );

  ChannelRTL__fce4be61a0158680 channels__14
  (
    .clk( channels__clk[14] ),
    .reset( channels__reset[14] ),
    .recv__msg( channels__recv__msg[14] ),
    .recv__rdy( channels__recv__rdy[14] ),
    .recv__val( channels__recv__val[14] ),
    .send__msg( channels__send__msg[14] ),
    .send__rdy( channels__send__rdy[14] ),
    .send__val( channels__send__val[14] )
  );

  ChannelRTL__fce4be61a0158680 channels__15
  (
    .clk( channels__clk[15] ),
    .reset( channels__reset[15] ),
    .recv__msg( channels__recv__msg[15] ),
    .recv__rdy( channels__recv__rdy[15] ),
    .recv__val( channels__recv__val[15] ),
    .send__msg( channels__send__msg[15] ),
    .send__rdy( channels__send__rdy[15] ),
    .send__val( channels__send__val[15] )
  );

  ChannelRTL__fce4be61a0158680 channels__16
  (
    .clk( channels__clk[16] ),
    .reset( channels__reset[16] ),
    .recv__msg( channels__recv__msg[16] ),
    .recv__rdy( channels__recv__rdy[16] ),
    .recv__val( channels__recv__val[16] ),
    .send__msg( channels__send__msg[16] ),
    .send__rdy( channels__send__rdy[16] ),
    .send__val( channels__send__val[16] )
  );

  ChannelRTL__fce4be61a0158680 channels__17
  (
    .clk( channels__clk[17] ),
    .reset( channels__reset[17] ),
    .recv__msg( channels__recv__msg[17] ),
    .recv__rdy( channels__recv__rdy[17] ),
    .recv__val( channels__recv__val[17] ),
    .send__msg( channels__send__msg[17] ),
    .send__rdy( channels__send__rdy[17] ),
    .send__val( channels__send__val[17] )
  );

  ChannelRTL__fce4be61a0158680 channels__18
  (
    .clk( channels__clk[18] ),
    .reset( channels__reset[18] ),
    .recv__msg( channels__recv__msg[18] ),
    .recv__rdy( channels__recv__rdy[18] ),
    .recv__val( channels__recv__val[18] ),
    .send__msg( channels__send__msg[18] ),
    .send__rdy( channels__send__rdy[18] ),
    .send__val( channels__send__val[18] )
  );

  ChannelRTL__fce4be61a0158680 channels__19
  (
    .clk( channels__clk[19] ),
    .reset( channels__reset[19] ),
    .recv__msg( channels__recv__msg[19] ),
    .recv__rdy( channels__recv__rdy[19] ),
    .recv__val( channels__recv__val[19] ),
    .send__msg( channels__send__msg[19] ),
    .send__rdy( channels__send__rdy[19] ),
    .send__val( channels__send__val[19] )
  );

  ChannelRTL__fce4be61a0158680 channels__20
  (
    .clk( channels__clk[20] ),
    .reset( channels__reset[20] ),
    .recv__msg( channels__recv__msg[20] ),
    .recv__rdy( channels__recv__rdy[20] ),
    .recv__val( channels__recv__val[20] ),
    .send__msg( channels__send__msg[20] ),
    .send__rdy( channels__send__rdy[20] ),
    .send__val( channels__send__val[20] )
  );

  ChannelRTL__fce4be61a0158680 channels__21
  (
    .clk( channels__clk[21] ),
    .reset( channels__reset[21] ),
    .recv__msg( channels__recv__msg[21] ),
    .recv__rdy( channels__recv__rdy[21] ),
    .recv__val( channels__recv__val[21] ),
    .send__msg( channels__send__msg[21] ),
    .send__rdy( channels__send__rdy[21] ),
    .send__val( channels__send__val[21] )
  );

  ChannelRTL__fce4be61a0158680 channels__22
  (
    .clk( channels__clk[22] ),
    .reset( channels__reset[22] ),
    .recv__msg( channels__recv__msg[22] ),
    .recv__rdy( channels__recv__rdy[22] ),
    .recv__val( channels__recv__val[22] ),
    .send__msg( channels__send__msg[22] ),
    .send__rdy( channels__send__rdy[22] ),
    .send__val( channels__send__val[22] )
  );

  ChannelRTL__fce4be61a0158680 channels__23
  (
    .clk( channels__clk[23] ),
    .reset( channels__reset[23] ),
    .recv__msg( channels__recv__msg[23] ),
    .recv__rdy( channels__recv__rdy[23] ),
    .recv__val( channels__recv__val[23] ),
    .send__msg( channels__send__msg[23] ),
    .send__rdy( channels__send__rdy[23] ),
    .send__val( channels__send__val[23] )
  );

  //-------------------------------------------------------------
  // End of component channels[0:23]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component routers[0:8]
  //-------------------------------------------------------------

  logic [0:0] routers__clk [0:8];
  MeshPosition_3x3__pos_x_2__pos_y_2 routers__pos [0:8];
  logic [0:0] routers__reset [0:8];
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d routers__recv__msg [0:8][0:4];
  logic [0:0] routers__recv__rdy [0:8][0:4];
  logic [0:0] routers__recv__val [0:8][0:4];
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d routers__send__msg [0:8][0:4];
  logic [0:0] routers__send__rdy [0:8][0:4];
  logic [0:0] routers__send__val [0:8][0:4];

  MeshRouterRTL__01c013da1fe506e7 routers__0
  (
    .clk( routers__clk[0] ),
    .pos( routers__pos[0] ),
    .reset( routers__reset[0] ),
    .recv__msg( routers__recv__msg[0] ),
    .recv__rdy( routers__recv__rdy[0] ),
    .recv__val( routers__recv__val[0] ),
    .send__msg( routers__send__msg[0] ),
    .send__rdy( routers__send__rdy[0] ),
    .send__val( routers__send__val[0] )
  );

  MeshRouterRTL__01c013da1fe506e7 routers__1
  (
    .clk( routers__clk[1] ),
    .pos( routers__pos[1] ),
    .reset( routers__reset[1] ),
    .recv__msg( routers__recv__msg[1] ),
    .recv__rdy( routers__recv__rdy[1] ),
    .recv__val( routers__recv__val[1] ),
    .send__msg( routers__send__msg[1] ),
    .send__rdy( routers__send__rdy[1] ),
    .send__val( routers__send__val[1] )
  );

  MeshRouterRTL__01c013da1fe506e7 routers__2
  (
    .clk( routers__clk[2] ),
    .pos( routers__pos[2] ),
    .reset( routers__reset[2] ),
    .recv__msg( routers__recv__msg[2] ),
    .recv__rdy( routers__recv__rdy[2] ),
    .recv__val( routers__recv__val[2] ),
    .send__msg( routers__send__msg[2] ),
    .send__rdy( routers__send__rdy[2] ),
    .send__val( routers__send__val[2] )
  );

  MeshRouterRTL__01c013da1fe506e7 routers__3
  (
    .clk( routers__clk[3] ),
    .pos( routers__pos[3] ),
    .reset( routers__reset[3] ),
    .recv__msg( routers__recv__msg[3] ),
    .recv__rdy( routers__recv__rdy[3] ),
    .recv__val( routers__recv__val[3] ),
    .send__msg( routers__send__msg[3] ),
    .send__rdy( routers__send__rdy[3] ),
    .send__val( routers__send__val[3] )
  );

  MeshRouterRTL__01c013da1fe506e7 routers__4
  (
    .clk( routers__clk[4] ),
    .pos( routers__pos[4] ),
    .reset( routers__reset[4] ),
    .recv__msg( routers__recv__msg[4] ),
    .recv__rdy( routers__recv__rdy[4] ),
    .recv__val( routers__recv__val[4] ),
    .send__msg( routers__send__msg[4] ),
    .send__rdy( routers__send__rdy[4] ),
    .send__val( routers__send__val[4] )
  );

  MeshRouterRTL__01c013da1fe506e7 routers__5
  (
    .clk( routers__clk[5] ),
    .pos( routers__pos[5] ),
    .reset( routers__reset[5] ),
    .recv__msg( routers__recv__msg[5] ),
    .recv__rdy( routers__recv__rdy[5] ),
    .recv__val( routers__recv__val[5] ),
    .send__msg( routers__send__msg[5] ),
    .send__rdy( routers__send__rdy[5] ),
    .send__val( routers__send__val[5] )
  );

  MeshRouterRTL__01c013da1fe506e7 routers__6
  (
    .clk( routers__clk[6] ),
    .pos( routers__pos[6] ),
    .reset( routers__reset[6] ),
    .recv__msg( routers__recv__msg[6] ),
    .recv__rdy( routers__recv__rdy[6] ),
    .recv__val( routers__recv__val[6] ),
    .send__msg( routers__send__msg[6] ),
    .send__rdy( routers__send__rdy[6] ),
    .send__val( routers__send__val[6] )
  );

  MeshRouterRTL__01c013da1fe506e7 routers__7
  (
    .clk( routers__clk[7] ),
    .pos( routers__pos[7] ),
    .reset( routers__reset[7] ),
    .recv__msg( routers__recv__msg[7] ),
    .recv__rdy( routers__recv__rdy[7] ),
    .recv__val( routers__recv__val[7] ),
    .send__msg( routers__send__msg[7] ),
    .send__rdy( routers__send__rdy[7] ),
    .send__val( routers__send__val[7] )
  );

  MeshRouterRTL__01c013da1fe506e7 routers__8
  (
    .clk( routers__clk[8] ),
    .pos( routers__pos[8] ),
    .reset( routers__reset[8] ),
    .recv__msg( routers__recv__msg[8] ),
    .recv__rdy( routers__recv__rdy[8] ),
    .recv__val( routers__recv__val[8] ),
    .send__msg( routers__send__msg[8] ),
    .send__rdy( routers__send__rdy[8] ),
    .send__val( routers__send__val[8] )
  );

  //-------------------------------------------------------------
  // End of component routers[0:8]
  //-------------------------------------------------------------

  assign routers__clk[0] = clk;
  assign routers__reset[0] = reset;
  assign routers__clk[1] = clk;
  assign routers__reset[1] = reset;
  assign routers__clk[2] = clk;
  assign routers__reset[2] = reset;
  assign routers__clk[3] = clk;
  assign routers__reset[3] = reset;
  assign routers__clk[4] = clk;
  assign routers__reset[4] = reset;
  assign routers__clk[5] = clk;
  assign routers__reset[5] = reset;
  assign routers__clk[6] = clk;
  assign routers__reset[6] = reset;
  assign routers__clk[7] = clk;
  assign routers__reset[7] = reset;
  assign routers__clk[8] = clk;
  assign routers__reset[8] = reset;
  assign channels__clk[0] = clk;
  assign channels__reset[0] = reset;
  assign channels__clk[1] = clk;
  assign channels__reset[1] = reset;
  assign channels__clk[2] = clk;
  assign channels__reset[2] = reset;
  assign channels__clk[3] = clk;
  assign channels__reset[3] = reset;
  assign channels__clk[4] = clk;
  assign channels__reset[4] = reset;
  assign channels__clk[5] = clk;
  assign channels__reset[5] = reset;
  assign channels__clk[6] = clk;
  assign channels__reset[6] = reset;
  assign channels__clk[7] = clk;
  assign channels__reset[7] = reset;
  assign channels__clk[8] = clk;
  assign channels__reset[8] = reset;
  assign channels__clk[9] = clk;
  assign channels__reset[9] = reset;
  assign channels__clk[10] = clk;
  assign channels__reset[10] = reset;
  assign channels__clk[11] = clk;
  assign channels__reset[11] = reset;
  assign channels__clk[12] = clk;
  assign channels__reset[12] = reset;
  assign channels__clk[13] = clk;
  assign channels__reset[13] = reset;
  assign channels__clk[14] = clk;
  assign channels__reset[14] = reset;
  assign channels__clk[15] = clk;
  assign channels__reset[15] = reset;
  assign channels__clk[16] = clk;
  assign channels__reset[16] = reset;
  assign channels__clk[17] = clk;
  assign channels__reset[17] = reset;
  assign channels__clk[18] = clk;
  assign channels__reset[18] = reset;
  assign channels__clk[19] = clk;
  assign channels__reset[19] = reset;
  assign channels__clk[20] = clk;
  assign channels__reset[20] = reset;
  assign channels__clk[21] = clk;
  assign channels__reset[21] = reset;
  assign channels__clk[22] = clk;
  assign channels__reset[22] = reset;
  assign channels__clk[23] = clk;
  assign channels__reset[23] = reset;
  assign routers__pos[0].pos_x = 2'd0;
  assign routers__pos[0].pos_y = 2'd0;
  assign routers__pos[1].pos_x = 2'd1;
  assign routers__pos[1].pos_y = 2'd0;
  assign routers__pos[2].pos_x = 2'd2;
  assign routers__pos[2].pos_y = 2'd0;
  assign routers__pos[3].pos_x = 2'd0;
  assign routers__pos[3].pos_y = 2'd1;
  assign routers__pos[4].pos_x = 2'd1;
  assign routers__pos[4].pos_y = 2'd1;
  assign routers__pos[5].pos_x = 2'd2;
  assign routers__pos[5].pos_y = 2'd1;
  assign routers__pos[6].pos_x = 2'd0;
  assign routers__pos[6].pos_y = 2'd2;
  assign routers__pos[7].pos_x = 2'd1;
  assign routers__pos[7].pos_y = 2'd2;
  assign routers__pos[8].pos_x = 2'd2;
  assign routers__pos[8].pos_y = 2'd2;
  assign channels__recv__msg[0] = routers__send__msg[0][0];
  assign routers__send__rdy[0][0] = channels__recv__rdy[0];
  assign channels__recv__val[0] = routers__send__val[0][0];
  assign routers__recv__msg[3][1] = channels__send__msg[0];
  assign channels__send__rdy[0] = routers__recv__rdy[3][1];
  assign routers__recv__val[3][1] = channels__send__val[0];
  assign channels__recv__msg[1] = routers__send__msg[0][3];
  assign routers__send__rdy[0][3] = channels__recv__rdy[1];
  assign channels__recv__val[1] = routers__send__val[0][3];
  assign routers__recv__msg[1][2] = channels__send__msg[1];
  assign channels__send__rdy[1] = routers__recv__rdy[1][2];
  assign routers__recv__val[1][2] = channels__send__val[1];
  assign routers__recv__msg[0][4] = recv__msg[0];
  assign recv__rdy[0] = routers__recv__rdy[0][4];
  assign routers__recv__val[0][4] = recv__val[0];
  assign send__msg[0] = routers__send__msg[0][4];
  assign routers__send__rdy[0][4] = send__rdy[0];
  assign send__val[0] = routers__send__val[0][4];
  assign routers__send__rdy[0][1] = 1'd0;
  assign routers__recv__val[0][1] = 1'd0;
  assign routers__recv__msg[0][1] = { 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 3'd0, 3'd0, 8'd0, 2'd0, { 4'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 9'd0, { 6'd0, 1'd0, { {3'd0, 3'd0, 3'd0, 3'd0} }, { {3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0} }, { {2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, 3'd0, 1'd0, { {2'd0, 2'd0, 2'd0, 2'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} } }, 4'd0 } };
  assign routers__send__rdy[0][2] = 1'd0;
  assign routers__recv__val[0][2] = 1'd0;
  assign routers__recv__msg[0][2] = { 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 3'd0, 3'd0, 8'd0, 2'd0, { 4'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 9'd0, { 6'd0, 1'd0, { {3'd0, 3'd0, 3'd0, 3'd0} }, { {3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0} }, { {2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, 3'd0, 1'd0, { {2'd0, 2'd0, 2'd0, 2'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} } }, 4'd0 } };
  assign channels__recv__msg[2] = routers__send__msg[1][0];
  assign routers__send__rdy[1][0] = channels__recv__rdy[2];
  assign channels__recv__val[2] = routers__send__val[1][0];
  assign routers__recv__msg[4][1] = channels__send__msg[2];
  assign channels__send__rdy[2] = routers__recv__rdy[4][1];
  assign routers__recv__val[4][1] = channels__send__val[2];
  assign channels__recv__msg[3] = routers__send__msg[1][2];
  assign routers__send__rdy[1][2] = channels__recv__rdy[3];
  assign channels__recv__val[3] = routers__send__val[1][2];
  assign routers__recv__msg[0][3] = channels__send__msg[3];
  assign channels__send__rdy[3] = routers__recv__rdy[0][3];
  assign routers__recv__val[0][3] = channels__send__val[3];
  assign channels__recv__msg[4] = routers__send__msg[1][3];
  assign routers__send__rdy[1][3] = channels__recv__rdy[4];
  assign channels__recv__val[4] = routers__send__val[1][3];
  assign routers__recv__msg[2][2] = channels__send__msg[4];
  assign channels__send__rdy[4] = routers__recv__rdy[2][2];
  assign routers__recv__val[2][2] = channels__send__val[4];
  assign routers__recv__msg[1][4] = recv__msg[1];
  assign recv__rdy[1] = routers__recv__rdy[1][4];
  assign routers__recv__val[1][4] = recv__val[1];
  assign send__msg[1] = routers__send__msg[1][4];
  assign routers__send__rdy[1][4] = send__rdy[1];
  assign send__val[1] = routers__send__val[1][4];
  assign routers__send__rdy[1][1] = 1'd0;
  assign routers__recv__val[1][1] = 1'd0;
  assign routers__recv__msg[1][1] = { 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 3'd0, 3'd0, 8'd0, 2'd0, { 4'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 9'd0, { 6'd0, 1'd0, { {3'd0, 3'd0, 3'd0, 3'd0} }, { {3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0} }, { {2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, 3'd0, 1'd0, { {2'd0, 2'd0, 2'd0, 2'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} } }, 4'd0 } };
  assign channels__recv__msg[5] = routers__send__msg[2][0];
  assign routers__send__rdy[2][0] = channels__recv__rdy[5];
  assign channels__recv__val[5] = routers__send__val[2][0];
  assign routers__recv__msg[5][1] = channels__send__msg[5];
  assign channels__send__rdy[5] = routers__recv__rdy[5][1];
  assign routers__recv__val[5][1] = channels__send__val[5];
  assign channels__recv__msg[6] = routers__send__msg[2][2];
  assign routers__send__rdy[2][2] = channels__recv__rdy[6];
  assign channels__recv__val[6] = routers__send__val[2][2];
  assign routers__recv__msg[1][3] = channels__send__msg[6];
  assign channels__send__rdy[6] = routers__recv__rdy[1][3];
  assign routers__recv__val[1][3] = channels__send__val[6];
  assign routers__recv__msg[2][4] = recv__msg[2];
  assign recv__rdy[2] = routers__recv__rdy[2][4];
  assign routers__recv__val[2][4] = recv__val[2];
  assign send__msg[2] = routers__send__msg[2][4];
  assign routers__send__rdy[2][4] = send__rdy[2];
  assign send__val[2] = routers__send__val[2][4];
  assign routers__send__rdy[2][1] = 1'd0;
  assign routers__recv__val[2][1] = 1'd0;
  assign routers__recv__msg[2][1] = { 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 3'd0, 3'd0, 8'd0, 2'd0, { 4'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 9'd0, { 6'd0, 1'd0, { {3'd0, 3'd0, 3'd0, 3'd0} }, { {3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0} }, { {2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, 3'd0, 1'd0, { {2'd0, 2'd0, 2'd0, 2'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} } }, 4'd0 } };
  assign routers__send__rdy[2][3] = 1'd0;
  assign routers__recv__val[2][3] = 1'd0;
  assign routers__recv__msg[2][3] = { 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 3'd0, 3'd0, 8'd0, 2'd0, { 4'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 9'd0, { 6'd0, 1'd0, { {3'd0, 3'd0, 3'd0, 3'd0} }, { {3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0} }, { {2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, 3'd0, 1'd0, { {2'd0, 2'd0, 2'd0, 2'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} } }, 4'd0 } };
  assign channels__recv__msg[7] = routers__send__msg[3][1];
  assign routers__send__rdy[3][1] = channels__recv__rdy[7];
  assign channels__recv__val[7] = routers__send__val[3][1];
  assign routers__recv__msg[0][0] = channels__send__msg[7];
  assign channels__send__rdy[7] = routers__recv__rdy[0][0];
  assign routers__recv__val[0][0] = channels__send__val[7];
  assign channels__recv__msg[8] = routers__send__msg[3][0];
  assign routers__send__rdy[3][0] = channels__recv__rdy[8];
  assign channels__recv__val[8] = routers__send__val[3][0];
  assign routers__recv__msg[6][1] = channels__send__msg[8];
  assign channels__send__rdy[8] = routers__recv__rdy[6][1];
  assign routers__recv__val[6][1] = channels__send__val[8];
  assign channels__recv__msg[9] = routers__send__msg[3][3];
  assign routers__send__rdy[3][3] = channels__recv__rdy[9];
  assign channels__recv__val[9] = routers__send__val[3][3];
  assign routers__recv__msg[4][2] = channels__send__msg[9];
  assign channels__send__rdy[9] = routers__recv__rdy[4][2];
  assign routers__recv__val[4][2] = channels__send__val[9];
  assign routers__recv__msg[3][4] = recv__msg[3];
  assign recv__rdy[3] = routers__recv__rdy[3][4];
  assign routers__recv__val[3][4] = recv__val[3];
  assign send__msg[3] = routers__send__msg[3][4];
  assign routers__send__rdy[3][4] = send__rdy[3];
  assign send__val[3] = routers__send__val[3][4];
  assign routers__send__rdy[3][2] = 1'd0;
  assign routers__recv__val[3][2] = 1'd0;
  assign routers__recv__msg[3][2] = { 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 3'd0, 3'd0, 8'd0, 2'd0, { 4'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 9'd0, { 6'd0, 1'd0, { {3'd0, 3'd0, 3'd0, 3'd0} }, { {3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0} }, { {2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, 3'd0, 1'd0, { {2'd0, 2'd0, 2'd0, 2'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} } }, 4'd0 } };
  assign channels__recv__msg[10] = routers__send__msg[4][1];
  assign routers__send__rdy[4][1] = channels__recv__rdy[10];
  assign channels__recv__val[10] = routers__send__val[4][1];
  assign routers__recv__msg[1][0] = channels__send__msg[10];
  assign channels__send__rdy[10] = routers__recv__rdy[1][0];
  assign routers__recv__val[1][0] = channels__send__val[10];
  assign channels__recv__msg[11] = routers__send__msg[4][0];
  assign routers__send__rdy[4][0] = channels__recv__rdy[11];
  assign channels__recv__val[11] = routers__send__val[4][0];
  assign routers__recv__msg[7][1] = channels__send__msg[11];
  assign channels__send__rdy[11] = routers__recv__rdy[7][1];
  assign routers__recv__val[7][1] = channels__send__val[11];
  assign channels__recv__msg[12] = routers__send__msg[4][2];
  assign routers__send__rdy[4][2] = channels__recv__rdy[12];
  assign channels__recv__val[12] = routers__send__val[4][2];
  assign routers__recv__msg[3][3] = channels__send__msg[12];
  assign channels__send__rdy[12] = routers__recv__rdy[3][3];
  assign routers__recv__val[3][3] = channels__send__val[12];
  assign channels__recv__msg[13] = routers__send__msg[4][3];
  assign routers__send__rdy[4][3] = channels__recv__rdy[13];
  assign channels__recv__val[13] = routers__send__val[4][3];
  assign routers__recv__msg[5][2] = channels__send__msg[13];
  assign channels__send__rdy[13] = routers__recv__rdy[5][2];
  assign routers__recv__val[5][2] = channels__send__val[13];
  assign routers__recv__msg[4][4] = recv__msg[4];
  assign recv__rdy[4] = routers__recv__rdy[4][4];
  assign routers__recv__val[4][4] = recv__val[4];
  assign send__msg[4] = routers__send__msg[4][4];
  assign routers__send__rdy[4][4] = send__rdy[4];
  assign send__val[4] = routers__send__val[4][4];
  assign channels__recv__msg[14] = routers__send__msg[5][1];
  assign routers__send__rdy[5][1] = channels__recv__rdy[14];
  assign channels__recv__val[14] = routers__send__val[5][1];
  assign routers__recv__msg[2][0] = channels__send__msg[14];
  assign channels__send__rdy[14] = routers__recv__rdy[2][0];
  assign routers__recv__val[2][0] = channels__send__val[14];
  assign channels__recv__msg[15] = routers__send__msg[5][0];
  assign routers__send__rdy[5][0] = channels__recv__rdy[15];
  assign channels__recv__val[15] = routers__send__val[5][0];
  assign routers__recv__msg[8][1] = channels__send__msg[15];
  assign channels__send__rdy[15] = routers__recv__rdy[8][1];
  assign routers__recv__val[8][1] = channels__send__val[15];
  assign channels__recv__msg[16] = routers__send__msg[5][2];
  assign routers__send__rdy[5][2] = channels__recv__rdy[16];
  assign channels__recv__val[16] = routers__send__val[5][2];
  assign routers__recv__msg[4][3] = channels__send__msg[16];
  assign channels__send__rdy[16] = routers__recv__rdy[4][3];
  assign routers__recv__val[4][3] = channels__send__val[16];
  assign routers__recv__msg[5][4] = recv__msg[5];
  assign recv__rdy[5] = routers__recv__rdy[5][4];
  assign routers__recv__val[5][4] = recv__val[5];
  assign send__msg[5] = routers__send__msg[5][4];
  assign routers__send__rdy[5][4] = send__rdy[5];
  assign send__val[5] = routers__send__val[5][4];
  assign routers__send__rdy[5][3] = 1'd0;
  assign routers__recv__val[5][3] = 1'd0;
  assign routers__recv__msg[5][3] = { 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 3'd0, 3'd0, 8'd0, 2'd0, { 4'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 9'd0, { 6'd0, 1'd0, { {3'd0, 3'd0, 3'd0, 3'd0} }, { {3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0} }, { {2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, 3'd0, 1'd0, { {2'd0, 2'd0, 2'd0, 2'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} } }, 4'd0 } };
  assign channels__recv__msg[17] = routers__send__msg[6][1];
  assign routers__send__rdy[6][1] = channels__recv__rdy[17];
  assign channels__recv__val[17] = routers__send__val[6][1];
  assign routers__recv__msg[3][0] = channels__send__msg[17];
  assign channels__send__rdy[17] = routers__recv__rdy[3][0];
  assign routers__recv__val[3][0] = channels__send__val[17];
  assign channels__recv__msg[18] = routers__send__msg[6][3];
  assign routers__send__rdy[6][3] = channels__recv__rdy[18];
  assign channels__recv__val[18] = routers__send__val[6][3];
  assign routers__recv__msg[7][2] = channels__send__msg[18];
  assign channels__send__rdy[18] = routers__recv__rdy[7][2];
  assign routers__recv__val[7][2] = channels__send__val[18];
  assign routers__recv__msg[6][4] = recv__msg[6];
  assign recv__rdy[6] = routers__recv__rdy[6][4];
  assign routers__recv__val[6][4] = recv__val[6];
  assign send__msg[6] = routers__send__msg[6][4];
  assign routers__send__rdy[6][4] = send__rdy[6];
  assign send__val[6] = routers__send__val[6][4];
  assign routers__send__rdy[6][0] = 1'd0;
  assign routers__recv__val[6][0] = 1'd0;
  assign routers__recv__msg[6][0] = { 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 3'd0, 3'd0, 8'd0, 2'd0, { 4'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 9'd0, { 6'd0, 1'd0, { {3'd0, 3'd0, 3'd0, 3'd0} }, { {3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0} }, { {2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, 3'd0, 1'd0, { {2'd0, 2'd0, 2'd0, 2'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} } }, 4'd0 } };
  assign routers__send__rdy[6][2] = 1'd0;
  assign routers__recv__val[6][2] = 1'd0;
  assign routers__recv__msg[6][2] = { 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 3'd0, 3'd0, 8'd0, 2'd0, { 4'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 9'd0, { 6'd0, 1'd0, { {3'd0, 3'd0, 3'd0, 3'd0} }, { {3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0} }, { {2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, 3'd0, 1'd0, { {2'd0, 2'd0, 2'd0, 2'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} } }, 4'd0 } };
  assign channels__recv__msg[19] = routers__send__msg[7][1];
  assign routers__send__rdy[7][1] = channels__recv__rdy[19];
  assign channels__recv__val[19] = routers__send__val[7][1];
  assign routers__recv__msg[4][0] = channels__send__msg[19];
  assign channels__send__rdy[19] = routers__recv__rdy[4][0];
  assign routers__recv__val[4][0] = channels__send__val[19];
  assign channels__recv__msg[20] = routers__send__msg[7][2];
  assign routers__send__rdy[7][2] = channels__recv__rdy[20];
  assign channels__recv__val[20] = routers__send__val[7][2];
  assign routers__recv__msg[6][3] = channels__send__msg[20];
  assign channels__send__rdy[20] = routers__recv__rdy[6][3];
  assign routers__recv__val[6][3] = channels__send__val[20];
  assign channels__recv__msg[21] = routers__send__msg[7][3];
  assign routers__send__rdy[7][3] = channels__recv__rdy[21];
  assign channels__recv__val[21] = routers__send__val[7][3];
  assign routers__recv__msg[8][2] = channels__send__msg[21];
  assign channels__send__rdy[21] = routers__recv__rdy[8][2];
  assign routers__recv__val[8][2] = channels__send__val[21];
  assign routers__recv__msg[7][4] = recv__msg[7];
  assign recv__rdy[7] = routers__recv__rdy[7][4];
  assign routers__recv__val[7][4] = recv__val[7];
  assign send__msg[7] = routers__send__msg[7][4];
  assign routers__send__rdy[7][4] = send__rdy[7];
  assign send__val[7] = routers__send__val[7][4];
  assign routers__send__rdy[7][0] = 1'd0;
  assign routers__recv__val[7][0] = 1'd0;
  assign routers__recv__msg[7][0] = { 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 3'd0, 3'd0, 8'd0, 2'd0, { 4'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 9'd0, { 6'd0, 1'd0, { {3'd0, 3'd0, 3'd0, 3'd0} }, { {3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0} }, { {2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, 3'd0, 1'd0, { {2'd0, 2'd0, 2'd0, 2'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} } }, 4'd0 } };
  assign channels__recv__msg[22] = routers__send__msg[8][1];
  assign routers__send__rdy[8][1] = channels__recv__rdy[22];
  assign channels__recv__val[22] = routers__send__val[8][1];
  assign routers__recv__msg[5][0] = channels__send__msg[22];
  assign channels__send__rdy[22] = routers__recv__rdy[5][0];
  assign routers__recv__val[5][0] = channels__send__val[22];
  assign channels__recv__msg[23] = routers__send__msg[8][2];
  assign routers__send__rdy[8][2] = channels__recv__rdy[23];
  assign channels__recv__val[23] = routers__send__val[8][2];
  assign routers__recv__msg[7][3] = channels__send__msg[23];
  assign channels__send__rdy[23] = routers__recv__rdy[7][3];
  assign routers__recv__val[7][3] = channels__send__val[23];
  assign routers__recv__msg[8][4] = recv__msg[8];
  assign recv__rdy[8] = routers__recv__rdy[8][4];
  assign routers__recv__val[8][4] = recv__val[8];
  assign send__msg[8] = routers__send__msg[8][4];
  assign routers__send__rdy[8][4] = send__rdy[8];
  assign send__val[8] = routers__send__val[8][4];
  assign routers__send__rdy[8][0] = 1'd0;
  assign routers__recv__val[8][0] = 1'd0;
  assign routers__recv__msg[8][0] = { 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 3'd0, 3'd0, 8'd0, 2'd0, { 4'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 9'd0, { 6'd0, 1'd0, { {3'd0, 3'd0, 3'd0, 3'd0} }, { {3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0} }, { {2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, 3'd0, 1'd0, { {2'd0, 2'd0, 2'd0, 2'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} } }, 4'd0 } };
  assign routers__send__rdy[8][3] = 1'd0;
  assign routers__recv__val[8][3] = 1'd0;
  assign routers__recv__msg[8][3] = { 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 3'd0, 3'd0, 8'd0, 2'd0, { 4'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 9'd0, { 6'd0, 1'd0, { {3'd0, 3'd0, 3'd0, 3'd0} }, { {3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0} }, { {2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, 3'd0, 1'd0, { {2'd0, 2'd0, 2'd0, 2'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} } }, 4'd0 } };

endmodule


// PyMTL Component MeshMultiCgraRTL Definition
// Full name: MeshMultiCgraRTL__CgraDataType_CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1__PredicateType_CGRAData_1_1__payload_1__predicate_1__CtrlPktType_IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74__CgraPayloadType_MultiCgraPayload_Cmd_Data_DataAddr_Ctrl_CtrlAddr__cc89ed621b71ae36__CtrlSignalType_CGRAConfig_6_4_2_4_4_1_3__3422a5e506e60ebf__NocPktType_InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d__cgra_rows_3__cgra_columns_3__tile_rows_2__tile_columns_2__ctrl_mem_size_16__data_mem_size_global_288__data_mem_size_per_bank_16__num_banks_per_cgra_2__num_registers_per_reg_bank_16__num_ctrl_2__total_steps_2__FunctionUnit_FlexibleFuRTL__FuList_[<class 'VectorCGRA.fu.single.AdderRTL.AdderRTL'>, <class 'VectorCGRA.fu.single.MulRTL.MulRTL'>, <class 'VectorCGRA.fu.single.LogicRTL.LogicRTL'>, <class 'VectorCGRA.fu.single.ShifterRTL.ShifterRTL'>, <class 'VectorCGRA.fu.single.PhiRTL.PhiRTL'>, <class 'VectorCGRA.fu.single.CompRTL.CompRTL'>, <class 'VectorCGRA.fu.single.BranchRTL.BranchRTL'>, <class 'VectorCGRA.fu.single.MemUnitRTL.MemUnitRTL'>, <class 'VectorCGRA.fu.single.SelRTL.SelRTL'>, <class 'VectorCGRA.fu.float.FpAddRTL.FpAddRTL'>, <class 'VectorCGRA.fu.float.FpMulRTL.FpMulRTL'>, <class 'VectorCGRA.fu.double.SeqMulAdderRTL.SeqMulAdderRTL'>, <class 'VectorCGRA.fu.vector.VectorMulComboRTL.VectorMulComboRTL'>, <class 'VectorCGRA.fu.vector.VectorAdderComboRTL.VectorAdderComboRTL'>, <class 'VectorCGRA.fu.single.NahRTL.NahRTL'>]__controller2addr_map_{0: [0, 31], 1: [32, 63], 2: [64, 95], 3: [96, 127], 4: [128, 159], 5: [160, 191], 6: [192, 223], 7: [224, 255], 8: [256, 287]}__preload_data_None
// At /project/chriskim00/Ruihong/CGRA/VectorCGRA/multi_cgra/MeshMultiCgraRTL.py

module MeshMultiCgraRTL__22e761dce011167a
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 recv_from_cpu_pkt__msg  ,
  output logic [0:0] recv_from_cpu_pkt__rdy  ,
  input logic [0:0] recv_from_cpu_pkt__val  ,
  output IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 send_to_cpu_pkt__msg  ,
  input logic [0:0] send_to_cpu_pkt__rdy  ,
  output logic [0:0] send_to_cpu_pkt__val  
);
  //-------------------------------------------------------------
  // Component cgra[0:8]
  //-------------------------------------------------------------

  logic [8:0] cgra__address_lower [0:8];
  logic [8:0] cgra__address_upper [0:8];
  logic [3:0] cgra__cgra_id [0:8];
  logic [0:0] cgra__clk [0:8];
  logic [0:0] cgra__reset [0:8];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 cgra__recv_data_on_boundary_east__msg [0:8][0:1];
  logic [0:0] cgra__recv_data_on_boundary_east__rdy [0:8][0:1];
  logic [0:0] cgra__recv_data_on_boundary_east__val [0:8][0:1];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 cgra__recv_data_on_boundary_north__msg [0:8][0:1];
  logic [0:0] cgra__recv_data_on_boundary_north__rdy [0:8][0:1];
  logic [0:0] cgra__recv_data_on_boundary_north__val [0:8][0:1];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 cgra__recv_data_on_boundary_south__msg [0:8][0:1];
  logic [0:0] cgra__recv_data_on_boundary_south__rdy [0:8][0:1];
  logic [0:0] cgra__recv_data_on_boundary_south__val [0:8][0:1];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 cgra__recv_data_on_boundary_west__msg [0:8][0:1];
  logic [0:0] cgra__recv_data_on_boundary_west__rdy [0:8][0:1];
  logic [0:0] cgra__recv_data_on_boundary_west__val [0:8][0:1];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 cgra__recv_from_cpu_pkt__msg [0:8];
  logic [0:0] cgra__recv_from_cpu_pkt__rdy [0:8];
  logic [0:0] cgra__recv_from_cpu_pkt__val [0:8];
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d cgra__recv_from_inter_cgra_noc__msg [0:8];
  logic [0:0] cgra__recv_from_inter_cgra_noc__rdy [0:8];
  logic [0:0] cgra__recv_from_inter_cgra_noc__val [0:8];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 cgra__send_data_on_boundary_east__msg [0:8][0:1];
  logic [0:0] cgra__send_data_on_boundary_east__rdy [0:8][0:1];
  logic [0:0] cgra__send_data_on_boundary_east__val [0:8][0:1];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 cgra__send_data_on_boundary_north__msg [0:8][0:1];
  logic [0:0] cgra__send_data_on_boundary_north__rdy [0:8][0:1];
  logic [0:0] cgra__send_data_on_boundary_north__val [0:8][0:1];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 cgra__send_data_on_boundary_south__msg [0:8][0:1];
  logic [0:0] cgra__send_data_on_boundary_south__rdy [0:8][0:1];
  logic [0:0] cgra__send_data_on_boundary_south__val [0:8][0:1];
  CgraData_32_1_1_1__payload_32__predicate_1__bypass_1__delay_1 cgra__send_data_on_boundary_west__msg [0:8][0:1];
  logic [0:0] cgra__send_data_on_boundary_west__rdy [0:8][0:1];
  logic [0:0] cgra__send_data_on_boundary_west__val [0:8][0:1];
  IntraCgraPacket_9_3x3_4_8_2_CgraPayload__da6bfa9093a6ea74 cgra__send_to_cpu_pkt__msg [0:8];
  logic [0:0] cgra__send_to_cpu_pkt__rdy [0:8];
  logic [0:0] cgra__send_to_cpu_pkt__val [0:8];
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d cgra__send_to_inter_cgra_noc__msg [0:8];
  logic [0:0] cgra__send_to_inter_cgra_noc__rdy [0:8];
  logic [0:0] cgra__send_to_inter_cgra_noc__val [0:8];

  CgraRTL__f1d9d60478fa8731 cgra__0
  (
    .address_lower( cgra__address_lower[0] ),
    .address_upper( cgra__address_upper[0] ),
    .cgra_id( cgra__cgra_id[0] ),
    .clk( cgra__clk[0] ),
    .reset( cgra__reset[0] ),
    .recv_data_on_boundary_east__msg( cgra__recv_data_on_boundary_east__msg[0] ),
    .recv_data_on_boundary_east__rdy( cgra__recv_data_on_boundary_east__rdy[0] ),
    .recv_data_on_boundary_east__val( cgra__recv_data_on_boundary_east__val[0] ),
    .recv_data_on_boundary_north__msg( cgra__recv_data_on_boundary_north__msg[0] ),
    .recv_data_on_boundary_north__rdy( cgra__recv_data_on_boundary_north__rdy[0] ),
    .recv_data_on_boundary_north__val( cgra__recv_data_on_boundary_north__val[0] ),
    .recv_data_on_boundary_south__msg( cgra__recv_data_on_boundary_south__msg[0] ),
    .recv_data_on_boundary_south__rdy( cgra__recv_data_on_boundary_south__rdy[0] ),
    .recv_data_on_boundary_south__val( cgra__recv_data_on_boundary_south__val[0] ),
    .recv_data_on_boundary_west__msg( cgra__recv_data_on_boundary_west__msg[0] ),
    .recv_data_on_boundary_west__rdy( cgra__recv_data_on_boundary_west__rdy[0] ),
    .recv_data_on_boundary_west__val( cgra__recv_data_on_boundary_west__val[0] ),
    .recv_from_cpu_pkt__msg( cgra__recv_from_cpu_pkt__msg[0] ),
    .recv_from_cpu_pkt__rdy( cgra__recv_from_cpu_pkt__rdy[0] ),
    .recv_from_cpu_pkt__val( cgra__recv_from_cpu_pkt__val[0] ),
    .recv_from_inter_cgra_noc__msg( cgra__recv_from_inter_cgra_noc__msg[0] ),
    .recv_from_inter_cgra_noc__rdy( cgra__recv_from_inter_cgra_noc__rdy[0] ),
    .recv_from_inter_cgra_noc__val( cgra__recv_from_inter_cgra_noc__val[0] ),
    .send_data_on_boundary_east__msg( cgra__send_data_on_boundary_east__msg[0] ),
    .send_data_on_boundary_east__rdy( cgra__send_data_on_boundary_east__rdy[0] ),
    .send_data_on_boundary_east__val( cgra__send_data_on_boundary_east__val[0] ),
    .send_data_on_boundary_north__msg( cgra__send_data_on_boundary_north__msg[0] ),
    .send_data_on_boundary_north__rdy( cgra__send_data_on_boundary_north__rdy[0] ),
    .send_data_on_boundary_north__val( cgra__send_data_on_boundary_north__val[0] ),
    .send_data_on_boundary_south__msg( cgra__send_data_on_boundary_south__msg[0] ),
    .send_data_on_boundary_south__rdy( cgra__send_data_on_boundary_south__rdy[0] ),
    .send_data_on_boundary_south__val( cgra__send_data_on_boundary_south__val[0] ),
    .send_data_on_boundary_west__msg( cgra__send_data_on_boundary_west__msg[0] ),
    .send_data_on_boundary_west__rdy( cgra__send_data_on_boundary_west__rdy[0] ),
    .send_data_on_boundary_west__val( cgra__send_data_on_boundary_west__val[0] ),
    .send_to_cpu_pkt__msg( cgra__send_to_cpu_pkt__msg[0] ),
    .send_to_cpu_pkt__rdy( cgra__send_to_cpu_pkt__rdy[0] ),
    .send_to_cpu_pkt__val( cgra__send_to_cpu_pkt__val[0] ),
    .send_to_inter_cgra_noc__msg( cgra__send_to_inter_cgra_noc__msg[0] ),
    .send_to_inter_cgra_noc__rdy( cgra__send_to_inter_cgra_noc__rdy[0] ),
    .send_to_inter_cgra_noc__val( cgra__send_to_inter_cgra_noc__val[0] )
  );

  CgraRTL__f1d9d60478fa8731 cgra__1
  (
    .address_lower( cgra__address_lower[1] ),
    .address_upper( cgra__address_upper[1] ),
    .cgra_id( cgra__cgra_id[1] ),
    .clk( cgra__clk[1] ),
    .reset( cgra__reset[1] ),
    .recv_data_on_boundary_east__msg( cgra__recv_data_on_boundary_east__msg[1] ),
    .recv_data_on_boundary_east__rdy( cgra__recv_data_on_boundary_east__rdy[1] ),
    .recv_data_on_boundary_east__val( cgra__recv_data_on_boundary_east__val[1] ),
    .recv_data_on_boundary_north__msg( cgra__recv_data_on_boundary_north__msg[1] ),
    .recv_data_on_boundary_north__rdy( cgra__recv_data_on_boundary_north__rdy[1] ),
    .recv_data_on_boundary_north__val( cgra__recv_data_on_boundary_north__val[1] ),
    .recv_data_on_boundary_south__msg( cgra__recv_data_on_boundary_south__msg[1] ),
    .recv_data_on_boundary_south__rdy( cgra__recv_data_on_boundary_south__rdy[1] ),
    .recv_data_on_boundary_south__val( cgra__recv_data_on_boundary_south__val[1] ),
    .recv_data_on_boundary_west__msg( cgra__recv_data_on_boundary_west__msg[1] ),
    .recv_data_on_boundary_west__rdy( cgra__recv_data_on_boundary_west__rdy[1] ),
    .recv_data_on_boundary_west__val( cgra__recv_data_on_boundary_west__val[1] ),
    .recv_from_cpu_pkt__msg( cgra__recv_from_cpu_pkt__msg[1] ),
    .recv_from_cpu_pkt__rdy( cgra__recv_from_cpu_pkt__rdy[1] ),
    .recv_from_cpu_pkt__val( cgra__recv_from_cpu_pkt__val[1] ),
    .recv_from_inter_cgra_noc__msg( cgra__recv_from_inter_cgra_noc__msg[1] ),
    .recv_from_inter_cgra_noc__rdy( cgra__recv_from_inter_cgra_noc__rdy[1] ),
    .recv_from_inter_cgra_noc__val( cgra__recv_from_inter_cgra_noc__val[1] ),
    .send_data_on_boundary_east__msg( cgra__send_data_on_boundary_east__msg[1] ),
    .send_data_on_boundary_east__rdy( cgra__send_data_on_boundary_east__rdy[1] ),
    .send_data_on_boundary_east__val( cgra__send_data_on_boundary_east__val[1] ),
    .send_data_on_boundary_north__msg( cgra__send_data_on_boundary_north__msg[1] ),
    .send_data_on_boundary_north__rdy( cgra__send_data_on_boundary_north__rdy[1] ),
    .send_data_on_boundary_north__val( cgra__send_data_on_boundary_north__val[1] ),
    .send_data_on_boundary_south__msg( cgra__send_data_on_boundary_south__msg[1] ),
    .send_data_on_boundary_south__rdy( cgra__send_data_on_boundary_south__rdy[1] ),
    .send_data_on_boundary_south__val( cgra__send_data_on_boundary_south__val[1] ),
    .send_data_on_boundary_west__msg( cgra__send_data_on_boundary_west__msg[1] ),
    .send_data_on_boundary_west__rdy( cgra__send_data_on_boundary_west__rdy[1] ),
    .send_data_on_boundary_west__val( cgra__send_data_on_boundary_west__val[1] ),
    .send_to_cpu_pkt__msg( cgra__send_to_cpu_pkt__msg[1] ),
    .send_to_cpu_pkt__rdy( cgra__send_to_cpu_pkt__rdy[1] ),
    .send_to_cpu_pkt__val( cgra__send_to_cpu_pkt__val[1] ),
    .send_to_inter_cgra_noc__msg( cgra__send_to_inter_cgra_noc__msg[1] ),
    .send_to_inter_cgra_noc__rdy( cgra__send_to_inter_cgra_noc__rdy[1] ),
    .send_to_inter_cgra_noc__val( cgra__send_to_inter_cgra_noc__val[1] )
  );

  CgraRTL__f1d9d60478fa8731 cgra__2
  (
    .address_lower( cgra__address_lower[2] ),
    .address_upper( cgra__address_upper[2] ),
    .cgra_id( cgra__cgra_id[2] ),
    .clk( cgra__clk[2] ),
    .reset( cgra__reset[2] ),
    .recv_data_on_boundary_east__msg( cgra__recv_data_on_boundary_east__msg[2] ),
    .recv_data_on_boundary_east__rdy( cgra__recv_data_on_boundary_east__rdy[2] ),
    .recv_data_on_boundary_east__val( cgra__recv_data_on_boundary_east__val[2] ),
    .recv_data_on_boundary_north__msg( cgra__recv_data_on_boundary_north__msg[2] ),
    .recv_data_on_boundary_north__rdy( cgra__recv_data_on_boundary_north__rdy[2] ),
    .recv_data_on_boundary_north__val( cgra__recv_data_on_boundary_north__val[2] ),
    .recv_data_on_boundary_south__msg( cgra__recv_data_on_boundary_south__msg[2] ),
    .recv_data_on_boundary_south__rdy( cgra__recv_data_on_boundary_south__rdy[2] ),
    .recv_data_on_boundary_south__val( cgra__recv_data_on_boundary_south__val[2] ),
    .recv_data_on_boundary_west__msg( cgra__recv_data_on_boundary_west__msg[2] ),
    .recv_data_on_boundary_west__rdy( cgra__recv_data_on_boundary_west__rdy[2] ),
    .recv_data_on_boundary_west__val( cgra__recv_data_on_boundary_west__val[2] ),
    .recv_from_cpu_pkt__msg( cgra__recv_from_cpu_pkt__msg[2] ),
    .recv_from_cpu_pkt__rdy( cgra__recv_from_cpu_pkt__rdy[2] ),
    .recv_from_cpu_pkt__val( cgra__recv_from_cpu_pkt__val[2] ),
    .recv_from_inter_cgra_noc__msg( cgra__recv_from_inter_cgra_noc__msg[2] ),
    .recv_from_inter_cgra_noc__rdy( cgra__recv_from_inter_cgra_noc__rdy[2] ),
    .recv_from_inter_cgra_noc__val( cgra__recv_from_inter_cgra_noc__val[2] ),
    .send_data_on_boundary_east__msg( cgra__send_data_on_boundary_east__msg[2] ),
    .send_data_on_boundary_east__rdy( cgra__send_data_on_boundary_east__rdy[2] ),
    .send_data_on_boundary_east__val( cgra__send_data_on_boundary_east__val[2] ),
    .send_data_on_boundary_north__msg( cgra__send_data_on_boundary_north__msg[2] ),
    .send_data_on_boundary_north__rdy( cgra__send_data_on_boundary_north__rdy[2] ),
    .send_data_on_boundary_north__val( cgra__send_data_on_boundary_north__val[2] ),
    .send_data_on_boundary_south__msg( cgra__send_data_on_boundary_south__msg[2] ),
    .send_data_on_boundary_south__rdy( cgra__send_data_on_boundary_south__rdy[2] ),
    .send_data_on_boundary_south__val( cgra__send_data_on_boundary_south__val[2] ),
    .send_data_on_boundary_west__msg( cgra__send_data_on_boundary_west__msg[2] ),
    .send_data_on_boundary_west__rdy( cgra__send_data_on_boundary_west__rdy[2] ),
    .send_data_on_boundary_west__val( cgra__send_data_on_boundary_west__val[2] ),
    .send_to_cpu_pkt__msg( cgra__send_to_cpu_pkt__msg[2] ),
    .send_to_cpu_pkt__rdy( cgra__send_to_cpu_pkt__rdy[2] ),
    .send_to_cpu_pkt__val( cgra__send_to_cpu_pkt__val[2] ),
    .send_to_inter_cgra_noc__msg( cgra__send_to_inter_cgra_noc__msg[2] ),
    .send_to_inter_cgra_noc__rdy( cgra__send_to_inter_cgra_noc__rdy[2] ),
    .send_to_inter_cgra_noc__val( cgra__send_to_inter_cgra_noc__val[2] )
  );

  CgraRTL__f1d9d60478fa8731 cgra__3
  (
    .address_lower( cgra__address_lower[3] ),
    .address_upper( cgra__address_upper[3] ),
    .cgra_id( cgra__cgra_id[3] ),
    .clk( cgra__clk[3] ),
    .reset( cgra__reset[3] ),
    .recv_data_on_boundary_east__msg( cgra__recv_data_on_boundary_east__msg[3] ),
    .recv_data_on_boundary_east__rdy( cgra__recv_data_on_boundary_east__rdy[3] ),
    .recv_data_on_boundary_east__val( cgra__recv_data_on_boundary_east__val[3] ),
    .recv_data_on_boundary_north__msg( cgra__recv_data_on_boundary_north__msg[3] ),
    .recv_data_on_boundary_north__rdy( cgra__recv_data_on_boundary_north__rdy[3] ),
    .recv_data_on_boundary_north__val( cgra__recv_data_on_boundary_north__val[3] ),
    .recv_data_on_boundary_south__msg( cgra__recv_data_on_boundary_south__msg[3] ),
    .recv_data_on_boundary_south__rdy( cgra__recv_data_on_boundary_south__rdy[3] ),
    .recv_data_on_boundary_south__val( cgra__recv_data_on_boundary_south__val[3] ),
    .recv_data_on_boundary_west__msg( cgra__recv_data_on_boundary_west__msg[3] ),
    .recv_data_on_boundary_west__rdy( cgra__recv_data_on_boundary_west__rdy[3] ),
    .recv_data_on_boundary_west__val( cgra__recv_data_on_boundary_west__val[3] ),
    .recv_from_cpu_pkt__msg( cgra__recv_from_cpu_pkt__msg[3] ),
    .recv_from_cpu_pkt__rdy( cgra__recv_from_cpu_pkt__rdy[3] ),
    .recv_from_cpu_pkt__val( cgra__recv_from_cpu_pkt__val[3] ),
    .recv_from_inter_cgra_noc__msg( cgra__recv_from_inter_cgra_noc__msg[3] ),
    .recv_from_inter_cgra_noc__rdy( cgra__recv_from_inter_cgra_noc__rdy[3] ),
    .recv_from_inter_cgra_noc__val( cgra__recv_from_inter_cgra_noc__val[3] ),
    .send_data_on_boundary_east__msg( cgra__send_data_on_boundary_east__msg[3] ),
    .send_data_on_boundary_east__rdy( cgra__send_data_on_boundary_east__rdy[3] ),
    .send_data_on_boundary_east__val( cgra__send_data_on_boundary_east__val[3] ),
    .send_data_on_boundary_north__msg( cgra__send_data_on_boundary_north__msg[3] ),
    .send_data_on_boundary_north__rdy( cgra__send_data_on_boundary_north__rdy[3] ),
    .send_data_on_boundary_north__val( cgra__send_data_on_boundary_north__val[3] ),
    .send_data_on_boundary_south__msg( cgra__send_data_on_boundary_south__msg[3] ),
    .send_data_on_boundary_south__rdy( cgra__send_data_on_boundary_south__rdy[3] ),
    .send_data_on_boundary_south__val( cgra__send_data_on_boundary_south__val[3] ),
    .send_data_on_boundary_west__msg( cgra__send_data_on_boundary_west__msg[3] ),
    .send_data_on_boundary_west__rdy( cgra__send_data_on_boundary_west__rdy[3] ),
    .send_data_on_boundary_west__val( cgra__send_data_on_boundary_west__val[3] ),
    .send_to_cpu_pkt__msg( cgra__send_to_cpu_pkt__msg[3] ),
    .send_to_cpu_pkt__rdy( cgra__send_to_cpu_pkt__rdy[3] ),
    .send_to_cpu_pkt__val( cgra__send_to_cpu_pkt__val[3] ),
    .send_to_inter_cgra_noc__msg( cgra__send_to_inter_cgra_noc__msg[3] ),
    .send_to_inter_cgra_noc__rdy( cgra__send_to_inter_cgra_noc__rdy[3] ),
    .send_to_inter_cgra_noc__val( cgra__send_to_inter_cgra_noc__val[3] )
  );

  CgraRTL__f1d9d60478fa8731 cgra__4
  (
    .address_lower( cgra__address_lower[4] ),
    .address_upper( cgra__address_upper[4] ),
    .cgra_id( cgra__cgra_id[4] ),
    .clk( cgra__clk[4] ),
    .reset( cgra__reset[4] ),
    .recv_data_on_boundary_east__msg( cgra__recv_data_on_boundary_east__msg[4] ),
    .recv_data_on_boundary_east__rdy( cgra__recv_data_on_boundary_east__rdy[4] ),
    .recv_data_on_boundary_east__val( cgra__recv_data_on_boundary_east__val[4] ),
    .recv_data_on_boundary_north__msg( cgra__recv_data_on_boundary_north__msg[4] ),
    .recv_data_on_boundary_north__rdy( cgra__recv_data_on_boundary_north__rdy[4] ),
    .recv_data_on_boundary_north__val( cgra__recv_data_on_boundary_north__val[4] ),
    .recv_data_on_boundary_south__msg( cgra__recv_data_on_boundary_south__msg[4] ),
    .recv_data_on_boundary_south__rdy( cgra__recv_data_on_boundary_south__rdy[4] ),
    .recv_data_on_boundary_south__val( cgra__recv_data_on_boundary_south__val[4] ),
    .recv_data_on_boundary_west__msg( cgra__recv_data_on_boundary_west__msg[4] ),
    .recv_data_on_boundary_west__rdy( cgra__recv_data_on_boundary_west__rdy[4] ),
    .recv_data_on_boundary_west__val( cgra__recv_data_on_boundary_west__val[4] ),
    .recv_from_cpu_pkt__msg( cgra__recv_from_cpu_pkt__msg[4] ),
    .recv_from_cpu_pkt__rdy( cgra__recv_from_cpu_pkt__rdy[4] ),
    .recv_from_cpu_pkt__val( cgra__recv_from_cpu_pkt__val[4] ),
    .recv_from_inter_cgra_noc__msg( cgra__recv_from_inter_cgra_noc__msg[4] ),
    .recv_from_inter_cgra_noc__rdy( cgra__recv_from_inter_cgra_noc__rdy[4] ),
    .recv_from_inter_cgra_noc__val( cgra__recv_from_inter_cgra_noc__val[4] ),
    .send_data_on_boundary_east__msg( cgra__send_data_on_boundary_east__msg[4] ),
    .send_data_on_boundary_east__rdy( cgra__send_data_on_boundary_east__rdy[4] ),
    .send_data_on_boundary_east__val( cgra__send_data_on_boundary_east__val[4] ),
    .send_data_on_boundary_north__msg( cgra__send_data_on_boundary_north__msg[4] ),
    .send_data_on_boundary_north__rdy( cgra__send_data_on_boundary_north__rdy[4] ),
    .send_data_on_boundary_north__val( cgra__send_data_on_boundary_north__val[4] ),
    .send_data_on_boundary_south__msg( cgra__send_data_on_boundary_south__msg[4] ),
    .send_data_on_boundary_south__rdy( cgra__send_data_on_boundary_south__rdy[4] ),
    .send_data_on_boundary_south__val( cgra__send_data_on_boundary_south__val[4] ),
    .send_data_on_boundary_west__msg( cgra__send_data_on_boundary_west__msg[4] ),
    .send_data_on_boundary_west__rdy( cgra__send_data_on_boundary_west__rdy[4] ),
    .send_data_on_boundary_west__val( cgra__send_data_on_boundary_west__val[4] ),
    .send_to_cpu_pkt__msg( cgra__send_to_cpu_pkt__msg[4] ),
    .send_to_cpu_pkt__rdy( cgra__send_to_cpu_pkt__rdy[4] ),
    .send_to_cpu_pkt__val( cgra__send_to_cpu_pkt__val[4] ),
    .send_to_inter_cgra_noc__msg( cgra__send_to_inter_cgra_noc__msg[4] ),
    .send_to_inter_cgra_noc__rdy( cgra__send_to_inter_cgra_noc__rdy[4] ),
    .send_to_inter_cgra_noc__val( cgra__send_to_inter_cgra_noc__val[4] )
  );

  CgraRTL__f1d9d60478fa8731 cgra__5
  (
    .address_lower( cgra__address_lower[5] ),
    .address_upper( cgra__address_upper[5] ),
    .cgra_id( cgra__cgra_id[5] ),
    .clk( cgra__clk[5] ),
    .reset( cgra__reset[5] ),
    .recv_data_on_boundary_east__msg( cgra__recv_data_on_boundary_east__msg[5] ),
    .recv_data_on_boundary_east__rdy( cgra__recv_data_on_boundary_east__rdy[5] ),
    .recv_data_on_boundary_east__val( cgra__recv_data_on_boundary_east__val[5] ),
    .recv_data_on_boundary_north__msg( cgra__recv_data_on_boundary_north__msg[5] ),
    .recv_data_on_boundary_north__rdy( cgra__recv_data_on_boundary_north__rdy[5] ),
    .recv_data_on_boundary_north__val( cgra__recv_data_on_boundary_north__val[5] ),
    .recv_data_on_boundary_south__msg( cgra__recv_data_on_boundary_south__msg[5] ),
    .recv_data_on_boundary_south__rdy( cgra__recv_data_on_boundary_south__rdy[5] ),
    .recv_data_on_boundary_south__val( cgra__recv_data_on_boundary_south__val[5] ),
    .recv_data_on_boundary_west__msg( cgra__recv_data_on_boundary_west__msg[5] ),
    .recv_data_on_boundary_west__rdy( cgra__recv_data_on_boundary_west__rdy[5] ),
    .recv_data_on_boundary_west__val( cgra__recv_data_on_boundary_west__val[5] ),
    .recv_from_cpu_pkt__msg( cgra__recv_from_cpu_pkt__msg[5] ),
    .recv_from_cpu_pkt__rdy( cgra__recv_from_cpu_pkt__rdy[5] ),
    .recv_from_cpu_pkt__val( cgra__recv_from_cpu_pkt__val[5] ),
    .recv_from_inter_cgra_noc__msg( cgra__recv_from_inter_cgra_noc__msg[5] ),
    .recv_from_inter_cgra_noc__rdy( cgra__recv_from_inter_cgra_noc__rdy[5] ),
    .recv_from_inter_cgra_noc__val( cgra__recv_from_inter_cgra_noc__val[5] ),
    .send_data_on_boundary_east__msg( cgra__send_data_on_boundary_east__msg[5] ),
    .send_data_on_boundary_east__rdy( cgra__send_data_on_boundary_east__rdy[5] ),
    .send_data_on_boundary_east__val( cgra__send_data_on_boundary_east__val[5] ),
    .send_data_on_boundary_north__msg( cgra__send_data_on_boundary_north__msg[5] ),
    .send_data_on_boundary_north__rdy( cgra__send_data_on_boundary_north__rdy[5] ),
    .send_data_on_boundary_north__val( cgra__send_data_on_boundary_north__val[5] ),
    .send_data_on_boundary_south__msg( cgra__send_data_on_boundary_south__msg[5] ),
    .send_data_on_boundary_south__rdy( cgra__send_data_on_boundary_south__rdy[5] ),
    .send_data_on_boundary_south__val( cgra__send_data_on_boundary_south__val[5] ),
    .send_data_on_boundary_west__msg( cgra__send_data_on_boundary_west__msg[5] ),
    .send_data_on_boundary_west__rdy( cgra__send_data_on_boundary_west__rdy[5] ),
    .send_data_on_boundary_west__val( cgra__send_data_on_boundary_west__val[5] ),
    .send_to_cpu_pkt__msg( cgra__send_to_cpu_pkt__msg[5] ),
    .send_to_cpu_pkt__rdy( cgra__send_to_cpu_pkt__rdy[5] ),
    .send_to_cpu_pkt__val( cgra__send_to_cpu_pkt__val[5] ),
    .send_to_inter_cgra_noc__msg( cgra__send_to_inter_cgra_noc__msg[5] ),
    .send_to_inter_cgra_noc__rdy( cgra__send_to_inter_cgra_noc__rdy[5] ),
    .send_to_inter_cgra_noc__val( cgra__send_to_inter_cgra_noc__val[5] )
  );

  CgraRTL__f1d9d60478fa8731 cgra__6
  (
    .address_lower( cgra__address_lower[6] ),
    .address_upper( cgra__address_upper[6] ),
    .cgra_id( cgra__cgra_id[6] ),
    .clk( cgra__clk[6] ),
    .reset( cgra__reset[6] ),
    .recv_data_on_boundary_east__msg( cgra__recv_data_on_boundary_east__msg[6] ),
    .recv_data_on_boundary_east__rdy( cgra__recv_data_on_boundary_east__rdy[6] ),
    .recv_data_on_boundary_east__val( cgra__recv_data_on_boundary_east__val[6] ),
    .recv_data_on_boundary_north__msg( cgra__recv_data_on_boundary_north__msg[6] ),
    .recv_data_on_boundary_north__rdy( cgra__recv_data_on_boundary_north__rdy[6] ),
    .recv_data_on_boundary_north__val( cgra__recv_data_on_boundary_north__val[6] ),
    .recv_data_on_boundary_south__msg( cgra__recv_data_on_boundary_south__msg[6] ),
    .recv_data_on_boundary_south__rdy( cgra__recv_data_on_boundary_south__rdy[6] ),
    .recv_data_on_boundary_south__val( cgra__recv_data_on_boundary_south__val[6] ),
    .recv_data_on_boundary_west__msg( cgra__recv_data_on_boundary_west__msg[6] ),
    .recv_data_on_boundary_west__rdy( cgra__recv_data_on_boundary_west__rdy[6] ),
    .recv_data_on_boundary_west__val( cgra__recv_data_on_boundary_west__val[6] ),
    .recv_from_cpu_pkt__msg( cgra__recv_from_cpu_pkt__msg[6] ),
    .recv_from_cpu_pkt__rdy( cgra__recv_from_cpu_pkt__rdy[6] ),
    .recv_from_cpu_pkt__val( cgra__recv_from_cpu_pkt__val[6] ),
    .recv_from_inter_cgra_noc__msg( cgra__recv_from_inter_cgra_noc__msg[6] ),
    .recv_from_inter_cgra_noc__rdy( cgra__recv_from_inter_cgra_noc__rdy[6] ),
    .recv_from_inter_cgra_noc__val( cgra__recv_from_inter_cgra_noc__val[6] ),
    .send_data_on_boundary_east__msg( cgra__send_data_on_boundary_east__msg[6] ),
    .send_data_on_boundary_east__rdy( cgra__send_data_on_boundary_east__rdy[6] ),
    .send_data_on_boundary_east__val( cgra__send_data_on_boundary_east__val[6] ),
    .send_data_on_boundary_north__msg( cgra__send_data_on_boundary_north__msg[6] ),
    .send_data_on_boundary_north__rdy( cgra__send_data_on_boundary_north__rdy[6] ),
    .send_data_on_boundary_north__val( cgra__send_data_on_boundary_north__val[6] ),
    .send_data_on_boundary_south__msg( cgra__send_data_on_boundary_south__msg[6] ),
    .send_data_on_boundary_south__rdy( cgra__send_data_on_boundary_south__rdy[6] ),
    .send_data_on_boundary_south__val( cgra__send_data_on_boundary_south__val[6] ),
    .send_data_on_boundary_west__msg( cgra__send_data_on_boundary_west__msg[6] ),
    .send_data_on_boundary_west__rdy( cgra__send_data_on_boundary_west__rdy[6] ),
    .send_data_on_boundary_west__val( cgra__send_data_on_boundary_west__val[6] ),
    .send_to_cpu_pkt__msg( cgra__send_to_cpu_pkt__msg[6] ),
    .send_to_cpu_pkt__rdy( cgra__send_to_cpu_pkt__rdy[6] ),
    .send_to_cpu_pkt__val( cgra__send_to_cpu_pkt__val[6] ),
    .send_to_inter_cgra_noc__msg( cgra__send_to_inter_cgra_noc__msg[6] ),
    .send_to_inter_cgra_noc__rdy( cgra__send_to_inter_cgra_noc__rdy[6] ),
    .send_to_inter_cgra_noc__val( cgra__send_to_inter_cgra_noc__val[6] )
  );

  CgraRTL__f1d9d60478fa8731 cgra__7
  (
    .address_lower( cgra__address_lower[7] ),
    .address_upper( cgra__address_upper[7] ),
    .cgra_id( cgra__cgra_id[7] ),
    .clk( cgra__clk[7] ),
    .reset( cgra__reset[7] ),
    .recv_data_on_boundary_east__msg( cgra__recv_data_on_boundary_east__msg[7] ),
    .recv_data_on_boundary_east__rdy( cgra__recv_data_on_boundary_east__rdy[7] ),
    .recv_data_on_boundary_east__val( cgra__recv_data_on_boundary_east__val[7] ),
    .recv_data_on_boundary_north__msg( cgra__recv_data_on_boundary_north__msg[7] ),
    .recv_data_on_boundary_north__rdy( cgra__recv_data_on_boundary_north__rdy[7] ),
    .recv_data_on_boundary_north__val( cgra__recv_data_on_boundary_north__val[7] ),
    .recv_data_on_boundary_south__msg( cgra__recv_data_on_boundary_south__msg[7] ),
    .recv_data_on_boundary_south__rdy( cgra__recv_data_on_boundary_south__rdy[7] ),
    .recv_data_on_boundary_south__val( cgra__recv_data_on_boundary_south__val[7] ),
    .recv_data_on_boundary_west__msg( cgra__recv_data_on_boundary_west__msg[7] ),
    .recv_data_on_boundary_west__rdy( cgra__recv_data_on_boundary_west__rdy[7] ),
    .recv_data_on_boundary_west__val( cgra__recv_data_on_boundary_west__val[7] ),
    .recv_from_cpu_pkt__msg( cgra__recv_from_cpu_pkt__msg[7] ),
    .recv_from_cpu_pkt__rdy( cgra__recv_from_cpu_pkt__rdy[7] ),
    .recv_from_cpu_pkt__val( cgra__recv_from_cpu_pkt__val[7] ),
    .recv_from_inter_cgra_noc__msg( cgra__recv_from_inter_cgra_noc__msg[7] ),
    .recv_from_inter_cgra_noc__rdy( cgra__recv_from_inter_cgra_noc__rdy[7] ),
    .recv_from_inter_cgra_noc__val( cgra__recv_from_inter_cgra_noc__val[7] ),
    .send_data_on_boundary_east__msg( cgra__send_data_on_boundary_east__msg[7] ),
    .send_data_on_boundary_east__rdy( cgra__send_data_on_boundary_east__rdy[7] ),
    .send_data_on_boundary_east__val( cgra__send_data_on_boundary_east__val[7] ),
    .send_data_on_boundary_north__msg( cgra__send_data_on_boundary_north__msg[7] ),
    .send_data_on_boundary_north__rdy( cgra__send_data_on_boundary_north__rdy[7] ),
    .send_data_on_boundary_north__val( cgra__send_data_on_boundary_north__val[7] ),
    .send_data_on_boundary_south__msg( cgra__send_data_on_boundary_south__msg[7] ),
    .send_data_on_boundary_south__rdy( cgra__send_data_on_boundary_south__rdy[7] ),
    .send_data_on_boundary_south__val( cgra__send_data_on_boundary_south__val[7] ),
    .send_data_on_boundary_west__msg( cgra__send_data_on_boundary_west__msg[7] ),
    .send_data_on_boundary_west__rdy( cgra__send_data_on_boundary_west__rdy[7] ),
    .send_data_on_boundary_west__val( cgra__send_data_on_boundary_west__val[7] ),
    .send_to_cpu_pkt__msg( cgra__send_to_cpu_pkt__msg[7] ),
    .send_to_cpu_pkt__rdy( cgra__send_to_cpu_pkt__rdy[7] ),
    .send_to_cpu_pkt__val( cgra__send_to_cpu_pkt__val[7] ),
    .send_to_inter_cgra_noc__msg( cgra__send_to_inter_cgra_noc__msg[7] ),
    .send_to_inter_cgra_noc__rdy( cgra__send_to_inter_cgra_noc__rdy[7] ),
    .send_to_inter_cgra_noc__val( cgra__send_to_inter_cgra_noc__val[7] )
  );

  CgraRTL__f1d9d60478fa8731 cgra__8
  (
    .address_lower( cgra__address_lower[8] ),
    .address_upper( cgra__address_upper[8] ),
    .cgra_id( cgra__cgra_id[8] ),
    .clk( cgra__clk[8] ),
    .reset( cgra__reset[8] ),
    .recv_data_on_boundary_east__msg( cgra__recv_data_on_boundary_east__msg[8] ),
    .recv_data_on_boundary_east__rdy( cgra__recv_data_on_boundary_east__rdy[8] ),
    .recv_data_on_boundary_east__val( cgra__recv_data_on_boundary_east__val[8] ),
    .recv_data_on_boundary_north__msg( cgra__recv_data_on_boundary_north__msg[8] ),
    .recv_data_on_boundary_north__rdy( cgra__recv_data_on_boundary_north__rdy[8] ),
    .recv_data_on_boundary_north__val( cgra__recv_data_on_boundary_north__val[8] ),
    .recv_data_on_boundary_south__msg( cgra__recv_data_on_boundary_south__msg[8] ),
    .recv_data_on_boundary_south__rdy( cgra__recv_data_on_boundary_south__rdy[8] ),
    .recv_data_on_boundary_south__val( cgra__recv_data_on_boundary_south__val[8] ),
    .recv_data_on_boundary_west__msg( cgra__recv_data_on_boundary_west__msg[8] ),
    .recv_data_on_boundary_west__rdy( cgra__recv_data_on_boundary_west__rdy[8] ),
    .recv_data_on_boundary_west__val( cgra__recv_data_on_boundary_west__val[8] ),
    .recv_from_cpu_pkt__msg( cgra__recv_from_cpu_pkt__msg[8] ),
    .recv_from_cpu_pkt__rdy( cgra__recv_from_cpu_pkt__rdy[8] ),
    .recv_from_cpu_pkt__val( cgra__recv_from_cpu_pkt__val[8] ),
    .recv_from_inter_cgra_noc__msg( cgra__recv_from_inter_cgra_noc__msg[8] ),
    .recv_from_inter_cgra_noc__rdy( cgra__recv_from_inter_cgra_noc__rdy[8] ),
    .recv_from_inter_cgra_noc__val( cgra__recv_from_inter_cgra_noc__val[8] ),
    .send_data_on_boundary_east__msg( cgra__send_data_on_boundary_east__msg[8] ),
    .send_data_on_boundary_east__rdy( cgra__send_data_on_boundary_east__rdy[8] ),
    .send_data_on_boundary_east__val( cgra__send_data_on_boundary_east__val[8] ),
    .send_data_on_boundary_north__msg( cgra__send_data_on_boundary_north__msg[8] ),
    .send_data_on_boundary_north__rdy( cgra__send_data_on_boundary_north__rdy[8] ),
    .send_data_on_boundary_north__val( cgra__send_data_on_boundary_north__val[8] ),
    .send_data_on_boundary_south__msg( cgra__send_data_on_boundary_south__msg[8] ),
    .send_data_on_boundary_south__rdy( cgra__send_data_on_boundary_south__rdy[8] ),
    .send_data_on_boundary_south__val( cgra__send_data_on_boundary_south__val[8] ),
    .send_data_on_boundary_west__msg( cgra__send_data_on_boundary_west__msg[8] ),
    .send_data_on_boundary_west__rdy( cgra__send_data_on_boundary_west__rdy[8] ),
    .send_data_on_boundary_west__val( cgra__send_data_on_boundary_west__val[8] ),
    .send_to_cpu_pkt__msg( cgra__send_to_cpu_pkt__msg[8] ),
    .send_to_cpu_pkt__rdy( cgra__send_to_cpu_pkt__rdy[8] ),
    .send_to_cpu_pkt__val( cgra__send_to_cpu_pkt__val[8] ),
    .send_to_inter_cgra_noc__msg( cgra__send_to_inter_cgra_noc__msg[8] ),
    .send_to_inter_cgra_noc__rdy( cgra__send_to_inter_cgra_noc__rdy[8] ),
    .send_to_inter_cgra_noc__val( cgra__send_to_inter_cgra_noc__val[8] )
  );

  //-------------------------------------------------------------
  // End of component cgra[0:8]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mesh
  //-------------------------------------------------------------

  logic [0:0] mesh__clk;
  logic [0:0] mesh__reset;
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d mesh__recv__msg [0:8];
  logic [0:0] mesh__recv__rdy [0:8];
  logic [0:0] mesh__recv__val [0:8];
  InterCgraPacket_9_3x3_4_8_4_CgraPayload__50d0cebf6ea0889d mesh__send__msg [0:8];
  logic [0:0] mesh__send__rdy [0:8];
  logic [0:0] mesh__send__val [0:8];

  MeshNetworkRTL__b809e6737c6ce9e8 mesh
  (
    .clk( mesh__clk ),
    .reset( mesh__reset ),
    .recv__msg( mesh__recv__msg ),
    .recv__rdy( mesh__recv__rdy ),
    .recv__val( mesh__recv__val ),
    .send__msg( mesh__send__msg ),
    .send__rdy( mesh__send__rdy ),
    .send__val( mesh__send__val )
  );

  //-------------------------------------------------------------
  // End of component mesh
  //-------------------------------------------------------------

  assign cgra__clk[0] = clk;
  assign cgra__reset[0] = reset;
  assign cgra__clk[1] = clk;
  assign cgra__reset[1] = reset;
  assign cgra__clk[2] = clk;
  assign cgra__reset[2] = reset;
  assign cgra__clk[3] = clk;
  assign cgra__reset[3] = reset;
  assign cgra__clk[4] = clk;
  assign cgra__reset[4] = reset;
  assign cgra__clk[5] = clk;
  assign cgra__reset[5] = reset;
  assign cgra__clk[6] = clk;
  assign cgra__reset[6] = reset;
  assign cgra__clk[7] = clk;
  assign cgra__reset[7] = reset;
  assign cgra__clk[8] = clk;
  assign cgra__reset[8] = reset;
  assign mesh__clk = clk;
  assign mesh__reset = reset;
  assign cgra__recv_from_inter_cgra_noc__msg[0] = mesh__send__msg[0];
  assign mesh__send__rdy[0] = cgra__recv_from_inter_cgra_noc__rdy[0];
  assign cgra__recv_from_inter_cgra_noc__val[0] = mesh__send__val[0];
  assign mesh__recv__msg[0] = cgra__send_to_inter_cgra_noc__msg[0];
  assign cgra__send_to_inter_cgra_noc__rdy[0] = mesh__recv__rdy[0];
  assign mesh__recv__val[0] = cgra__send_to_inter_cgra_noc__val[0];
  assign cgra__recv_from_inter_cgra_noc__msg[1] = mesh__send__msg[1];
  assign mesh__send__rdy[1] = cgra__recv_from_inter_cgra_noc__rdy[1];
  assign cgra__recv_from_inter_cgra_noc__val[1] = mesh__send__val[1];
  assign mesh__recv__msg[1] = cgra__send_to_inter_cgra_noc__msg[1];
  assign cgra__send_to_inter_cgra_noc__rdy[1] = mesh__recv__rdy[1];
  assign mesh__recv__val[1] = cgra__send_to_inter_cgra_noc__val[1];
  assign cgra__recv_from_inter_cgra_noc__msg[2] = mesh__send__msg[2];
  assign mesh__send__rdy[2] = cgra__recv_from_inter_cgra_noc__rdy[2];
  assign cgra__recv_from_inter_cgra_noc__val[2] = mesh__send__val[2];
  assign mesh__recv__msg[2] = cgra__send_to_inter_cgra_noc__msg[2];
  assign cgra__send_to_inter_cgra_noc__rdy[2] = mesh__recv__rdy[2];
  assign mesh__recv__val[2] = cgra__send_to_inter_cgra_noc__val[2];
  assign cgra__recv_from_inter_cgra_noc__msg[3] = mesh__send__msg[3];
  assign mesh__send__rdy[3] = cgra__recv_from_inter_cgra_noc__rdy[3];
  assign cgra__recv_from_inter_cgra_noc__val[3] = mesh__send__val[3];
  assign mesh__recv__msg[3] = cgra__send_to_inter_cgra_noc__msg[3];
  assign cgra__send_to_inter_cgra_noc__rdy[3] = mesh__recv__rdy[3];
  assign mesh__recv__val[3] = cgra__send_to_inter_cgra_noc__val[3];
  assign cgra__recv_from_inter_cgra_noc__msg[4] = mesh__send__msg[4];
  assign mesh__send__rdy[4] = cgra__recv_from_inter_cgra_noc__rdy[4];
  assign cgra__recv_from_inter_cgra_noc__val[4] = mesh__send__val[4];
  assign mesh__recv__msg[4] = cgra__send_to_inter_cgra_noc__msg[4];
  assign cgra__send_to_inter_cgra_noc__rdy[4] = mesh__recv__rdy[4];
  assign mesh__recv__val[4] = cgra__send_to_inter_cgra_noc__val[4];
  assign cgra__recv_from_inter_cgra_noc__msg[5] = mesh__send__msg[5];
  assign mesh__send__rdy[5] = cgra__recv_from_inter_cgra_noc__rdy[5];
  assign cgra__recv_from_inter_cgra_noc__val[5] = mesh__send__val[5];
  assign mesh__recv__msg[5] = cgra__send_to_inter_cgra_noc__msg[5];
  assign cgra__send_to_inter_cgra_noc__rdy[5] = mesh__recv__rdy[5];
  assign mesh__recv__val[5] = cgra__send_to_inter_cgra_noc__val[5];
  assign cgra__recv_from_inter_cgra_noc__msg[6] = mesh__send__msg[6];
  assign mesh__send__rdy[6] = cgra__recv_from_inter_cgra_noc__rdy[6];
  assign cgra__recv_from_inter_cgra_noc__val[6] = mesh__send__val[6];
  assign mesh__recv__msg[6] = cgra__send_to_inter_cgra_noc__msg[6];
  assign cgra__send_to_inter_cgra_noc__rdy[6] = mesh__recv__rdy[6];
  assign mesh__recv__val[6] = cgra__send_to_inter_cgra_noc__val[6];
  assign cgra__recv_from_inter_cgra_noc__msg[7] = mesh__send__msg[7];
  assign mesh__send__rdy[7] = cgra__recv_from_inter_cgra_noc__rdy[7];
  assign cgra__recv_from_inter_cgra_noc__val[7] = mesh__send__val[7];
  assign mesh__recv__msg[7] = cgra__send_to_inter_cgra_noc__msg[7];
  assign cgra__send_to_inter_cgra_noc__rdy[7] = mesh__recv__rdy[7];
  assign mesh__recv__val[7] = cgra__send_to_inter_cgra_noc__val[7];
  assign cgra__recv_from_inter_cgra_noc__msg[8] = mesh__send__msg[8];
  assign mesh__send__rdy[8] = cgra__recv_from_inter_cgra_noc__rdy[8];
  assign cgra__recv_from_inter_cgra_noc__val[8] = mesh__send__val[8];
  assign mesh__recv__msg[8] = cgra__send_to_inter_cgra_noc__msg[8];
  assign cgra__send_to_inter_cgra_noc__rdy[8] = mesh__recv__rdy[8];
  assign mesh__recv__val[8] = cgra__send_to_inter_cgra_noc__val[8];
  assign cgra__cgra_id[0] = 4'd0;
  assign cgra__cgra_id[1] = 4'd1;
  assign cgra__cgra_id[2] = 4'd2;
  assign cgra__cgra_id[3] = 4'd3;
  assign cgra__cgra_id[4] = 4'd4;
  assign cgra__cgra_id[5] = 4'd5;
  assign cgra__cgra_id[6] = 4'd6;
  assign cgra__cgra_id[7] = 4'd7;
  assign cgra__cgra_id[8] = 4'd8;
  assign cgra__address_lower[0] = 9'd0;
  assign cgra__address_upper[0] = 9'd31;
  assign cgra__address_lower[1] = 9'd32;
  assign cgra__address_upper[1] = 9'd63;
  assign cgra__address_lower[2] = 9'd64;
  assign cgra__address_upper[2] = 9'd95;
  assign cgra__address_lower[3] = 9'd96;
  assign cgra__address_upper[3] = 9'd127;
  assign cgra__address_lower[4] = 9'd128;
  assign cgra__address_upper[4] = 9'd159;
  assign cgra__address_lower[5] = 9'd160;
  assign cgra__address_upper[5] = 9'd191;
  assign cgra__address_lower[6] = 9'd192;
  assign cgra__address_upper[6] = 9'd223;
  assign cgra__address_lower[7] = 9'd224;
  assign cgra__address_upper[7] = 9'd255;
  assign cgra__address_lower[8] = 9'd256;
  assign cgra__address_upper[8] = 9'd287;
  assign cgra__recv_from_cpu_pkt__msg[0] = recv_from_cpu_pkt__msg;
  assign recv_from_cpu_pkt__rdy = cgra__recv_from_cpu_pkt__rdy[0];
  assign cgra__recv_from_cpu_pkt__val[0] = recv_from_cpu_pkt__val;
  assign send_to_cpu_pkt__msg = cgra__send_to_cpu_pkt__msg[0];
  assign cgra__send_to_cpu_pkt__rdy[0] = send_to_cpu_pkt__rdy;
  assign send_to_cpu_pkt__val = cgra__send_to_cpu_pkt__val[0];
  assign cgra__recv_from_cpu_pkt__val[1] = 1'd0;
  assign cgra__recv_from_cpu_pkt__msg[1] = { 3'd0, 3'd0, 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 8'd0, 1'd0, { 4'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 9'd0, { 6'd0, 1'd0, { {3'd0, 3'd0, 3'd0, 3'd0} }, { {3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0} }, { {2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, 3'd0, 1'd0, { {2'd0, 2'd0, 2'd0, 2'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} } }, 4'd0 } };
  assign cgra__send_to_cpu_pkt__rdy[1] = 1'd0;
  assign cgra__recv_from_cpu_pkt__val[2] = 1'd0;
  assign cgra__recv_from_cpu_pkt__msg[2] = { 3'd0, 3'd0, 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 8'd0, 1'd0, { 4'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 9'd0, { 6'd0, 1'd0, { {3'd0, 3'd0, 3'd0, 3'd0} }, { {3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0} }, { {2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, 3'd0, 1'd0, { {2'd0, 2'd0, 2'd0, 2'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} } }, 4'd0 } };
  assign cgra__send_to_cpu_pkt__rdy[2] = 1'd0;
  assign cgra__recv_from_cpu_pkt__val[3] = 1'd0;
  assign cgra__recv_from_cpu_pkt__msg[3] = { 3'd0, 3'd0, 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 8'd0, 1'd0, { 4'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 9'd0, { 6'd0, 1'd0, { {3'd0, 3'd0, 3'd0, 3'd0} }, { {3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0} }, { {2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, 3'd0, 1'd0, { {2'd0, 2'd0, 2'd0, 2'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} } }, 4'd0 } };
  assign cgra__send_to_cpu_pkt__rdy[3] = 1'd0;
  assign cgra__recv_from_cpu_pkt__val[4] = 1'd0;
  assign cgra__recv_from_cpu_pkt__msg[4] = { 3'd0, 3'd0, 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 8'd0, 1'd0, { 4'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 9'd0, { 6'd0, 1'd0, { {3'd0, 3'd0, 3'd0, 3'd0} }, { {3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0} }, { {2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, 3'd0, 1'd0, { {2'd0, 2'd0, 2'd0, 2'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} } }, 4'd0 } };
  assign cgra__send_to_cpu_pkt__rdy[4] = 1'd0;
  assign cgra__recv_from_cpu_pkt__val[5] = 1'd0;
  assign cgra__recv_from_cpu_pkt__msg[5] = { 3'd0, 3'd0, 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 8'd0, 1'd0, { 4'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 9'd0, { 6'd0, 1'd0, { {3'd0, 3'd0, 3'd0, 3'd0} }, { {3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0} }, { {2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, 3'd0, 1'd0, { {2'd0, 2'd0, 2'd0, 2'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} } }, 4'd0 } };
  assign cgra__send_to_cpu_pkt__rdy[5] = 1'd0;
  assign cgra__recv_from_cpu_pkt__val[6] = 1'd0;
  assign cgra__recv_from_cpu_pkt__msg[6] = { 3'd0, 3'd0, 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 8'd0, 1'd0, { 4'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 9'd0, { 6'd0, 1'd0, { {3'd0, 3'd0, 3'd0, 3'd0} }, { {3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0} }, { {2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, 3'd0, 1'd0, { {2'd0, 2'd0, 2'd0, 2'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} } }, 4'd0 } };
  assign cgra__send_to_cpu_pkt__rdy[6] = 1'd0;
  assign cgra__recv_from_cpu_pkt__val[7] = 1'd0;
  assign cgra__recv_from_cpu_pkt__msg[7] = { 3'd0, 3'd0, 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 8'd0, 1'd0, { 4'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 9'd0, { 6'd0, 1'd0, { {3'd0, 3'd0, 3'd0, 3'd0} }, { {3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0} }, { {2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, 3'd0, 1'd0, { {2'd0, 2'd0, 2'd0, 2'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} } }, 4'd0 } };
  assign cgra__send_to_cpu_pkt__rdy[7] = 1'd0;
  assign cgra__recv_from_cpu_pkt__val[8] = 1'd0;
  assign cgra__recv_from_cpu_pkt__msg[8] = { 3'd0, 3'd0, 4'd0, 4'd0, 2'd0, 2'd0, 2'd0, 2'd0, 8'd0, 1'd0, { 4'd0, { 32'd0, 1'd0, 1'd0, 1'd0 }, 9'd0, { 6'd0, 1'd0, { {3'd0, 3'd0, 3'd0, 3'd0} }, { {3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0, 3'd0} }, { {2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, 3'd0, 1'd0, { {2'd0, 2'd0, 2'd0, 2'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} }, { {1'd0, 1'd0, 1'd0, 1'd0} }, { {4'd0, 4'd0, 4'd0, 4'd0} } }, 4'd0 } };
  assign cgra__send_to_cpu_pkt__rdy[8] = 1'd0;
  assign cgra__send_data_on_boundary_south__rdy[0][0] = 1'd0;
  assign cgra__recv_data_on_boundary_south__val[0][0] = 1'd0;
  assign cgra__recv_data_on_boundary_south__msg[0][0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__send_data_on_boundary_south__rdy[0][1] = 1'd0;
  assign cgra__recv_data_on_boundary_south__val[0][1] = 1'd0;
  assign cgra__recv_data_on_boundary_south__msg[0][1] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__send_data_on_boundary_west__rdy[0][0] = 1'd0;
  assign cgra__recv_data_on_boundary_west__val[0][0] = 1'd0;
  assign cgra__recv_data_on_boundary_west__msg[0][0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__send_data_on_boundary_west__rdy[0][1] = 1'd0;
  assign cgra__recv_data_on_boundary_west__val[0][1] = 1'd0;
  assign cgra__recv_data_on_boundary_west__msg[0][1] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__send_data_on_boundary_south__rdy[1][0] = 1'd0;
  assign cgra__recv_data_on_boundary_south__val[1][0] = 1'd0;
  assign cgra__recv_data_on_boundary_south__msg[1][0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__send_data_on_boundary_south__rdy[1][1] = 1'd0;
  assign cgra__recv_data_on_boundary_south__val[1][1] = 1'd0;
  assign cgra__recv_data_on_boundary_south__msg[1][1] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__recv_data_on_boundary_east__msg[0][0] = cgra__send_data_on_boundary_west__msg[1][0];
  assign cgra__send_data_on_boundary_west__rdy[1][0] = cgra__recv_data_on_boundary_east__rdy[0][0];
  assign cgra__recv_data_on_boundary_east__val[0][0] = cgra__send_data_on_boundary_west__val[1][0];
  assign cgra__recv_data_on_boundary_west__msg[1][0] = cgra__send_data_on_boundary_east__msg[0][0];
  assign cgra__send_data_on_boundary_east__rdy[0][0] = cgra__recv_data_on_boundary_west__rdy[1][0];
  assign cgra__recv_data_on_boundary_west__val[1][0] = cgra__send_data_on_boundary_east__val[0][0];
  assign cgra__recv_data_on_boundary_east__msg[0][1] = cgra__send_data_on_boundary_west__msg[1][1];
  assign cgra__send_data_on_boundary_west__rdy[1][1] = cgra__recv_data_on_boundary_east__rdy[0][1];
  assign cgra__recv_data_on_boundary_east__val[0][1] = cgra__send_data_on_boundary_west__val[1][1];
  assign cgra__recv_data_on_boundary_west__msg[1][1] = cgra__send_data_on_boundary_east__msg[0][1];
  assign cgra__send_data_on_boundary_east__rdy[0][1] = cgra__recv_data_on_boundary_west__rdy[1][1];
  assign cgra__recv_data_on_boundary_west__val[1][1] = cgra__send_data_on_boundary_east__val[0][1];
  assign cgra__send_data_on_boundary_south__rdy[2][0] = 1'd0;
  assign cgra__recv_data_on_boundary_south__val[2][0] = 1'd0;
  assign cgra__recv_data_on_boundary_south__msg[2][0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__send_data_on_boundary_south__rdy[2][1] = 1'd0;
  assign cgra__recv_data_on_boundary_south__val[2][1] = 1'd0;
  assign cgra__recv_data_on_boundary_south__msg[2][1] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__recv_data_on_boundary_east__msg[1][0] = cgra__send_data_on_boundary_west__msg[2][0];
  assign cgra__send_data_on_boundary_west__rdy[2][0] = cgra__recv_data_on_boundary_east__rdy[1][0];
  assign cgra__recv_data_on_boundary_east__val[1][0] = cgra__send_data_on_boundary_west__val[2][0];
  assign cgra__recv_data_on_boundary_west__msg[2][0] = cgra__send_data_on_boundary_east__msg[1][0];
  assign cgra__send_data_on_boundary_east__rdy[1][0] = cgra__recv_data_on_boundary_west__rdy[2][0];
  assign cgra__recv_data_on_boundary_west__val[2][0] = cgra__send_data_on_boundary_east__val[1][0];
  assign cgra__recv_data_on_boundary_east__msg[1][1] = cgra__send_data_on_boundary_west__msg[2][1];
  assign cgra__send_data_on_boundary_west__rdy[2][1] = cgra__recv_data_on_boundary_east__rdy[1][1];
  assign cgra__recv_data_on_boundary_east__val[1][1] = cgra__send_data_on_boundary_west__val[2][1];
  assign cgra__recv_data_on_boundary_west__msg[2][1] = cgra__send_data_on_boundary_east__msg[1][1];
  assign cgra__send_data_on_boundary_east__rdy[1][1] = cgra__recv_data_on_boundary_west__rdy[2][1];
  assign cgra__recv_data_on_boundary_west__val[2][1] = cgra__send_data_on_boundary_east__val[1][1];
  assign cgra__send_data_on_boundary_east__rdy[2][0] = 1'd0;
  assign cgra__recv_data_on_boundary_east__val[2][0] = 1'd0;
  assign cgra__recv_data_on_boundary_east__msg[2][0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__send_data_on_boundary_east__rdy[2][1] = 1'd0;
  assign cgra__recv_data_on_boundary_east__val[2][1] = 1'd0;
  assign cgra__recv_data_on_boundary_east__msg[2][1] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__recv_data_on_boundary_north__msg[0][0] = cgra__send_data_on_boundary_south__msg[3][0];
  assign cgra__send_data_on_boundary_south__rdy[3][0] = cgra__recv_data_on_boundary_north__rdy[0][0];
  assign cgra__recv_data_on_boundary_north__val[0][0] = cgra__send_data_on_boundary_south__val[3][0];
  assign cgra__recv_data_on_boundary_south__msg[3][0] = cgra__send_data_on_boundary_north__msg[0][0];
  assign cgra__send_data_on_boundary_north__rdy[0][0] = cgra__recv_data_on_boundary_south__rdy[3][0];
  assign cgra__recv_data_on_boundary_south__val[3][0] = cgra__send_data_on_boundary_north__val[0][0];
  assign cgra__recv_data_on_boundary_north__msg[0][1] = cgra__send_data_on_boundary_south__msg[3][1];
  assign cgra__send_data_on_boundary_south__rdy[3][1] = cgra__recv_data_on_boundary_north__rdy[0][1];
  assign cgra__recv_data_on_boundary_north__val[0][1] = cgra__send_data_on_boundary_south__val[3][1];
  assign cgra__recv_data_on_boundary_south__msg[3][1] = cgra__send_data_on_boundary_north__msg[0][1];
  assign cgra__send_data_on_boundary_north__rdy[0][1] = cgra__recv_data_on_boundary_south__rdy[3][1];
  assign cgra__recv_data_on_boundary_south__val[3][1] = cgra__send_data_on_boundary_north__val[0][1];
  assign cgra__send_data_on_boundary_west__rdy[3][0] = 1'd0;
  assign cgra__recv_data_on_boundary_west__val[3][0] = 1'd0;
  assign cgra__recv_data_on_boundary_west__msg[3][0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__send_data_on_boundary_west__rdy[3][1] = 1'd0;
  assign cgra__recv_data_on_boundary_west__val[3][1] = 1'd0;
  assign cgra__recv_data_on_boundary_west__msg[3][1] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__recv_data_on_boundary_north__msg[1][0] = cgra__send_data_on_boundary_south__msg[4][0];
  assign cgra__send_data_on_boundary_south__rdy[4][0] = cgra__recv_data_on_boundary_north__rdy[1][0];
  assign cgra__recv_data_on_boundary_north__val[1][0] = cgra__send_data_on_boundary_south__val[4][0];
  assign cgra__recv_data_on_boundary_south__msg[4][0] = cgra__send_data_on_boundary_north__msg[1][0];
  assign cgra__send_data_on_boundary_north__rdy[1][0] = cgra__recv_data_on_boundary_south__rdy[4][0];
  assign cgra__recv_data_on_boundary_south__val[4][0] = cgra__send_data_on_boundary_north__val[1][0];
  assign cgra__recv_data_on_boundary_north__msg[1][1] = cgra__send_data_on_boundary_south__msg[4][1];
  assign cgra__send_data_on_boundary_south__rdy[4][1] = cgra__recv_data_on_boundary_north__rdy[1][1];
  assign cgra__recv_data_on_boundary_north__val[1][1] = cgra__send_data_on_boundary_south__val[4][1];
  assign cgra__recv_data_on_boundary_south__msg[4][1] = cgra__send_data_on_boundary_north__msg[1][1];
  assign cgra__send_data_on_boundary_north__rdy[1][1] = cgra__recv_data_on_boundary_south__rdy[4][1];
  assign cgra__recv_data_on_boundary_south__val[4][1] = cgra__send_data_on_boundary_north__val[1][1];
  assign cgra__recv_data_on_boundary_east__msg[3][0] = cgra__send_data_on_boundary_west__msg[4][0];
  assign cgra__send_data_on_boundary_west__rdy[4][0] = cgra__recv_data_on_boundary_east__rdy[3][0];
  assign cgra__recv_data_on_boundary_east__val[3][0] = cgra__send_data_on_boundary_west__val[4][0];
  assign cgra__recv_data_on_boundary_west__msg[4][0] = cgra__send_data_on_boundary_east__msg[3][0];
  assign cgra__send_data_on_boundary_east__rdy[3][0] = cgra__recv_data_on_boundary_west__rdy[4][0];
  assign cgra__recv_data_on_boundary_west__val[4][0] = cgra__send_data_on_boundary_east__val[3][0];
  assign cgra__recv_data_on_boundary_east__msg[3][1] = cgra__send_data_on_boundary_west__msg[4][1];
  assign cgra__send_data_on_boundary_west__rdy[4][1] = cgra__recv_data_on_boundary_east__rdy[3][1];
  assign cgra__recv_data_on_boundary_east__val[3][1] = cgra__send_data_on_boundary_west__val[4][1];
  assign cgra__recv_data_on_boundary_west__msg[4][1] = cgra__send_data_on_boundary_east__msg[3][1];
  assign cgra__send_data_on_boundary_east__rdy[3][1] = cgra__recv_data_on_boundary_west__rdy[4][1];
  assign cgra__recv_data_on_boundary_west__val[4][1] = cgra__send_data_on_boundary_east__val[3][1];
  assign cgra__recv_data_on_boundary_north__msg[2][0] = cgra__send_data_on_boundary_south__msg[5][0];
  assign cgra__send_data_on_boundary_south__rdy[5][0] = cgra__recv_data_on_boundary_north__rdy[2][0];
  assign cgra__recv_data_on_boundary_north__val[2][0] = cgra__send_data_on_boundary_south__val[5][0];
  assign cgra__recv_data_on_boundary_south__msg[5][0] = cgra__send_data_on_boundary_north__msg[2][0];
  assign cgra__send_data_on_boundary_north__rdy[2][0] = cgra__recv_data_on_boundary_south__rdy[5][0];
  assign cgra__recv_data_on_boundary_south__val[5][0] = cgra__send_data_on_boundary_north__val[2][0];
  assign cgra__recv_data_on_boundary_north__msg[2][1] = cgra__send_data_on_boundary_south__msg[5][1];
  assign cgra__send_data_on_boundary_south__rdy[5][1] = cgra__recv_data_on_boundary_north__rdy[2][1];
  assign cgra__recv_data_on_boundary_north__val[2][1] = cgra__send_data_on_boundary_south__val[5][1];
  assign cgra__recv_data_on_boundary_south__msg[5][1] = cgra__send_data_on_boundary_north__msg[2][1];
  assign cgra__send_data_on_boundary_north__rdy[2][1] = cgra__recv_data_on_boundary_south__rdy[5][1];
  assign cgra__recv_data_on_boundary_south__val[5][1] = cgra__send_data_on_boundary_north__val[2][1];
  assign cgra__recv_data_on_boundary_east__msg[4][0] = cgra__send_data_on_boundary_west__msg[5][0];
  assign cgra__send_data_on_boundary_west__rdy[5][0] = cgra__recv_data_on_boundary_east__rdy[4][0];
  assign cgra__recv_data_on_boundary_east__val[4][0] = cgra__send_data_on_boundary_west__val[5][0];
  assign cgra__recv_data_on_boundary_west__msg[5][0] = cgra__send_data_on_boundary_east__msg[4][0];
  assign cgra__send_data_on_boundary_east__rdy[4][0] = cgra__recv_data_on_boundary_west__rdy[5][0];
  assign cgra__recv_data_on_boundary_west__val[5][0] = cgra__send_data_on_boundary_east__val[4][0];
  assign cgra__recv_data_on_boundary_east__msg[4][1] = cgra__send_data_on_boundary_west__msg[5][1];
  assign cgra__send_data_on_boundary_west__rdy[5][1] = cgra__recv_data_on_boundary_east__rdy[4][1];
  assign cgra__recv_data_on_boundary_east__val[4][1] = cgra__send_data_on_boundary_west__val[5][1];
  assign cgra__recv_data_on_boundary_west__msg[5][1] = cgra__send_data_on_boundary_east__msg[4][1];
  assign cgra__send_data_on_boundary_east__rdy[4][1] = cgra__recv_data_on_boundary_west__rdy[5][1];
  assign cgra__recv_data_on_boundary_west__val[5][1] = cgra__send_data_on_boundary_east__val[4][1];
  assign cgra__send_data_on_boundary_east__rdy[5][0] = 1'd0;
  assign cgra__recv_data_on_boundary_east__val[5][0] = 1'd0;
  assign cgra__recv_data_on_boundary_east__msg[5][0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__send_data_on_boundary_east__rdy[5][1] = 1'd0;
  assign cgra__recv_data_on_boundary_east__val[5][1] = 1'd0;
  assign cgra__recv_data_on_boundary_east__msg[5][1] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__recv_data_on_boundary_north__msg[3][0] = cgra__send_data_on_boundary_south__msg[6][0];
  assign cgra__send_data_on_boundary_south__rdy[6][0] = cgra__recv_data_on_boundary_north__rdy[3][0];
  assign cgra__recv_data_on_boundary_north__val[3][0] = cgra__send_data_on_boundary_south__val[6][0];
  assign cgra__recv_data_on_boundary_south__msg[6][0] = cgra__send_data_on_boundary_north__msg[3][0];
  assign cgra__send_data_on_boundary_north__rdy[3][0] = cgra__recv_data_on_boundary_south__rdy[6][0];
  assign cgra__recv_data_on_boundary_south__val[6][0] = cgra__send_data_on_boundary_north__val[3][0];
  assign cgra__recv_data_on_boundary_north__msg[3][1] = cgra__send_data_on_boundary_south__msg[6][1];
  assign cgra__send_data_on_boundary_south__rdy[6][1] = cgra__recv_data_on_boundary_north__rdy[3][1];
  assign cgra__recv_data_on_boundary_north__val[3][1] = cgra__send_data_on_boundary_south__val[6][1];
  assign cgra__recv_data_on_boundary_south__msg[6][1] = cgra__send_data_on_boundary_north__msg[3][1];
  assign cgra__send_data_on_boundary_north__rdy[3][1] = cgra__recv_data_on_boundary_south__rdy[6][1];
  assign cgra__recv_data_on_boundary_south__val[6][1] = cgra__send_data_on_boundary_north__val[3][1];
  assign cgra__send_data_on_boundary_north__rdy[6][0] = 1'd0;
  assign cgra__recv_data_on_boundary_north__val[6][0] = 1'd0;
  assign cgra__recv_data_on_boundary_north__msg[6][0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__send_data_on_boundary_north__rdy[6][1] = 1'd0;
  assign cgra__recv_data_on_boundary_north__val[6][1] = 1'd0;
  assign cgra__recv_data_on_boundary_north__msg[6][1] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__send_data_on_boundary_west__rdy[6][0] = 1'd0;
  assign cgra__recv_data_on_boundary_west__val[6][0] = 1'd0;
  assign cgra__recv_data_on_boundary_west__msg[6][0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__send_data_on_boundary_west__rdy[6][1] = 1'd0;
  assign cgra__recv_data_on_boundary_west__val[6][1] = 1'd0;
  assign cgra__recv_data_on_boundary_west__msg[6][1] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__recv_data_on_boundary_north__msg[4][0] = cgra__send_data_on_boundary_south__msg[7][0];
  assign cgra__send_data_on_boundary_south__rdy[7][0] = cgra__recv_data_on_boundary_north__rdy[4][0];
  assign cgra__recv_data_on_boundary_north__val[4][0] = cgra__send_data_on_boundary_south__val[7][0];
  assign cgra__recv_data_on_boundary_south__msg[7][0] = cgra__send_data_on_boundary_north__msg[4][0];
  assign cgra__send_data_on_boundary_north__rdy[4][0] = cgra__recv_data_on_boundary_south__rdy[7][0];
  assign cgra__recv_data_on_boundary_south__val[7][0] = cgra__send_data_on_boundary_north__val[4][0];
  assign cgra__recv_data_on_boundary_north__msg[4][1] = cgra__send_data_on_boundary_south__msg[7][1];
  assign cgra__send_data_on_boundary_south__rdy[7][1] = cgra__recv_data_on_boundary_north__rdy[4][1];
  assign cgra__recv_data_on_boundary_north__val[4][1] = cgra__send_data_on_boundary_south__val[7][1];
  assign cgra__recv_data_on_boundary_south__msg[7][1] = cgra__send_data_on_boundary_north__msg[4][1];
  assign cgra__send_data_on_boundary_north__rdy[4][1] = cgra__recv_data_on_boundary_south__rdy[7][1];
  assign cgra__recv_data_on_boundary_south__val[7][1] = cgra__send_data_on_boundary_north__val[4][1];
  assign cgra__send_data_on_boundary_north__rdy[7][0] = 1'd0;
  assign cgra__recv_data_on_boundary_north__val[7][0] = 1'd0;
  assign cgra__recv_data_on_boundary_north__msg[7][0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__send_data_on_boundary_north__rdy[7][1] = 1'd0;
  assign cgra__recv_data_on_boundary_north__val[7][1] = 1'd0;
  assign cgra__recv_data_on_boundary_north__msg[7][1] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__recv_data_on_boundary_east__msg[6][0] = cgra__send_data_on_boundary_west__msg[7][0];
  assign cgra__send_data_on_boundary_west__rdy[7][0] = cgra__recv_data_on_boundary_east__rdy[6][0];
  assign cgra__recv_data_on_boundary_east__val[6][0] = cgra__send_data_on_boundary_west__val[7][0];
  assign cgra__recv_data_on_boundary_west__msg[7][0] = cgra__send_data_on_boundary_east__msg[6][0];
  assign cgra__send_data_on_boundary_east__rdy[6][0] = cgra__recv_data_on_boundary_west__rdy[7][0];
  assign cgra__recv_data_on_boundary_west__val[7][0] = cgra__send_data_on_boundary_east__val[6][0];
  assign cgra__recv_data_on_boundary_east__msg[6][1] = cgra__send_data_on_boundary_west__msg[7][1];
  assign cgra__send_data_on_boundary_west__rdy[7][1] = cgra__recv_data_on_boundary_east__rdy[6][1];
  assign cgra__recv_data_on_boundary_east__val[6][1] = cgra__send_data_on_boundary_west__val[7][1];
  assign cgra__recv_data_on_boundary_west__msg[7][1] = cgra__send_data_on_boundary_east__msg[6][1];
  assign cgra__send_data_on_boundary_east__rdy[6][1] = cgra__recv_data_on_boundary_west__rdy[7][1];
  assign cgra__recv_data_on_boundary_west__val[7][1] = cgra__send_data_on_boundary_east__val[6][1];
  assign cgra__recv_data_on_boundary_north__msg[5][0] = cgra__send_data_on_boundary_south__msg[8][0];
  assign cgra__send_data_on_boundary_south__rdy[8][0] = cgra__recv_data_on_boundary_north__rdy[5][0];
  assign cgra__recv_data_on_boundary_north__val[5][0] = cgra__send_data_on_boundary_south__val[8][0];
  assign cgra__recv_data_on_boundary_south__msg[8][0] = cgra__send_data_on_boundary_north__msg[5][0];
  assign cgra__send_data_on_boundary_north__rdy[5][0] = cgra__recv_data_on_boundary_south__rdy[8][0];
  assign cgra__recv_data_on_boundary_south__val[8][0] = cgra__send_data_on_boundary_north__val[5][0];
  assign cgra__recv_data_on_boundary_north__msg[5][1] = cgra__send_data_on_boundary_south__msg[8][1];
  assign cgra__send_data_on_boundary_south__rdy[8][1] = cgra__recv_data_on_boundary_north__rdy[5][1];
  assign cgra__recv_data_on_boundary_north__val[5][1] = cgra__send_data_on_boundary_south__val[8][1];
  assign cgra__recv_data_on_boundary_south__msg[8][1] = cgra__send_data_on_boundary_north__msg[5][1];
  assign cgra__send_data_on_boundary_north__rdy[5][1] = cgra__recv_data_on_boundary_south__rdy[8][1];
  assign cgra__recv_data_on_boundary_south__val[8][1] = cgra__send_data_on_boundary_north__val[5][1];
  assign cgra__send_data_on_boundary_north__rdy[8][0] = 1'd0;
  assign cgra__recv_data_on_boundary_north__val[8][0] = 1'd0;
  assign cgra__recv_data_on_boundary_north__msg[8][0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__send_data_on_boundary_north__rdy[8][1] = 1'd0;
  assign cgra__recv_data_on_boundary_north__val[8][1] = 1'd0;
  assign cgra__recv_data_on_boundary_north__msg[8][1] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__recv_data_on_boundary_east__msg[7][0] = cgra__send_data_on_boundary_west__msg[8][0];
  assign cgra__send_data_on_boundary_west__rdy[8][0] = cgra__recv_data_on_boundary_east__rdy[7][0];
  assign cgra__recv_data_on_boundary_east__val[7][0] = cgra__send_data_on_boundary_west__val[8][0];
  assign cgra__recv_data_on_boundary_west__msg[8][0] = cgra__send_data_on_boundary_east__msg[7][0];
  assign cgra__send_data_on_boundary_east__rdy[7][0] = cgra__recv_data_on_boundary_west__rdy[8][0];
  assign cgra__recv_data_on_boundary_west__val[8][0] = cgra__send_data_on_boundary_east__val[7][0];
  assign cgra__recv_data_on_boundary_east__msg[7][1] = cgra__send_data_on_boundary_west__msg[8][1];
  assign cgra__send_data_on_boundary_west__rdy[8][1] = cgra__recv_data_on_boundary_east__rdy[7][1];
  assign cgra__recv_data_on_boundary_east__val[7][1] = cgra__send_data_on_boundary_west__val[8][1];
  assign cgra__recv_data_on_boundary_west__msg[8][1] = cgra__send_data_on_boundary_east__msg[7][1];
  assign cgra__send_data_on_boundary_east__rdy[7][1] = cgra__recv_data_on_boundary_west__rdy[8][1];
  assign cgra__recv_data_on_boundary_west__val[8][1] = cgra__send_data_on_boundary_east__val[7][1];
  assign cgra__send_data_on_boundary_east__rdy[8][0] = 1'd0;
  assign cgra__recv_data_on_boundary_east__val[8][0] = 1'd0;
  assign cgra__recv_data_on_boundary_east__msg[8][0] = { 32'd0, 1'd0, 1'd0, 1'd0 };
  assign cgra__send_data_on_boundary_east__rdy[8][1] = 1'd0;
  assign cgra__recv_data_on_boundary_east__val[8][1] = 1'd0;
  assign cgra__recv_data_on_boundary_east__msg[8][1] = { 32'd0, 1'd0, 1'd0, 1'd0 };

endmodule
